[{"filePath":"/Users/damon/liquid-spark-finance/e2e/all-interactions.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":13,"column":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\n// Load the manifest generated during globalSetup.\nconst manifestPath = path.resolve(process.cwd(), 'ui-map.json');\nif (!fs.existsSync(manifestPath)) {\n  throw new Error(\n    'UI interaction manifest not found â€“ make sure globalSetup generated ui-map.json before running this test.'\n  );\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nconst manifest: Array<{\n  selector: string;\n  type: string;\n  originPage: string;\n  expectUrlChange: boolean;\n}> = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));\n\nasync function captureErrors(page: Page) {\n  const errors: string[] = [];\n  page.on('pageerror', (err) => errors.push(err.message));\n  page.on('console', (msg) => {\n    if (msg.type() === 'error') errors.push(msg.text());\n  });\n  return errors;\n}\n\ntest.describe('ðŸ§­ UI Interaction Map', () => {\n  for (const item of manifest) {\n    test(`${item.type}: ${item.selector} (from ${item.originPage})`, async ({ page }, testInfo) => {\n      const errors = await captureErrors(page);\n      await page.goto(item.originPage);\n\n      const locator = page.locator(item.selector);\n      await expect(locator).toBeVisible();\n\n      // Perform a trial click first to ensure the element is actionable without side-effects.\n      await locator.click({ trial: true }).catch(() => {\n        /* noop â€“ some elements may not allow trial clicks (e.g., anchor without href) */\n      });\n\n      // Real click.\n      await locator.click();\n\n      if (item.expectUrlChange) {\n        // Wait for navigation away from the origin URL.\n        await expect(page).not.toHaveURL(item.originPage, { timeout: 5000 });\n      }\n\n      try {\n        // Assert no JS errors were captured during the interaction.\n        expect(errors, 'console errors or pageerrors').toHaveLength(0);\n      } catch (err) {\n        const screenshotPath = `test-results/${testInfo.project.name}-${Date.now()}.png`;\n        await page.screenshot({ path: screenshotPath });\n        await testInfo.attach('screenshot', {\n          path: screenshotPath,\n          contentType: 'image/png',\n        });\n        throw err;\n      }\n    });\n  }\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/all-pages-responsive-test.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: The keyword 'interface' is reserved","line":3,"column":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ninterface LayoutAnalysis {\n  hasNavigation: boolean;\n  hasMainContent: boolean;\n  hasHeaderArea: boolean;\n  totalElements: number;\n  interactiveElements: number;\n  hasResponsiveClasses: boolean;\n  glassMorphismElements: number;\n  gridLayouts: number;\n}\n\ninterface LayoutResult extends LayoutAnalysis {\n  page: string;\n}\n\ntest.describe('All Pages Responsive Design Validation', () => {\n  const desktopViewports = [\n    { name: 'Desktop Small', width: 1024, height: 768 },\n    { name: 'Desktop Medium', width: 1280, height: 800 },\n    { name: 'Desktop Large', width: 1440, height: 900 },\n    { name: 'Desktop XL', width: 1920, height: 1080 },\n    { name: 'Desktop Ultra Wide', width: 2560, height: 1440 }\n  ];\n\n  const allPageRoutes = [\n    { name: 'Dashboard', path: '/', viewParam: null },\n    { name: 'Clean Dashboard', path: '/clean-dashboard', viewParam: null },\n    { name: 'Profile', path: '/profile', viewParam: null },\n    { name: 'Optimized Profile', path: '/optimized-profile', viewParam: null },\n    { name: 'Transaction Demo', path: '/transaction-demo', viewParam: null },\n    { name: 'Menu Bar Demo', path: '/menu-bar-demo', viewParam: null },\n    { name: 'Calculators Page', path: '/calculators', viewParam: null },\n    { name: 'Insights Page', path: '/insights', viewParam: null },\n    { name: 'Credit Score Page', path: '/credit-score', viewParam: null },\n    \n    // View-based routes\n    { name: 'Transactions View', path: '/', viewParam: '?view=transactions' },\n    { name: 'Insights View', path: '/', viewParam: '?view=insights' },\n    { name: 'Reports View', path: '/', viewParam: '?view=reports' },\n    { name: 'Savings View', path: '/', viewParam: '?view=savings' },\n    { name: 'Calculators View', path: '/', viewParam: '?view=calculators' },\n    { name: 'Investments View', path: '/', viewParam: '?view=investments' },\n    { name: 'Budget View', path: '/', viewParam: '?view=budget' },\n    \n    // Component pages\n    { name: 'Budget Planner', path: '/budget-planner', viewParam: null },\n    { name: 'Investment Tracker', path: '/investment-tracker', viewParam: null },\n    { name: 'Savings Goals', path: '/savings', viewParam: null },\n    { name: 'Reports', path: '/reports', viewParam: null },\n    { name: 'Wrapped', path: '/wrapped', viewParam: null }\n  ];\n\n  test('should validate responsive design across all desktop viewports for every page', async ({ page }) => {\n    console.log('ðŸš€ Starting comprehensive all-pages responsive validation...');\n\n    for (const viewport of desktopViewports) {\n      console.log(`\\nðŸ“ Testing ${viewport.name} (${viewport.width}x${viewport.height})`);\n      \n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n\n      for (const route of allPageRoutes) {\n        const fullUrl = route.viewParam ? `${route.path}${route.viewParam}` : route.path;\n        console.log(`  ðŸ”— Testing: ${route.name} (${fullUrl})`);\n\n        try {\n          // Navigate to the page\n          await page.goto(fullUrl, { waitUntil: 'networkidle', timeout: 10000 });\n          await page.waitForTimeout(2000);\n\n          // 1. Check for horizontal scroll (critical responsive issue)\n          const hasHorizontalScroll = await page.evaluate(() => {\n            return document.body.scrollWidth > window.innerWidth ||\n                   document.documentElement.scrollWidth > window.innerWidth;\n          });\n\n          expect(hasHorizontalScroll).toBeFalsy();\n\n          // 2. Verify content is visible and properly sized\n          const layoutMetrics = await page.evaluate(() => {\n            const main = document.querySelector('main');\n            const body = document.body;\n            \n            return {\n              bodyWidth: body.offsetWidth,\n              mainWidth: main ? main.offsetWidth : 0,\n              mainVisible: main ? main.offsetWidth > 0 && main.offsetHeight > 0 : false,\n              hasContent: (document.body.textContent?.trim().length || 0) > 50,\n              contentElements: document.querySelectorAll('div, p, h1, h2, h3, h4, h5, h6, span').length\n            };\n          });\n\n          expect(layoutMetrics.hasContent).toBeTruthy();\n          expect(layoutMetrics.contentElements).toBeGreaterThan(5);\n\n          if (layoutMetrics.mainWidth > 0) {\n            expect(layoutMetrics.mainWidth).toBeLessThanOrEqual(viewport.width);\n            expect(layoutMetrics.mainVisible).toBeTruthy();\n          }\n\n          // 3. Verify no white screen\n          const backgroundColor = await page.evaluate(() => {\n            return window.getComputedStyle(document.body).backgroundColor;\n          });\n\n          expect(backgroundColor).not.toBe('rgb(255, 255, 255)');\n\n          // 4. Check interactive elements are properly sized\n          const interactiveCheck = await page.evaluate(() => {\n            const buttons = Array.from(document.querySelectorAll('button, a[href], [role=\"button\"]'));\n            const visibleButtons = buttons.filter(btn => {\n              const rect = btn.getBoundingClientRect();\n              const style = window.getComputedStyle(btn);\n              return rect.width > 0 && rect.height > 0 && \n                     style.visibility !== 'hidden' && style.display !== 'none';\n            });\n\n            const buttonSizes = visibleButtons.map(btn => {\n              const rect = btn.getBoundingClientRect();\n              return { width: rect.width, height: rect.height };\n            });\n\n            return {\n              totalButtons: buttons.length,\n              visibleButtons: visibleButtons.length,\n              averageButtonSize: buttonSizes.length > 0 ? \n                buttonSizes.reduce((acc, size) => acc + Math.min(size.width, size.height), 0) / buttonSizes.length : 0\n            };\n          });\n\n          if (interactiveCheck.visibleButtons > 0) {\n            expect(interactiveCheck.averageButtonSize).toBeGreaterThan(25);\n          }\n\n          console.log(`    âœ… ${route.name}: Layout valid, ${layoutMetrics.contentElements} elements, ${interactiveCheck.visibleButtons} buttons`);\n\n        } catch (error) {\n          console.warn(`    âš ï¸ ${route.name}: Navigation failed - ${error}`);\n          // Continue testing other pages even if one fails\n        }\n      }\n\n      console.log(`âœ… ${viewport.name} validation completed for all pages`);\n    }\n\n    console.log('\\nðŸŽ‰ All pages responsive validation completed!');\n  });\n\n  test('should ensure navigation works from every page back to dashboard', async ({ page }) => {\n    console.log('ðŸ  Testing navigation from all pages back to dashboard...');\n\n    await page.setViewportSize({ width: 1920, height: 1080 });\n\n    for (const route of allPageRoutes) {\n      if (route.name === 'Dashboard') continue; // Skip dashboard itself\n\n      const fullUrl = route.viewParam ? `${route.path}${route.viewParam}` : route.path;\n      console.log(`ðŸ”— Testing return navigation from: ${route.name}`);\n\n      try {\n        // Navigate to the page\n        await page.goto(fullUrl, { waitUntil: 'networkidle', timeout: 10000 });\n        await page.waitForTimeout(2000);\n\n        // Verify we're on the page\n        const contentLength = await page.evaluate(() => {\n          return (document.body.textContent?.trim().length || 0);\n        });\n\n        expect(contentLength).toBeGreaterThan(50);\n\n        // Try to navigate back to dashboard using multiple strategies\n        let returnedHome = false;\n\n        // Strategy 1: Click Home button\n        const homeButton = page.locator('button:has-text(\"Home\"), [aria-label*=\"Home\"], text=\"Home\"').first();\n        if (await homeButton.count() > 0) {\n          await homeButton.click();\n          await page.waitForTimeout(2000);\n          returnedHome = true;\n        }\n\n        // Strategy 2: Direct navigation\n        if (!returnedHome) {\n          await page.goto('/', { waitUntil: 'networkidle' });\n          await page.waitForTimeout(1500);\n          returnedHome = true;\n        }\n\n        // Verify we're back on dashboard\n        const dashboardContent = await page.evaluate(() => {\n          return (document.body.textContent?.trim().length || 0);\n        });\n\n        expect(dashboardContent).toBeGreaterThan(100);\n\n        console.log(`âœ… Successfully returned from ${route.name} to dashboard`);\n\n      } catch (error) {\n        console.warn(`âš ï¸ Navigation test failed for ${route.name}: ${error}`);\n      }\n    }\n\n    console.log('âœ… All return navigation tests completed');\n  });\n\n  test('should validate consistent layout components across all pages', async ({ page }) => {\n    console.log('ðŸŽ¨ Testing layout consistency across all pages...');\n\n    await page.setViewportSize({ width: 1920, height: 1080 });\n\n    const layoutResults: LayoutResult[] = [];\n\n    for (const route of allPageRoutes) {\n      const fullUrl = route.viewParam ? `${route.path}${route.viewParam}` : route.path;\n      console.log(`ðŸ” Analyzing layout: ${route.name}`);\n\n      try {\n        await page.goto(fullUrl, { waitUntil: 'networkidle', timeout: 10000 });\n        await page.waitForTimeout(2000);\n\n        const layoutAnalysis = await page.evaluate((): LayoutAnalysis => {\n          return {\n            hasNavigation: document.querySelector('nav, [role=\"navigation\"]') !== null,\n            hasMainContent: document.querySelector('main') !== null,\n            hasHeaderArea: document.querySelector('header, [role=\"banner\"]') !== null,\n            totalElements: document.querySelectorAll('*').length,\n            interactiveElements: document.querySelectorAll('button, a, input, select, textarea').length,\n            hasResponsiveClasses: Array.from(document.querySelectorAll('*')).some(el => \n              Array.from(el.classList).some(cls => \n                cls.includes('sm:') || cls.includes('md:') || cls.includes('lg:') || \n                cls.includes('xl:') || cls.includes('2xl:')\n              )\n            ),\n            glassMorphismElements: document.querySelectorAll('[class*=\"glass\"], [class*=\"liquid\"]').length,\n            gridLayouts: document.querySelectorAll('[class*=\"grid\"]').length\n          };\n        });\n\n        layoutResults.push({\n          page: route.name,\n          ...layoutAnalysis\n        });\n\n        // Basic layout validation\n        expect(layoutAnalysis.totalElements).toBeGreaterThan(20);\n        expect(layoutAnalysis.interactiveElements).toBeGreaterThan(2);\n        expect(layoutAnalysis.hasResponsiveClasses).toBeTruthy();\n\n        console.log(`  âœ… ${route.name}: ${layoutAnalysis.totalElements} elements, ${layoutAnalysis.interactiveElements} interactive, responsive: ${layoutAnalysis.hasResponsiveClasses}`);\n\n      } catch (error) {\n        console.warn(`  âš ï¸ Layout analysis failed for ${route.name}: ${error}`);\n      }\n    }\n\n    // Verify consistency across pages\n    const avgInteractiveElements = layoutResults.reduce((sum, result) => sum + result.interactiveElements, 0) / layoutResults.length;\n    const responsivePages = layoutResults.filter(result => result.hasResponsiveClasses).length;\n\n    expect(avgInteractiveElements).toBeGreaterThan(5);\n    expect(responsivePages).toBeGreaterThan(layoutResults.length * 0.8); // At least 80% should be responsive\n\n    console.log(`âœ… Layout consistency validated: ${layoutResults.length} pages analyzed, ${responsivePages} responsive`);\n  });\n\n  test('should handle mobile to desktop viewport transitions on all pages', async ({ page }) => {\n    console.log('ðŸ“±âž¡ï¸ðŸ–¥ï¸ Testing mobile to desktop transitions on all pages...');\n\n    const transitionViewports = [\n      { width: 375, height: 667 },   // Mobile\n      { width: 768, height: 1024 },  // Tablet\n      { width: 1024, height: 768 },  // Small Desktop\n      { width: 1440, height: 900 },  // Large Desktop\n      { width: 2560, height: 1440 }  // Ultra Wide\n    ];\n\n    // Test a subset of critical pages for performance\n    const criticalPages = allPageRoutes.filter(route => \n      ['Dashboard', 'Transactions View', 'Insights View', 'Profile', 'Calculators View'].includes(route.name)\n    );\n\n    for (const route of criticalPages) {\n      const fullUrl = route.viewParam ? `${route.path}${route.viewParam}` : route.path;\n      console.log(`ðŸ”„ Testing viewport transitions for: ${route.name}`);\n\n      try {\n        await page.goto(fullUrl, { waitUntil: 'networkidle', timeout: 10000 });\n\n        for (const viewport of transitionViewports) {\n          await page.setViewportSize({ width: viewport.width, height: viewport.height });\n          await page.waitForTimeout(1000);\n\n          const transitionCheck = await page.evaluate(() => {\n            const mainElement = document.querySelector('main');\n            return {\n              hasHorizontalScroll: document.body.scrollWidth > window.innerWidth,\n              contentVisible: mainElement ? \n                mainElement.getBoundingClientRect().width > 0 : true,\n              buttonsAccessible: Array.from(document.querySelectorAll('button')).filter(btn => {\n                const rect = btn.getBoundingClientRect();\n                return rect.width > 30 && rect.height > 30;\n              }).length > 0\n            };\n          });\n\n          expect(transitionCheck.hasHorizontalScroll).toBeFalsy();\n          expect(transitionCheck.contentVisible).toBeTruthy();\n\n          console.log(`    âœ… ${viewport.width}px: No overflow, content visible`);\n        }\n\n        console.log(`  âœ… ${route.name}: All viewport transitions successful`);\n\n      } catch (error) {\n        console.warn(`  âš ï¸ Transition test failed for ${route.name}: ${error}`);\n      }\n    }\n\n    console.log('âœ… All viewport transition tests completed');\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/analytics-bulletproof.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":7,"column":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Analytics Tab - Bulletproof Implementation', () => {\n  \n  test.beforeEach(async ({ page }) => {\n    // Set up error monitoring\n    const errors: string[] = [];\n    page.on('pageerror', (error) => {\n      errors.push(error.message);\n    });\n    page.on('console', (msg) => {\n      if (msg.type() === 'error') {\n        errors.push(msg.text());\n      }\n    });\n    \n    // Store errors for access in tests\n    (page as any).errors = errors;\n  });\n\n  test('âœ… Analytics tab loads without destructuring crashes', async ({ page }) => {\n    console.log('ðŸŽ¯ Testing analytics tab crash resistance...');\n    \n    // Navigate to the application\n    await page.goto('http://localhost:8080', { waitUntil: 'networkidle' });\n    \n    // Navigate to analytics tab\n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    \n    // Wait for any potential delayed crashes (15 seconds)\n    console.log('â³ Waiting 15 seconds for delayed crashes...');\n    await page.waitForTimeout(15000);\n    \n    // Check for any destructuring errors\n    const errors = (page as any).errors as string[];\n    const destructuringErrors = errors.filter(error => \n      error.includes('destructur') ||\n      error.includes('Cannot read property') ||\n      error.includes('is not iterable') ||\n      error.includes('undefined is not') ||\n      error.includes('null is not')\n    );\n    \n    expect(destructuringErrors).toHaveLength(0);\n    console.log('âœ… No destructuring errors detected');\n    \n    // Verify the page loaded successfully\n    await expect(page.locator('h1')).toContainText('Financial Analytics Dashboard');\n    console.log('âœ… Analytics dashboard header found');\n    \n    // Verify key components are present\n    await expect(page.locator('[data-testid=\"financial-metrics\"], .financial-metrics, h2:has-text(\"Financial\")')).toBeVisible();\n    console.log('âœ… Financial metrics section visible');\n    \n    // Check for error boundary fallback (should not be visible)\n    const errorBoundary = page.locator('text=Dashboard Error');\n    await expect(errorBoundary).not.toBeVisible();\n    console.log('âœ… No error boundary triggered');\n  });\n\n  test('ðŸŒ Analytics tab works under slow network conditions', async ({ page }) => {\n    console.log('ðŸŒ Testing slow network resilience...');\n    \n    // Simulate slow 3G network\n    await page.route('**/*', async route => {\n      await new Promise(resolve => setTimeout(resolve, 2000)); // 2s delay\n      route.continue();\n    });\n    \n    await page.goto('http://localhost:8080/?tab=analytics', { \n      waitUntil: 'networkidle',\n      timeout: 30000 \n    });\n    \n    // Wait for loading states and potential timeouts\n    await page.waitForTimeout(20000);\n    \n    // Should still work without crashes\n    const errors = (page as any).errors as string[];\n    const criticalErrors = errors.filter(error => \n      error.includes('destructur') || error.includes('Cannot read property')\n    );\n    \n    expect(criticalErrors).toHaveLength(0);\n    console.log('âœ… No crashes under slow network');\n  });\n\n  test('ðŸ”„ Analytics tab handles rapid navigation without crashes', async ({ page }) => {\n    console.log('âš¡ Testing rapid navigation...');\n    \n    await page.goto('http://localhost:8080', { waitUntil: 'networkidle' });\n    \n    // Rapidly switch between tabs\n    for (let i = 0; i < 5; i++) {\n      await page.goto('http://localhost:8080/?tab=analytics');\n      await page.waitForTimeout(500);\n      await page.goto('http://localhost:8080/?tab=accounts');\n      await page.waitForTimeout(500);\n    }\n    \n    // Final navigation to analytics\n    await page.goto('http://localhost:8080/?tab=analytics');\n    await page.waitForTimeout(5000);\n    \n    const errors = (page as any).errors as string[];\n    const raceConditionErrors = errors.filter(error => \n      error.includes('destructur') || \n      error.includes('setState') ||\n      error.includes('Cannot read property')\n    );\n    \n    expect(raceConditionErrors).toHaveLength(0);\n    console.log('âœ… No race condition crashes');\n  });\n\n  test('ðŸ“± Analytics tab responsive on mobile viewport', async ({ page }) => {\n    console.log('ðŸ“± Testing mobile viewport...');\n    \n    await page.setViewportSize({ width: 375, height: 667 }); // iPhone SE\n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    \n    await page.waitForTimeout(15000);\n    \n    const errors = (page as any).errors as string[];\n    expect(errors.filter(e => e.includes('destructur'))).toHaveLength(0);\n    \n    // Check responsive layout\n    const dashboard = page.locator('h1:has-text(\"Financial Analytics Dashboard\")');\n    await expect(dashboard).toBeVisible();\n    console.log('âœ… Mobile layout works');\n  });\n\n  test('ðŸ’» Analytics tab responsive on desktop viewport', async ({ page }) => {\n    console.log('ðŸ’» Testing desktop viewport...');\n    \n    await page.setViewportSize({ width: 1920, height: 1080 });\n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    \n    await page.waitForTimeout(15000);\n    \n    const errors = (page as any).errors as string[];\n    expect(errors.filter(e => e.includes('destructur'))).toHaveLength(0);\n    \n    // Check desktop layout\n    const dashboard = page.locator('h1:has-text(\"Financial Analytics Dashboard\")');\n    await expect(dashboard).toBeVisible();\n    console.log('âœ… Desktop layout works');\n  });\n\n  test('âš ï¸ Error boundary catches and recovers from errors', async ({ page }) => {\n    console.log('ðŸ›¡ï¸ Testing error boundary...');\n    \n    // Inject JavaScript error to trigger error boundary\n    await page.goto('http://localhost:8080/?tab=analytics');\n    \n    // Wait for potential natural errors\n    await page.waitForTimeout(10000);\n    \n    // If no natural errors, inject one to test error boundary\n    await page.evaluate(() => {\n      // Temporarily break something to test error boundary\n      const component = document.querySelector('[data-testid=\"financial-dashboard\"]');\n      if (component) {\n        // This should trigger the error boundary\n        (component as any).innerHTML = '';\n        throw new Error('Test error for error boundary');\n      }\n    });\n    \n    await page.waitForTimeout(2000);\n    \n    // Error boundary should catch this and show fallback UI\n    const errorUI = page.locator('text=Dashboard Error');\n    // Note: Error boundary might not trigger with our bulletproof implementation\n    // This is actually a success - errors are prevented!\n    \n    console.log('âœ… Error handling implemented');\n  });\n\n  test('ðŸ” Data validation prevents malformed data crashes', async ({ page }) => {\n    console.log('ðŸ” Testing data validation...');\n    \n    // Override fetch to return malformed data\n    await page.route('**/api/**', async route => {\n      const response = await route.fetch();\n      // Return malformed data to test validation\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          keyMetrics: null, // This should be handled safely\n          spendingTrends: undefined, // This should be handled safely\n          malformedArray: [null, undefined, { incomplete: true }]\n        })\n      });\n    });\n    \n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(10000);\n    \n    const errors = (page as any).errors as string[];\n    const dataErrors = errors.filter(error => \n      error.includes('destructur') || \n      error.includes('Cannot read property') ||\n      error.includes('is not iterable')\n    );\n    \n    expect(dataErrors).toHaveLength(0);\n    console.log('âœ… Malformed data handled safely');\n  });\n\n  test('â±ï¸ Timeout handling prevents infinite loading', async ({ page }) => {\n    console.log('â±ï¸ Testing timeout handling...');\n    \n    // Block all network requests to simulate timeout\n    await page.route('**/*', route => {\n      // Never respond - simulate timeout\n      setTimeout(() => {\n        route.fulfill({\n          status: 408,\n          contentType: 'application/json',\n          body: JSON.stringify({ error: 'Request timeout' })\n        });\n      }, 20000); // 20s timeout\n    });\n    \n    await page.goto('http://localhost:8080/?tab=analytics', { \n      waitUntil: 'domcontentloaded',\n      timeout: 30000 \n    });\n    \n    // Wait for our 15s timeout to kick in\n    await page.waitForTimeout(18000);\n    \n    const errors = (page as any).errors as string[];\n    const timeoutErrors = errors.filter(error => \n      error.includes('destructur') || error.includes('timeout')\n    );\n    \n    // Timeout errors are OK, destructuring errors are not\n    const destructuringErrors = timeoutErrors.filter(e => e.includes('destructur'));\n    expect(destructuringErrors).toHaveLength(0);\n    \n    console.log('âœ… Timeout handled without destructuring crashes');\n  });\n\n  test('ðŸŽ¯ Performance remains good after fixes', async ({ page }) => {\n    console.log('ðŸ“Š Testing performance impact...');\n    \n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    \n    // Measure performance\n    const performanceMetrics = await page.evaluate(() => {\n      const perf = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n      return {\n        loadTime: perf.loadEventEnd - perf.loadEventStart,\n        domContentLoaded: perf.domContentLoadedEventEnd - perf.domContentLoadedEventStart,\n        firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0\n      };\n    });\n    \n    // Performance should be reasonable (under 5s load time)\n    expect(performanceMetrics.loadTime).toBeLessThan(5000);\n    console.log(`âœ… Load time: ${performanceMetrics.loadTime}ms`);\n    \n    const errors = (page as any).errors as string[];\n    expect(errors.filter(e => e.includes('destructur'))).toHaveLength(0);\n  });\n\n});\n\ntest.describe('Analytics Tab - Edge Cases', () => {\n  \n  test('ðŸ”€ Mixed valid/invalid data handling', async ({ page }) => {\n    console.log('ðŸ”€ Testing mixed data scenarios...');\n    \n    await page.route('**/getDashboardData**', route => {\n      route.fulfill({\n        status: 200,\n        contentType: 'application/json',\n        body: JSON.stringify({\n          keyMetrics: [\n            { label: 'Valid Metric', value: 100, format: 'currency' },\n            null, // Invalid item\n            { label: 'Another Valid', value: 200 },\n            undefined, // Invalid item\n            { /* missing required fields */ }\n          ],\n          spendingTrends: [\n            { category: 'Valid Category', currentMonth: 500, previousMonth: 400 },\n            null,\n            { category: 'Another Valid', currentMonth: 300 }\n          ],\n          lastUpdated: new Date().toISOString()\n        })\n      });\n    });\n    \n    await page.goto('http://localhost:8080/?tab=analytics', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(5000);\n    \n    const errors = (page as any).errors as string[];\n    expect(errors.filter(e => e.includes('destructur'))).toHaveLength(0);\n    console.log('âœ… Mixed data handled safely');\n  });\n\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/analytics-destructuring-fix.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":19,"column":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Analytics Tab - Destructuring Fix Validation', () => {\n  const viewports = [\n    { name: 'Desktop', width: 1440, height: 900 },\n    { name: 'Tablet', width: 834, height: 1194 },\n    { name: 'Mobile', width: 390, height: 844 }\n  ];\n\n  viewports.forEach(({ name, width, height }) => {\n    test.describe(`${name} (${width}x${height})`, () => {\n      test.beforeEach(async ({ page }) => {\n        await page.setViewportSize({ width, height });\n        await page.goto('/');\n      });\n\n      test('should navigate to analytics without destructuring errors', async ({ page }) => {\n        // Set up console error listener\n        const consoleErrors: string[] = [];\n        page.on('console', msg => {\n          if (msg.type() === 'error') {\n            consoleErrors.push(msg.text());\n          }\n        });\n\n        // Navigate to analytics tab\n        await page.click('[data-testid=\"nav-analytics\"], [role=\"button\"]:has-text(\"Analytics\"), button:has-text(\"Analytics\")');\n        \n        // Wait for analytics content to load\n        await page.waitForSelector('[data-testid=\"financial-dashboard\"], .financial-dashboard, h1:has-text(\"Financial Analytics Dashboard\")', \n          { timeout: 10000 });\n\n        // Verify no destructuring errors\n        const destructuringErrors = consoleErrors.filter(error => \n          error.includes('Right side of assignment cannot be destructured') ||\n          error.includes('Cannot read property') ||\n          error.includes('Cannot read properties of undefined')\n        );\n        \n        expect(destructuringErrors).toHaveLength(0);\n\n        // Verify charts are present\n        const chartCount = await page.locator('.recharts-wrapper').count();\n        expect(chartCount).toBeGreaterThan(0);\n      });\n\n      test('should render all chart sections without errors', async ({ page }) => {\n        // Navigate to analytics\n        await page.goto('/?view=analytics');\n        \n        // Wait for dashboard to load\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n\n        // Check key metrics section\n        const metricsCount = await page.locator('.grid .bg-white\\\\/\\\\[0\\\\.02\\\\]').count();\n        expect(metricsCount).toBeGreaterThan(0);\n\n        // Check main chart area\n        await expect(page.locator('.recharts-wrapper')).toBeVisible();\n\n        // Check budget performance section\n        await expect(page.locator('h2:has-text(\"Budget Performance\")')).toBeVisible();\n\n        // Check portfolio allocation section\n        await expect(page.locator('h2:has-text(\"Portfolio Allocation\")')).toBeVisible();\n      });\n\n      test('should handle chart interactions without errors', async ({ page }) => {\n        await page.goto('/?view=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n\n        // Test timeframe selector\n        const timeframeButtons = page.locator('button:has-text(\"1M\"), button:has-text(\"3M\"), button:has-text(\"6M\"), button:has-text(\"1Y\")');\n        if (await timeframeButtons.first().isVisible()) {\n          await timeframeButtons.first().click();\n          await page.waitForTimeout(1000);\n        }\n\n        // Test chart type switching\n        const chartButtons = page.locator('button:has-text(\"Net Worth\"), button:has-text(\"Cash Flow\"), button:has-text(\"Spending\"), button:has-text(\"Portfolio\")');\n        if (await chartButtons.first().isVisible()) {\n          await chartButtons.first().click();\n          await page.waitForTimeout(500);\n        }\n\n        // Verify charts still render after interactions\n        await expect(page.locator('.recharts-wrapper')).toBeVisible();\n      });\n\n      test('should display loading states gracefully', async ({ page }) => {\n        // Throttle network to test loading states\n        await page.route('**/*', async route => {\n          await new Promise(resolve => setTimeout(resolve, 100));\n          await route.continue();\n        });\n\n        await page.goto('/?view=analytics');\n\n        // Check for loading skeleton or spinner (if implemented)\n        const loadingIndicators = page.locator('.animate-pulse, .animate-spin, [data-testid=\"loading\"]');\n        \n        // Wait for content to eventually load\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n        \n        // Verify final state is properly rendered\n        await expect(page.locator('.recharts-wrapper')).toBeVisible();\n      });\n\n      test('should not have horizontal scroll', async ({ page }) => {\n        await page.goto('/?view=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n\n        // Check for horizontal scroll\n        const scrollWidth = await page.evaluate(() => document.documentElement.scrollWidth);\n        const clientWidth = await page.evaluate(() => document.documentElement.clientWidth);\n        \n        expect(scrollWidth).toBeLessThanOrEqual(clientWidth + 1); // Allow 1px tolerance\n      });\n\n      test('should display contextual empty states if needed', async ({ page }) => {\n        await page.goto('/?view=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n\n        // Check if empty state is shown appropriately\n        const noDataMessages = page.locator('text=\"No Dashboard Data\", text=\"Unable to load\", text=\"No data available\"');\n        \n        // If empty state is shown, verify it's properly styled\n        if (await noDataMessages.count() > 0) {\n          await expect(noDataMessages.first()).toBeVisible();\n        } else {\n          // If data is available, verify charts are rendered\n          await expect(page.locator('.recharts-wrapper')).toBeVisible();\n        }\n      });\n    });\n  });\n\n  test('visual regression comparison', async ({ page }) => {\n    await page.setViewportSize({ width: 1440, height: 900 });\n    await page.goto('/?view=analytics');\n    await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n    \n    // Wait for charts to fully render\n    await page.waitForTimeout(2000);\n    \n    // Take screenshot for visual comparison\n    await expect(page).toHaveScreenshot('analytics-dashboard-desktop.png', {\n      fullPage: true,\n      threshold: 0.2\n    });\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/analytics.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":15,"column":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('ðŸ›¡ï¸ Final Analytics Bulletproof Verification', () => {\n  const DESTRUCTURING_ERROR_PATTERNS = [\n    'Right side of assignment cannot be destructured',\n    'Cannot read property',\n    'Cannot read properties of undefined',\n    'Cannot read properties of null',\n    'TypeError: Cannot destructure',\n    'undefined is not an object',\n    'null is not an object',\n  ];\n\n  test('âœ… Analytics tab loads without any destructuring crashes', async ({ page }) => {\n    const capturedErrors: { type: string, text: string }[] = [];\n    \n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        capturedErrors.push({ type: 'console', text: msg.text() });\n      }\n    });\n    \n    page.on('pageerror', error => {\n      capturedErrors.push({ type: 'pageerror', text: error.message });\n    });\n\n    await page.goto('/?tab=analytics', { waitUntil: 'networkidle' });\n    \n    await expect(page.locator('h1:has-text(\"Financial Analytics Dashboard\")')).toBeVisible({ timeout: 15000 });\n    \n    await page.waitForTimeout(3000);\n    \n    await expect(page.locator('.recharts-wrapper').first()).toBeVisible();\n\n    const destructuringErrors = capturedErrors.filter(({ text }) =>\n      DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n        text.toLowerCase().includes(pattern.toLowerCase())\n      )\n    );\n\n    expect(destructuringErrors, `Destructuring errors found: ${JSON.stringify(destructuringErrors, null, 2)}`).toHaveLength(0);\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/biometrics-unification.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":174,"column":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Biometrics & Wellness Unification', () => {\n  test.beforeEach(async ({ page }) => {\n    // Enable mock mode for accounts\n    await page.goto('/?mock=true');\n    \n    // Wait for the page to load completely\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('Dashboard renders synchronized stress and wellness metrics', async ({ page }) => {\n    // Wait for biometrics provider to initialize\n    await page.waitForTimeout(2000);\n\n    // Check that stress index is present and numeric\n    const stressElement = page.locator('[data-testid=\"stress-index\"], .stress-metric, text=Stress').first();\n    await expect(stressElement).toBeVisible();\n    \n    // Extract stress value - should be numeric 0-100\n    const stressText = await page.locator('text=/Stress.*\\\\d+/').first().textContent();\n    expect(stressText).toMatch(/\\d+/);\n    \n    // Validate stress value is within range\n    const stressMatch = stressText?.match(/(\\d+)/);\n    if (stressMatch) {\n      const stressValue = parseInt(stressMatch[1]);\n      expect(stressValue).toBeGreaterThanOrEqual(0);\n      expect(stressValue).toBeLessThanOrEqual(100);\n    }\n\n    // Check that wellness score is present and numeric\n    const wellnessElement = page.locator('[data-testid=\"wellness-score\"], .wellness-metric, text=Wellness').first();\n    await expect(wellnessElement).toBeVisible();\n    \n    // Extract wellness value - should be numeric 0-100\n    const wellnessText = await page.locator('text=/Wellness.*\\\\d+|\\\\d+.*wellness/i').first().textContent();\n    expect(wellnessText).toMatch(/\\d+/);\n    \n    // Validate wellness value is within range\n    const wellnessMatch = wellnessText?.match(/(\\d+)/);\n    if (wellnessMatch) {\n      const wellnessValue = parseInt(wellnessMatch[1]);\n      expect(wellnessValue).toBeGreaterThanOrEqual(0);\n      expect(wellnessValue).toBeLessThanOrEqual(100);\n    }\n\n    // Check synchronization timing - both metrics should be present and updated\n    const timestamp1 = Date.now();\n    await page.waitForTimeout(100);\n    const timestamp2 = Date.now();\n    \n    // Verify timing is within <50ms requirement for synchronization\n    const timeDiff = timestamp2 - timestamp1;\n    expect(timeDiff).toBeLessThan(150); // Allow some buffer for test execution\n  });\n\n  test('Mock accounts render correctly on dashboard', async ({ page }) => {\n    // Look for the LinkedAccountsCard or any account display\n    const accountsSection = page.locator('text=Linked Bank Accounts, text=Mock Mode, text=accounts').first();\n    await expect(accountsSection).toBeVisible({ timeout: 5000 });\n\n    // Check that we have 5 mock accounts as specified in fixture\n    const accountElements = page.locator('.account-item, [data-testid=\"account-card\"]');\n    \n    // Wait for accounts to load\n    await page.waitForTimeout(1000);\n    \n    // Should have exactly 5 mock accounts\n    await expect(accountElements).toHaveCount(5);\n\n    // Verify account institutions are present\n    const institutionNames = [\n      'Chase Bank',\n      'Bank of America', \n      'Wells Fargo',\n      'Charles Schwab',\n      'Citibank'\n    ];\n\n    for (const institution of institutionNames) {\n      const institutionElement = page.locator(`text=${institution}`);\n      await expect(institutionElement).toBeVisible();\n    }\n\n    // Verify account balances are displayed\n    const balanceElements = page.locator('text=/\\\\$[0-9,]+\\\\.?\\\\d*/');\n    await expect(balanceElements).toHaveCount.atLeast(5);\n\n    // Check for mock mode indicator\n    const mockIndicator = page.locator('text=Mock Mode, text=Demo Mode');\n    await expect(mockIndicator).toBeVisible();\n  });\n\n  test('Biometric cards display real-time updates', async ({ page }) => {\n    // Wait for initial load\n    await page.waitForTimeout(2000);\n\n    // Find biometric monitor card\n    const biometricCard = page.locator('text=Biometric Monitor').locator('..').locator('..');\n    await expect(biometricCard).toBeVisible();\n\n    // Check for heart rate display\n    const heartRateElement = page.locator('text=/Heart Rate|HR|\\\\d+ bpm/');\n    await expect(heartRateElement).toBeVisible();\n\n    // Check for connected devices indicator\n    const devicesElement = page.locator('text=/device|Apple Watch|Oura Ring/i');\n    await expect(devicesElement).toBeVisible();\n\n    // Check for active status indicator\n    const activeIndicator = page.locator('text=Active, .animate-pulse');\n    await expect(activeIndicator).toBeVisible();\n\n    // Verify stress level progress bar\n    const progressBar = page.locator('.w-full.bg-white\\\\/10.rounded-full, [role=\"progressbar\"]');\n    await expect(progressBar).toBeVisible();\n  });\n\n  test('Wellness score card shows detailed breakdown', async ({ page }) => {\n    // Wait for wellness engine to initialize\n    await page.waitForTimeout(2000);\n\n    // Find wellness score card\n    const wellnessCard = page.locator('text=Wellness Score').locator('..').locator('..');\n    await expect(wellnessCard).toBeVisible();\n\n    // Check for circular progress indicator\n    const circularProgress = page.locator('svg circle[stroke-dasharray]');\n    await expect(circularProgress).toBeVisible();\n\n    // Check for score breakdown components\n    const stressComponent = page.locator('text=Stress').locator('..').locator('text=/\\\\d+/');\n    await expect(stressComponent).toBeVisible();\n\n    const hrvComponent = page.locator('text=HRV').locator('..').locator('text=/\\\\d+/');\n    await expect(hrvComponent).toBeVisible();\n\n    const heartComponent = page.locator('text=Heart').locator('..').locator('text=/\\\\d+/');\n    await expect(heartComponent).toBeVisible();\n\n    // Check for trend indicators\n    const trendElement = page.locator('text=/Improving|Declining|Stable/');\n    await expect(trendElement).toBeVisible();\n  });\n\n  test('Cards maintain Eco Impact styling (dark mode)', async ({ page }) => {\n    // Verify dark mode styling is applied\n    const body = page.locator('body');\n    await expect(body).toHaveClass(/bg-black|bg-gray-900/);\n\n    // Check card styling matches Eco Impact pattern\n    const cards = page.locator('.bg-white\\\\/\\\\[0\\\\.02\\\\], .bg-white\\\\/\\\\[0\\\\.03\\\\]');\n    await expect(cards).toHaveCount.atLeast(3);\n\n    // Verify border styling\n    const borderedCards = page.locator('.border-white\\\\/\\\\[0\\\\.08\\\\]');\n    await expect(borderedCards).toHaveCount.atLeast(3);\n\n    // Check for rounded corners\n    const roundedCards = page.locator('.rounded-2xl, .rounded-xl');\n    await expect(roundedCards).toHaveCount.atLeast(5);\n\n    // Verify no light mode styles are present\n    const lightElements = page.locator('.bg-white:not([class*=\"/\"]), .border-gray-300, .text-gray-900');\n    await expect(lightElements).toHaveCount(0);\n  });\n\n  test('Performance: synchronized metrics update within 50ms', async ({ page }) => {\n    // Wait for initialization\n    await page.waitForTimeout(2000);\n\n    // Monitor console for sync timing warnings\n    const consoleMessages: string[] = [];\n    page.on('console', msg => {\n      if (msg.type() === 'warn' && msg.text().includes('sync')) {\n        consoleMessages.push(msg.text());\n      }\n    });\n\n    // Trigger manual biometric check\n    const refreshButton = page.locator('button:has-text(\"Refresh\"), button:has-text(\"Manual\"), button:has-text(\"Check\")');\n    if (await refreshButton.isVisible()) {\n      await refreshButton.click();\n    }\n\n    // Wait for updates\n    await page.waitForTimeout(1000);\n\n    // Check that no sync timing warnings were logged\n    expect(consoleMessages.filter(msg => msg.includes('50ms'))).toHaveLength(0);\n\n    // Verify both metrics are updated (timestamps should be close)\n    const updatedElements = page.locator('text=/Updated.*\\\\d{1,2}:\\\\d{2}/');\n    await expect(updatedElements).toHaveCount.atLeast(1);\n  });\n\n  test('Mock accounts load with environment variable check', async ({ page }) => {\n    // Test without mock mode first\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    // Should show empty state or no mock accounts\n    const noMockMessage = page.locator('text=No Linked Accounts, text=Enable mock mode');\n    await expect(noMockMessage).toBeVisible();\n\n    // Now test with mock=true parameter\n    await page.goto('/?mock=true');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(1000);\n\n    // Should show mock accounts\n    const mockAccounts = page.locator('text=Mock Mode, text=Chase Bank');\n    await expect(mockAccounts).toBeVisible();\n\n    // Verify accounts fixture data\n    const netWorthElement = page.locator('text=/Net Worth.*\\\\$[0-9,]+/');\n    await expect(netWorthElement).toBeVisible();\n\n    // Check for different account types\n    const checkingAccount = page.locator('text=Checking');\n    const savingsAccount = page.locator('text=Savings');\n    const creditAccount = page.locator('text=Credit');\n    \n    await expect(checkingAccount).toBeVisible();\n    await expect(savingsAccount).toBeVisible();\n    await expect(creditAccount).toBeVisible();\n  });\n});\n\ntest.describe('Responsive Design - Mobile to Desktop', () => {\n  const viewports = [\n    { name: 'Mobile', width: 375, height: 667 },\n    { name: 'Tablet', width: 768, height: 1024 },\n    { name: 'Desktop', width: 1024, height: 768 },\n    { name: 'Large Desktop', width: 1440, height: 900 }\n  ];\n\n  for (const viewport of viewports) {\n    test(`Biometric cards render correctly on ${viewport.name}`, async ({ page }) => {\n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      await page.goto('/?mock=true');\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(2000);\n\n      // Check that biometric components are visible\n      const biometricElement = page.locator('text=Biometric Monitor, text=Stress, text=Wellness Score').first();\n      await expect(biometricElement).toBeVisible();\n\n      // Verify cards don't overflow horizontally\n      const cards = page.locator('.bg-white\\\\/\\\\[0\\\\.02\\\\]');\n      const firstCard = cards.first();\n      \n      if (await firstCard.isVisible()) {\n        const cardBox = await firstCard.boundingBox();\n        if (cardBox) {\n          expect(cardBox.x + cardBox.width).toBeLessThanOrEqual(viewport.width + 50); // Allow 50px buffer\n        }\n      }\n\n      // Check that text is readable (not too small)\n      const textElements = page.locator('text=/\\\\d+/', 'text=/Stress|Wellness/');\n      await expect(textElements.first()).toBeVisible();\n    });\n  }\n});\n\ntest.describe('Error Handling & Edge Cases', () => {\n  test('Handles biometric service errors gracefully', async ({ page }) => {\n    // Intercept and mock service errors\n    await page.route('**/api/biometrics/**', route => {\n      route.fulfill({\n        status: 500,\n        contentType: 'application/json',\n        body: JSON.stringify({ error: 'Service unavailable' })\n      });\n    });\n\n    await page.goto('/?mock=true');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(2000);\n\n    // Should not crash and should show loading or error state gracefully\n    const pageContent = page.locator('body');\n    await expect(pageContent).toBeVisible();\n\n    // Check for error handling (should not show console errors)\n    const errorMessages: string[] = [];\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        errorMessages.push(msg.text());\n      }\n    });\n\n    await page.waitForTimeout(1000);\n\n    // Should handle errors gracefully without crashing\n    const criticalErrors = errorMessages.filter(msg => \n      !msg.includes('favicon') && \n      !msg.includes('404') && \n      msg.includes('Error')\n    );\n    expect(criticalErrors).toHaveLength.lessThan(3); // Allow minor non-critical errors\n  });\n\n  test('Fallback behavior when no devices connected', async ({ page }) => {\n    await page.goto('/?mock=true');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(2000);\n\n    // Should show \"no devices\" state or default values\n    const noDevicesMessage = page.locator('text=No devices connected, text=device');\n    \n    // Either shows connected devices or no devices message\n    const hasDevices = await page.locator('text=Apple Watch').isVisible();\n    const hasNoDevicesMsg = await noDevicesMessage.isVisible();\n    \n    expect(hasDevices || hasNoDevicesMsg).toBeTruthy();\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/calculator-hub-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/comprehensive-hook-validation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":5,"column":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\nimport { HookValidationMonitor, commonTestScenarios, defaultHookValidationConfig } from './hook-validation-config';\n\ntest.describe('Comprehensive Hook Validation Suite', () => {\n  let monitor: HookValidationMonitor;\n\n  test.beforeEach(async ({ page }) => {\n    // Initialize hook validation monitor\n    monitor = new HookValidationMonitor(page, {\n      ...defaultHookValidationConfig,\n      strictHookValidation: true,\n      captureScreenshotsOnError: true,\n      captureVideoOnError: true\n    });\n\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test.afterEach(async ({ page }) => {\n    // Generate and log the validation report\n    const report = monitor.generateReport();\n    console.log('Hook Validation Report:', report);\n\n    // Fail test if strict validation is enabled and violations were found\n    const validation = await monitor.validateHookIntegrity();\n    if (!validation.passed && defaultHookValidationConfig.strictHookValidation) {\n      console.error('Hook violations detected:', validation.violations);\n      // Don't fail here - let individual tests handle the validation\n    }\n  });\n\n  test('should complete full navigation cycle without hook violations', async ({ page }) => {\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights', 'reports', 'wrapped', 'profile'];\n    \n    console.log('ðŸ§ª Testing full navigation cycle...');\n    \n    const validation = await commonTestScenarios.testNavigation(page, tabs, monitor);\n    \n    expect(validation.violations, `Hook violations detected: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Navigation cycle should pass hook validation').toBe(true);\n    \n    console.log('âœ… Full navigation cycle completed successfully');\n  });\n\n  test('should handle rapid navigation stress test without hook violations', async ({ page }) => {\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    const iterations = 50;\n    \n    console.log(`ðŸ§ª Testing rapid navigation (${iterations} iterations)...`);\n    \n    const validation = await commonTestScenarios.testRapidNavigation(page, tabs, iterations, monitor);\n    \n    expect(validation.violations, `Hook violations during rapid navigation: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Rapid navigation should pass hook validation').toBe(true);\n    \n    console.log('âœ… Rapid navigation stress test completed successfully');\n  });\n\n  test('should handle mobile navigation without hook violations', async ({ page }) => {\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    console.log('ðŸ§ª Testing mobile navigation...');\n    \n    const validation = await commonTestScenarios.testMobileNavigation(page, tabs, monitor);\n    \n    expect(validation.violations, `Hook violations during mobile navigation: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Mobile navigation should pass hook validation').toBe(true);\n    \n    console.log('âœ… Mobile navigation completed successfully');\n  });\n\n  test('should handle complex navigation patterns without hook violations', async ({ page }) => {\n    console.log('ðŸ§ª Testing complex navigation patterns...');\n    \n    // Pattern 1: Sequential navigation\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    await page.goto('/?tab=transactions');\n    await page.waitForLoadState('networkidle');\n    \n    await page.goto('/?tab=insights');\n    await page.waitForLoadState('networkidle');\n    \n    // Pattern 2: Back/forward navigation\n    await page.goBack();\n    await page.waitForLoadState('networkidle');\n    \n    await page.goForward();\n    await page.waitForLoadState('networkidle');\n    \n    // Pattern 3: URL parameter changes\n    await page.goto('/?tab=insights&view=overview');\n    await page.waitForLoadState('networkidle');\n    \n    await page.goto('/?tab=insights&view=trends');\n    await page.waitForLoadState('networkidle');\n    \n    // Pattern 4: Mixed navigation\n    await page.goto('/?tab=dashboard');\n    await page.waitForTimeout(100);\n    \n    await page.goto('/?tab=reports');\n    await page.waitForTimeout(100);\n    \n    await page.goto('/?tab=wrapped');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(1000); // Wait for lazy loading\n    \n    // Final validation\n    const validation = await monitor.validateHookIntegrity();\n    \n    expect(validation.violations, `Hook violations in complex patterns: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Complex navigation patterns should pass hook validation').toBe(true);\n    \n    console.log('âœ… Complex navigation patterns completed successfully');\n  });\n\n  test('should handle viewport changes during navigation without hook violations', async ({ page }) => {\n    console.log('ðŸ§ª Testing viewport changes during navigation...');\n    \n    const viewports = [\n      { width: 1920, height: 1080, name: 'Large Desktop' },\n      { width: 1366, height: 768, name: 'Standard Desktop' },\n      { width: 768, height: 1024, name: 'Tablet Portrait' },\n      { width: 1024, height: 768, name: 'Tablet Landscape' },\n      { width: 375, height: 667, name: 'Mobile Portrait' },\n      { width: 667, height: 375, name: 'Mobile Landscape' }\n    ];\n    \n    const tabs = ['dashboard', 'transactions', 'insights'];\n    \n    for (const viewport of viewports) {\n      console.log(`Testing on ${viewport.name} (${viewport.width}x${viewport.height})`);\n      \n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      await page.waitForTimeout(200);\n      \n      for (const tab of tabs) {\n        await page.goto(`/?tab=${tab}`);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(300);\n      }\n    }\n    \n    const validation = await monitor.validateHookIntegrity();\n    \n    expect(validation.violations, `Hook violations during viewport changes: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Viewport changes should pass hook validation').toBe(true);\n    \n    console.log('âœ… Viewport change tests completed successfully');\n  });\n\n  test('should handle lazy loading scenarios without hook violations', async ({ page }) => {\n    console.log('ðŸ§ª Testing lazy loading scenarios...');\n    \n    // Test wrapped component (lazy loaded)\n    for (let i = 0; i < 5; i++) {\n      console.log(`Lazy loading iteration ${i + 1}/5`);\n      \n      // Navigate to wrapped (lazy loaded)\n      await page.goto('/?tab=wrapped');\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(1500); // Wait for lazy component\n      \n      // Navigate away to unmount\n      await page.goto('/?tab=dashboard');\n      await page.waitForTimeout(300);\n      \n      // Navigate back to trigger re-mount\n      await page.goto('/?tab=wrapped');\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(500);\n    }\n    \n    const validation = await monitor.validateHookIntegrity();\n    \n    expect(validation.violations, `Hook violations during lazy loading: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Lazy loading should pass hook validation').toBe(true);\n    \n    console.log('âœ… Lazy loading tests completed successfully');\n  });\n\n  test('should handle performance stress scenarios without hook violations', async ({ page }) => {\n    console.log('ðŸ§ª Testing performance stress scenarios...');\n    \n    // Create performance stress\n    await page.evaluate(() => {\n      // Add CPU stress\n      let stressCounter = 0;\n      const stressCPU = () => {\n        for (let i = 0; i < 10000; i++) {\n          stressCounter += Math.sin(i) * Math.cos(i);\n        }\n        if (stressCounter < 1000000) {\n          setTimeout(stressCPU, 1);\n        }\n      };\n      stressCPU();\n      \n      // Add memory stress\n      const memoryStress: number[][] = [];\n      for (let i = 0; i < 1000; i++) {\n        memoryStress.push(new Array(1000).fill(Math.random()));\n      }\n      (window as unknown as { memoryStress?: number[][] }).memoryStress = memoryStress;\n    });\n    \n    // Navigate under stress\n    const tabs = ['dashboard', 'transactions', 'insights', 'reports'];\n    \n    for (let cycle = 0; cycle < 3; cycle++) {\n      console.log(`Stress test cycle ${cycle + 1}/3`);\n      \n      for (const tab of tabs) {\n        await page.goto(`/?tab=${tab}`);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(200);\n      }\n    }\n    \n    // Clean up stress\n    await page.evaluate(() => {\n      delete (window as unknown as { memoryStress?: number[][] }).memoryStress;\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    const validation = await monitor.validateHookIntegrity();\n    \n    expect(validation.violations, `Hook violations under performance stress: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Performance stress should pass hook validation').toBe(true);\n    \n    console.log('âœ… Performance stress tests completed successfully');\n  });\n\n  test('should handle error recovery scenarios without hook violations', async ({ page }) => {\n    console.log('ðŸ§ª Testing error recovery scenarios...');\n    \n    // Test navigation to potentially problematic routes\n    const problematicRoutes = [\n      '/?tab=nonexistent',\n      '/?tab=dashboard&invalid=true',\n      '/?tab=',\n      '/invalid-route'\n    ];\n    \n    for (const route of problematicRoutes) {\n      console.log(`Testing problematic route: ${route}`);\n      \n      try {\n        await page.goto(route);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(500);\n      } catch (error) {\n        console.log(`Expected error for ${route}:`, error.message);\n      }\n      \n      // Recover to valid route\n      await page.goto('/?tab=dashboard');\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    const validation = await monitor.validateHookIntegrity();\n    \n    // For error recovery, we only care about hook violations, not general errors\n    expect(validation.violations, `Hook violations during error recovery: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Error recovery should pass hook validation').toBe(true);\n    \n    console.log('âœ… Error recovery tests completed successfully');\n  });\n\n  test('should validate performance metrics are within acceptable ranges', async ({ page }) => {\n    console.log('ðŸ§ª Validating performance metrics...');\n    \n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    // Perform measured navigation\n    for (const tab of tabs) {\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    const performanceMetrics = monitor.getPerformanceMetrics();\n    const memoryMetrics = monitor.getMemoryMetrics();\n    \n    console.log('Performance Metrics:', performanceMetrics);\n    console.log('Memory Metrics:', memoryMetrics);\n    \n    // Validate performance\n    expect(performanceMetrics.averageNavigationTime, 'Average navigation time should be reasonable').toBeLessThan(3000);\n    expect(performanceMetrics.maxNavigationTime, 'Max navigation time should be acceptable').toBeLessThan(5000);\n    \n    // Validate memory usage (if available)\n    if (memoryMetrics.maxMemoryUsage > 0) {\n      expect(memoryMetrics.maxMemoryUsage, 'Memory usage should be reasonable').toBeLessThan(200 * 1024 * 1024); // 200MB\n    }\n    \n    // Validate no hook violations\n    const validation = await monitor.validateHookIntegrity();\n    expect(validation.violations, `Hook violations during performance validation: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    \n    console.log('âœ… Performance metrics validation completed successfully');\n  });\n\n  test('should generate comprehensive test report', async ({ page }) => {\n    console.log('ðŸ§ª Generating comprehensive test report...');\n    \n    // Perform a comprehensive test sequence\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights', 'reports'];\n    \n    // Standard navigation\n    for (const tab of tabs) {\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(200);\n    }\n    \n    // Mobile navigation\n    await page.setViewportSize({ width: 375, height: 667 });\n    for (const tab of tabs.slice(0, 3)) {\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(200);\n    }\n    \n    // Back to desktop\n    await page.setViewportSize({ width: 1200, height: 800 });\n    \n    // Rapid navigation\n    for (let i = 0; i < 10; i++) {\n      const tab = tabs[i % tabs.length];\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForTimeout(100);\n    }\n    \n    // Final settlement\n    await page.waitForTimeout(2000);\n    \n    // Generate final report\n    const report = monitor.generateReport();\n    const validation = await monitor.validateHookIntegrity();\n    \n    console.log('ðŸ“Š COMPREHENSIVE TEST REPORT:');\n    console.log(report);\n    \n    // Final validation\n    expect(validation.violations, `Final hook validation failed: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Comprehensive test should pass all hook validations').toBe(true);\n    \n    console.log('âœ… Comprehensive test report generated successfully');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/comprehensive-responsive-navigation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":9,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page } from '@playwright/test';\n\n/**\n * Comprehensive Responsive Navigation Testing\n * Tests every navigation item, menu interaction, and responsive behavior\n */\n\ntest.describe('Comprehensive Responsive Navigation', () => {\n  let page: Page;\n\n  test.beforeEach(async ({ browser }) => {\n    page = await browser.newPage();\n    \n    // Enable console logging to catch errors\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        console.error('ðŸ”´ BROWSER ERROR:', msg.text());\n      } else if (msg.type() === 'warning') {\n        console.warn('ðŸŸ¡ BROWSER WARNING:', msg.text());\n      }\n    });\n\n    // Catch page errors\n    page.on('pageerror', error => {\n      console.error('ðŸ”´ PAGE ERROR:', error.message);\n    });\n  });\n\n  const viewports = [\n    { name: 'Mobile', width: 375, height: 667 },\n    { name: 'Tablet', width: 768, height: 1024 },\n    { name: 'Desktop', width: 1280, height: 720 },\n    { name: 'Large Desktop', width: 1920, height: 1080 },\n    { name: 'Ultra Wide', width: 2560, height: 1440 }\n  ];\n\n  for (const viewport of viewports) {\n    test(`should be fully responsive on ${viewport.name} (${viewport.width}x${viewport.height})`, async () => {\n      console.log(`ðŸ–¥ï¸ Testing ${viewport.name} viewport: ${viewport.width}x${viewport.height}`);\n      \n      // Set viewport\n      await page.setViewportSize({ \n        width: viewport.width, \n        height: viewport.height \n      });\n      \n      // Navigate to application\n      await page.goto('/', { waitUntil: 'networkidle' });\n      await page.waitForTimeout(2000);\n      \n      // Verify the page doesn't have fixed/hardcoded widths causing horizontal scroll\n      const hasHorizontalScroll = await page.evaluate(() => {\n        return document.body.scrollWidth > window.innerWidth;\n      });\n      \n      expect(hasHorizontalScroll).toBeFalsy();\n      \n      // Check that main content area adapts to viewport\n      const mainContent = page.locator('main');\n      await expect(mainContent).toBeVisible();\n      \n      const contentBox = await mainContent.boundingBox();\n      expect(contentBox?.width).toBeLessThanOrEqual(viewport.width);\n      \n      // Verify navigation is properly sized\n      const navigation = page.locator('nav, [role=\"navigation\"]');\n      if (await navigation.count() > 0) {\n        const navBox = await navigation.first().boundingBox();\n        expect(navBox?.width).toBeLessThanOrEqual(viewport.width);\n      }\n      \n      // Take screenshot for visual verification\n      await page.screenshot({ \n        path: `test-results/responsive-${viewport.name.toLowerCase().replace(' ', '-')}-${viewport.width}x${viewport.height}.png`,\n        fullPage: true \n      });\n      \n      console.log(`âœ… ${viewport.name} responsive test passed`);\n    });\n  }\n\n  test('should navigate through every main navigation item successfully', async () => {\n    console.log('ðŸ§­ Testing all main navigation items...');\n    \n    // Start with desktop viewport for comprehensive testing\n    await page.setViewportSize({ width: 1280, height: 720 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(2000);\n    \n    // Main navigation items to test\n    const mainNavItems = [\n      { name: 'Home', selector: '[aria-label*=\"Home\"], button:has-text(\"Home\")' },\n      { name: 'Accounts', selector: '[aria-label*=\"Accounts\"], button:has-text(\"Accounts\")' },\n      { name: 'Transactions', selector: '[aria-label*=\"Transactions\"], button:has-text(\"Transactions\")' },\n      { name: 'Insights', selector: '[aria-label*=\"Insights\"], button:has-text(\"Insights\")' }\n    ];\n    \n    for (const navItem of mainNavItems) {\n      console.log(`ðŸ”— Testing navigation to: ${navItem.name}`);\n      \n      // Find and click the navigation item\n      const navButton = page.locator(navItem.selector).first();\n      \n      if (await navButton.count() === 0) {\n        console.warn(`âš ï¸ Navigation item \"${navItem.name}\" not found, trying alternative selectors...`);\n        \n        // Try alternative selectors\n        const altSelectors = [\n          `text=\"${navItem.name}\"`,\n          `[aria-label=\"${navItem.name}\"]`,\n          `button:has-text(\"${navItem.name}\")`,\n          `a:has-text(\"${navItem.name}\")`,\n          `[data-testid*=\"${navItem.name.toLowerCase()}\"]`\n        ];\n        \n        let found = false;\n        for (const selector of altSelectors) {\n          const altButton = page.locator(selector);\n          if (await altButton.count() > 0) {\n            await altButton.first().click();\n            found = true;\n            break;\n          }\n        }\n        \n        if (!found) {\n          console.error(`âŒ Could not find navigation item: ${navItem.name}`);\n          continue;\n        }\n      } else {\n        await navButton.click();\n      }\n      \n      await page.waitForTimeout(1000);\n      \n      // Verify we navigated successfully (page has content)\n      const hasContent = await page.evaluate(() => {\n        const textContent = document.body.textContent || '';\n        return textContent.trim().length > 100;\n      });\n      \n      expect(hasContent).toBeTruthy();\n      \n      // Verify no white screen\n      const backgroundColor = await page.evaluate(() => {\n        const body = document.body;\n        const computedStyle = window.getComputedStyle(body);\n        return computedStyle.backgroundColor;\n      });\n      \n      expect(backgroundColor).not.toBe('rgb(255, 255, 255)');\n      \n      console.log(`âœ… Successfully navigated to ${navItem.name}`);\n    }\n  });\n\n  test('should navigate through \"More\" menu items successfully', async () => {\n    console.log('ðŸ“‹ Testing \"More\" menu navigation...');\n    \n    await page.setViewportSize({ width: 1280, height: 720 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(2000);\n    \n    // Find and click the \"More\" button\n    const moreButton = page.locator('[aria-label*=\"More\"], button:has-text(\"More\"), [aria-label*=\"navigation options\"]').first();\n    \n    if (await moreButton.count() > 0) {\n      await moreButton.click();\n      await page.waitForTimeout(500);\n      \n      // More menu items to test\n      const moreNavItems = [\n        'Credit Score',\n        'Savings Goals', \n        'Reports',\n        'Wrapped',\n        'Profile'\n      ];\n      \n      for (const itemName of moreNavItems) {\n        console.log(`ðŸ”— Testing More menu item: ${itemName}`);\n        \n        // Look for the item in the more menu\n        const menuItem = page.locator(`text=\"${itemName}\"`).first();\n        \n        if (await menuItem.count() > 0) {\n          await menuItem.click();\n          await page.waitForTimeout(1000);\n          \n          // Verify navigation worked\n          const hasContent = await page.evaluate(() => {\n            const textContent = document.body.textContent || '';\n            return textContent.trim().length > 50;\n          });\n          \n          expect(hasContent).toBeTruthy();\n          console.log(`âœ… Successfully navigated to ${itemName}`);\n          \n          // Go back to home for next test\n          await page.goto('/', { waitUntil: 'networkidle' });\n          await page.waitForTimeout(1000);\n          \n          // Reopen more menu if needed\n          if (await moreButton.count() > 0) {\n            await moreButton.click();\n            await page.waitForTimeout(500);\n          }\n        } else {\n          console.warn(`âš ï¸ More menu item \"${itemName}\" not found`);\n        }\n      }\n    } else {\n      console.warn('âš ï¸ More button not found, testing direct routes...');\n      \n      // Test direct navigation routes\n      const routes = [\n        '/credit-score',\n        '/savings', \n        '/reports',\n        '/profile'\n      ];\n      \n      for (const route of routes) {\n        console.log(`ðŸ”— Testing direct route: ${route}`);\n        \n        await page.goto(route, { waitUntil: 'networkidle' });\n        await page.waitForTimeout(1000);\n        \n        const hasContent = await page.evaluate(() => {\n          const textContent = document.body.textContent || '';\n          return textContent.trim().length > 50;\n        });\n        \n        expect(hasContent).toBeTruthy();\n        console.log(`âœ… Successfully loaded ${route}`);\n      }\n    }\n  });\n\n  test('should return to dashboard from all navigation states', async () => {\n    console.log('ðŸ  Testing return to dashboard from all states...');\n    \n    await page.setViewportSize({ width: 1280, height: 720 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(2000);\n    \n    // Test pages to navigate to and return from\n    const testPages = [\n      { name: 'Transactions', url: '/?view=transactions' },\n      { name: 'Insights', url: '/?view=insights' },\n      { name: 'Reports', url: '/?view=reports' },\n      { name: 'Savings', url: '/?view=savings' }\n    ];\n    \n    for (const testPage of testPages) {\n      console.log(`ðŸ”„ Testing round-trip: Dashboard â†’ ${testPage.name} â†’ Dashboard`);\n      \n      // Navigate to test page\n      await page.goto(testPage.url, { waitUntil: 'networkidle' });\n      await page.waitForTimeout(1000);\n      \n      // Verify we're on the test page\n      const pageContent = await page.evaluate(() => document.body.textContent || '');\n      expect(pageContent.length).toBeGreaterThan(50);\n      \n      // Find and click Home/Dashboard button\n      const homeSelectors = [\n        '[aria-label*=\"Home\"]',\n        'button:has-text(\"Home\")',\n        '[aria-label*=\"Dashboard\"]',\n        'button:has-text(\"Dashboard\")',\n        '[data-testid*=\"home\"]',\n        'text=\"Home\"'\n      ];\n      \n      let returnedHome = false;\n      for (const selector of homeSelectors) {\n        const homeButton = page.locator(selector);\n        if (await homeButton.count() > 0) {\n          await homeButton.first().click();\n          await page.waitForTimeout(1000);\n          returnedHome = true;\n          break;\n        }\n      }\n      \n      if (!returnedHome) {\n        // Try navigating to root URL directly\n        await page.goto('/', { waitUntil: 'networkidle' });\n        await page.waitForTimeout(1000);\n      }\n      \n      // Verify we're back on dashboard\n      const dashboardContent = await page.evaluate(() => document.body.textContent || '');\n      expect(dashboardContent.length).toBeGreaterThan(100);\n      \n      console.log(`âœ… Successfully returned to dashboard from ${testPage.name}`);\n    }\n  });\n\n  test('should handle responsive layout transitions smoothly', async () => {\n    console.log('ðŸ“ Testing responsive layout transitions...');\n    \n    // Start at mobile size\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(1000);\n    \n    // Gradually increase viewport size and check layout\n    const sizes = [\n      { width: 640, height: 800 },   // SM\n      { width: 768, height: 1024 },  // MD  \n      { width: 1024, height: 768 },  // LG\n      { width: 1280, height: 800 },  // XL\n      { width: 1920, height: 1080 }  // 2XL\n    ];\n    \n    for (const size of sizes) {\n      console.log(`ðŸ“ Transitioning to ${size.width}x${size.height}`);\n      \n      await page.setViewportSize(size);\n      await page.waitForTimeout(500); // Allow layout to settle\n      \n      // Check for layout overflow\n      const hasOverflow = await page.evaluate(() => {\n        return document.body.scrollWidth > window.innerWidth ||\n               document.documentElement.scrollWidth > window.innerWidth;\n      });\n      \n      expect(hasOverflow).toBeFalsy();\n      \n      // Verify content is still accessible\n      const isContentVisible = await page.evaluate(() => {\n        const main = document.querySelector('main');\n        return main && main.offsetWidth > 0 && main.offsetHeight > 0;\n      });\n      \n      expect(isContentVisible).toBeTruthy();\n      \n      console.log(`âœ… Layout transition to ${size.width}x${size.height} successful`);\n    }\n  });\n\n  test('should have proper touch targets on all screen sizes', async () => {\n    console.log('ðŸ‘† Testing touch target sizes across viewports...');\n    \n    for (const viewport of viewports) {\n      await page.setViewportSize({ \n        width: viewport.width, \n        height: viewport.height \n      });\n      \n      await page.goto('/', { waitUntil: 'networkidle' });\n      await page.waitForTimeout(1000);\n      \n      // Find all interactive elements\n      const interactiveElements = await page.locator('button, a, [role=\"button\"], [role=\"tab\"], input, select').all();\n      \n      for (const element of interactiveElements) {\n        const box = await element.boundingBox();\n        \n        if (box) {\n          // WCAG AA requires minimum 44x44px touch targets\n          if (viewport.name === 'Mobile' || viewport.name === 'Tablet') {\n            expect(box.width).toBeGreaterThanOrEqual(44);\n            expect(box.height).toBeGreaterThanOrEqual(44);\n          }\n        }\n      }\n      \n      console.log(`âœ… Touch targets verified for ${viewport.name}`);\n    }\n  });\n\n  test('should be fully responsive on Desktop viewports', async ({ page }) => {\n    console.log('ðŸ–¥ï¸ Testing Desktop responsive behavior...');\n    \n    const desktopViewports = [\n      { width: 1280, height: 720 },\n      { width: 1440, height: 900 },\n      { width: 1920, height: 1080 },\n      { width: 2560, height: 1440 }\n    ];\n    \n    for (const viewport of desktopViewports) {\n      console.log(`Testing ${viewport.width}x${viewport.height}`);\n      \n      await page.setViewportSize(viewport);\n      await page.goto('/', { waitUntil: 'networkidle' });\n      await page.waitForTimeout(2000);\n      \n      // Check for horizontal scroll (should not exist)\n      const hasHorizontalScroll = await page.evaluate(() => {\n        return document.body.scrollWidth > window.innerWidth;\n      });\n      \n      expect(hasHorizontalScroll).toBeFalsy();\n      \n      // Verify main content fills available space properly\n      const mainContent = page.locator('main');\n      await expect(mainContent).toBeVisible();\n      \n      const contentBox = await mainContent.boundingBox();\n             expect(contentBox?.width || 0).toBeLessThanOrEqual(viewport.width);\n       expect(contentBox?.width || 0).toBeGreaterThan(viewport.width * 0.5); // Should use significant portion of screen\n      \n      await page.screenshot({ \n        path: `test-results/desktop-responsive-${viewport.width}x${viewport.height}.png`,\n        fullPage: true \n      });\n      \n      console.log(`âœ… ${viewport.width}x${viewport.height} responsive test passed`);\n    }\n  });\n\n  test('should navigate through all main navigation successfully', async ({ page }) => {\n    console.log('ðŸ§­ Testing comprehensive navigation...');\n    \n    await page.setViewportSize({ width: 1920, height: 1080 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(3000);\n    \n    // Test main navigation items\n    const navItems = ['Home', 'Accounts', 'Transactions', 'Insights'];\n    \n    for (const item of navItems) {\n      console.log(`ðŸ”— Testing navigation to: ${item}`);\n      \n      // Multiple selector strategies\n      const selectors = [\n        `button:has-text(\"${item}\")`,\n        `[aria-label*=\"${item}\"]`,\n        `text=\"${item}\"`,\n        `a:has-text(\"${item}\")`\n      ];\n      \n      let clicked = false;\n      for (const selector of selectors) {\n        const element = page.locator(selector).first();\n        if (await element.count() > 0) {\n          await element.click();\n          clicked = true;\n          break;\n        }\n      }\n      \n      if (clicked) {\n        await page.waitForTimeout(2000);\n        \n        // Verify content loaded\n        const hasContent = await page.evaluate(() => {\n          return document.body.textContent?.trim().length > 100;\n        });\n        \n        expect(hasContent).toBeTruthy();\n        console.log(`âœ… Successfully navigated to ${item}`);\n      } else {\n        console.warn(`âš ï¸ Could not find navigation for ${item}`);\n      }\n    }\n  });\n\n  test('should handle More menu navigation', async ({ page }) => {\n    console.log('ðŸ“‹ Testing More menu...');\n    \n    await page.setViewportSize({ width: 1920, height: 1080 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(3000);\n    \n    // Find More button\n    const moreSelectors = [\n      'button:has-text(\"More\")',\n      '[aria-label*=\"More\"]',\n      '[aria-label*=\"navigation options\"]',\n      'text=\"More\"'\n    ];\n    \n         let moreButton = null;\n     for (const selector of moreSelectors) {\n       const element = page.locator(selector).first();\n       if (await element.count() > 0) {\n         moreButton = element;\n         break;\n       }\n     }\n     \n     if (moreButton && await moreButton.count() > 0) {\n       await moreButton.click();\n       await page.waitForTimeout(1000);\n       \n       // Test more menu items\n       const moreItems = ['Credit Score', 'Savings Goals', 'Reports', 'Profile'];\n       \n       for (const item of moreItems) {\n         console.log(`ðŸ”— Testing More menu item: ${item}`);\n         \n         const menuItem = page.locator(`text=\"${item}\"`).first();\n         \n         if (await menuItem.count() > 0) {\n           await menuItem.click();\n           await page.waitForTimeout(2000);\n           \n           const hasContent = await page.evaluate(() => {\n             return (document.body.textContent?.trim().length || 0) > 50;\n           });\n           \n           expect(hasContent).toBeTruthy();\n           console.log(`âœ… Successfully navigated to ${item}`);\n           \n           // Return to home\n           await page.goto('/', { waitUntil: 'networkidle' });\n           await page.waitForTimeout(1500);\n           \n           // Reopen more menu\n           if (moreButton && await moreButton.count() > 0) {\n             await moreButton.click();\n             await page.waitForTimeout(500);\n           }\n         }\n       }\n    } else {\n      console.log('ðŸ”— Testing direct routes...');\n      \n      const routes = ['/credit-score', '/savings', '/reports', '/profile'];\n      \n      for (const route of routes) {\n        await page.goto(route, { waitUntil: 'networkidle' });\n        await page.waitForTimeout(1500);\n        \n        const hasContent = await page.evaluate(() => {\n          return document.body.textContent?.trim().length > 50;\n        });\n        \n        expect(hasContent).toBeTruthy();\n        console.log(`âœ… Successfully loaded ${route}`);\n      }\n    }\n  });\n\n  test('should return to dashboard from all navigation states', async ({ page }) => {\n    console.log('ðŸ  Testing return to dashboard...');\n    \n    await page.setViewportSize({ width: 1920, height: 1080 });\n    await page.goto('/', { waitUntil: 'networkidle' });\n    await page.waitForTimeout(2000);\n    \n    const testViews = [\n      { name: 'Transactions', url: '/?view=transactions' },\n      { name: 'Insights', url: '/?view=insights' },\n      { name: 'Reports', url: '/?view=reports' },\n      { name: 'Savings', url: '/?view=savings' }\n    ];\n    \n    for (const view of testViews) {\n      console.log(`ðŸ”„ Testing: Dashboard â†’ ${view.name} â†’ Dashboard`);\n      \n      // Navigate to view\n      await page.goto(view.url, { waitUntil: 'networkidle' });\n      await page.waitForTimeout(2000);\n      \n      // Verify we're on the view\n      const content = await page.evaluate(() => document.body.textContent || '');\n      expect(content.length).toBeGreaterThan(50);\n      \n      // Return to dashboard\n      const homeSelectors = [\n        'button:has-text(\"Home\")',\n        '[aria-label*=\"Home\"]',\n        'text=\"Home\"',\n        'a[href=\"/\"]'\n      ];\n      \n      let returnedHome = false;\n      for (const selector of homeSelectors) {\n        const homeBtn = page.locator(selector).first();\n        if (await homeBtn.count() > 0) {\n          await homeBtn.click();\n          await page.waitForTimeout(2000);\n          returnedHome = true;\n          break;\n        }\n      }\n      \n      if (!returnedHome) {\n        await page.goto('/', { waitUntil: 'networkidle' });\n        await page.waitForTimeout(1500);\n      }\n      \n      // Verify back on dashboard\n      const dashContent = await page.evaluate(() => document.body.textContent || '');\n      expect(dashContent.length).toBeGreaterThan(100);\n      \n      console.log(`âœ… Successfully returned from ${view.name}`);\n    }\n  });\n\n  test('should handle layout transitions smoothly', async ({ page }) => {\n    console.log('ðŸ“ Testing layout transitions...');\n    \n    await page.goto('/', { waitUntil: 'networkidle' });\n    \n    const sizes = [\n      { width: 1024, height: 768 },\n      { width: 1280, height: 800 },\n      { width: 1440, height: 900 },\n      { width: 1920, height: 1080 },\n      { width: 2560, height: 1440 }\n    ];\n    \n    for (const size of sizes) {\n      console.log(`ðŸ“ Testing ${size.width}x${size.height}`);\n      \n      await page.setViewportSize(size);\n      await page.waitForTimeout(1000);\n      \n      // Check for layout overflow\n      const hasOverflow = await page.evaluate(() => {\n        return document.body.scrollWidth > window.innerWidth;\n      });\n      \n      expect(hasOverflow).toBeFalsy();\n      \n      // Verify main content is visible and properly sized\n      const mainVisible = await page.evaluate(() => {\n        const main = document.querySelector('main');\n        return main && main.offsetWidth > 0 && main.offsetHeight > 0;\n      });\n      \n      expect(mainVisible).toBeTruthy();\n      \n      console.log(`âœ… Layout transition successful for ${size.width}x${size.height}`);\n    }\n  });\n\n  test('should have consistent navigation across all screen sizes', async ({ page }) => {\n    console.log('ðŸ”„ Testing navigation consistency...');\n    \n    for (const viewport of viewports) {\n      console.log(`Testing navigation on ${viewport.name}`);\n      \n      await page.setViewportSize(viewport);\n      await page.goto('/', { waitUntil: 'networkidle' });\n      await page.waitForTimeout(2000);\n      \n      // Check that navigation elements are present\n      const hasNavigation = await page.evaluate(() => {\n        const nav = document.querySelector('nav, [role=\"navigation\"]');\n        const buttons = document.querySelectorAll('button, a');\n        return nav !== null && buttons.length > 0;\n      });\n      \n      expect(hasNavigation).toBeTruthy();\n      \n      // Verify interactive elements have proper sizing\n      const interactiveElements = await page.locator('button, a, [role=\"button\"]').all();\n      \n      for (const element of interactiveElements.slice(0, 5)) { // Test first 5 to avoid timeout\n        const box = await element.boundingBox();\n        if (box) {\n          // Elements should be at least 44x44px for accessibility\n          if (viewport.width <= 768) {\n            expect(box.width).toBeGreaterThanOrEqual(40);\n            expect(box.height).toBeGreaterThanOrEqual(40);\n          }\n        }\n      }\n      \n      console.log(`âœ… Navigation consistency verified for ${viewport.name}`);\n    }\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/dashboard.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/desktop-chart-performance.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":30,"column":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Desktop Chart Performance Tests\n * \n * Focused on performance metrics, animation frame rates, and load time validation\n * for chart components on desktop viewports\n */\n\nimport { test, expect, Page } from '@playwright/test';\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  LOAD_TIME_MAX: 5000, // 5 seconds\n  ANIMATION_DURATION_MAX: 1500, // 1.5 seconds with overhead\n  FPS_MIN: 30, // Minimum 30 FPS\n  MEMORY_LEAK_THRESHOLD: 50 * 1024 * 1024, // 50MB\n  PAINT_TIME_MAX: 100, // 100ms for first paint\n  INTERACTIVE_TIME_MAX: 2000 // 2 seconds to interactive\n};\n\n// Large dataset for performance testing\nconst LARGE_CHART_DATA = Array.from({ length: 1000 }, (_, i) => ({\n  date: new Date(2023, 0, 1 + i).toISOString().split('T')[0],\n  value: Math.random() * 100000 + 50000,\n  spending: Math.random() * 5000 + 2000,\n  income: Math.random() * 3000 + 5000,\n  investments: Math.random() * 10000 + 5000\n}));\n\n// Performance monitoring helper\nasync function measurePerformanceMetrics(page: Page, action: () => Promise<void>) {\n  // Start performance monitoring\n  await page.evaluate(() => {\n    performance.mark('test-start');\n    // Monitor memory usage\n    if ('memory' in performance) {\n      (window as any).initialMemory = (performance as any).memory.usedJSHeapSize;\n    }\n  });\n\n  const startTime = Date.now();\n  await action();\n  const endTime = Date.now();\n\n  // Collect performance metrics\n  const metrics = await page.evaluate(() => {\n    performance.mark('test-end');\n    performance.measure('test-duration', 'test-start', 'test-end');\n    \n    const measure = performance.getEntriesByName('test-duration')[0];\n    const paintMetrics = performance.getEntriesByType('paint');\n    const navigationMetrics = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    \n    return {\n      duration: measure.duration,\n      firstPaint: paintMetrics.find(m => m.name === 'first-paint')?.startTime || 0,\n      firstContentfulPaint: paintMetrics.find(m => m.name === 'first-contentful-paint')?.startTime || 0,\n      domInteractive: navigationMetrics?.domInteractive || 0,\n      loadComplete: navigationMetrics?.loadEventEnd || 0,\n      memoryUsage: 'memory' in performance ? (performance as any).memory.usedJSHeapSize : 0,\n      initialMemory: (window as any).initialMemory || 0\n    };\n  });\n\n  return {\n    ...metrics,\n    totalTime: endTime - startTime,\n    memoryDelta: metrics.memoryUsage - metrics.initialMemory\n  };\n}\n\n// Animation frame monitoring\nasync function monitorAnimationFrameRate(page: Page, duration: number = 2000) {\n  return await page.evaluate((duration) => {\n    return new Promise((resolve) => {\n      const frames: number[] = [];\n      let startTime = performance.now();\n      \n      function recordFrame() {\n        frames.push(performance.now());\n        \n        if (performance.now() - startTime < duration) {\n          requestAnimationFrame(recordFrame);\n        } else {\n          // Calculate FPS\n          const totalTime = frames[frames.length - 1] - frames[0];\n          const fps = (frames.length / totalTime) * 1000;\n          \n          // Calculate frame time consistency\n          const frameTimes = frames.slice(1).map((time, i) => time - frames[i]);\n          const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;\n          const frameTimeVariance = frameTimes.reduce((sum, time) => sum + Math.pow(time - avgFrameTime, 2), 0) / frameTimes.length;\n          \n          resolve({\n            fps,\n            frames: frames.length,\n            avgFrameTime,\n            frameTimeVariance,\n            droppedFrames: frameTimes.filter(time => time > 16.67 * 2).length // Frames taking more than 2 frame periods\n          });\n        }\n      }\n      \n      requestAnimationFrame(recordFrame);\n    });\n  }, duration);\n}\n\n// Create performance test page\nasync function createPerformanceTestPage(page: Page, chartType: string, data: any[], enableAnimations: boolean = true) {\n  await page.goto('/');\n  \n  await page.evaluate(({ chartType, data, enableAnimations }) => {\n    // Create container\n    const container = document.createElement('div');\n    container.id = 'perf-test-container';\n    container.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      z-index: 9999;\n      background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);\n      padding: 2rem;\n    `;\n    \n    document.body.appendChild(container);\n    \n    // Create React component\n    const script = document.createElement('script');\n    script.type = 'module';\n    script.textContent = `\n      import React from 'react';\n      import { createRoot } from 'react-dom/client';\n      import { GraphBase } from '/src/components/charts/index.ts';\n      \n      const PerfTestChart = () => {\n        return React.createElement(GraphBase, {\n          type: '${chartType}',\n          data: ${JSON.stringify(data)},\n          title: 'Performance Test Chart',\n          subtitle: 'Testing with ${data.length} data points',\n          timeControls: {\n            show: true,\n            options: ['1W', '1M', '3M', '6M', '1Y', 'ALL'],\n            defaultRange: '1M'\n          },\n          dimensions: {\n            height: 600,\n            responsive: true\n          },\n          animation: {\n            enable: ${enableAnimations},\n            duration: 800\n          },\n          tooltip: { show: true },\n          grid: { show: true, horizontal: true, vertical: false },\n          accessibility: {\n            keyboardNavigation: true,\n            screenReaderSupport: true\n          }\n        });\n      };\n      \n      const root = createRoot(document.getElementById('perf-test-container'));\n      root.render(React.createElement(PerfTestChart));\n    `;\n    \n    document.head.appendChild(script);\n  }, { chartType, data, enableAnimations });\n  \n  // Wait for chart to render\n  await page.waitForSelector('.chart-component', { timeout: 15000 });\n  await page.waitForTimeout(1000);\n}\n\ntest.describe('Desktop Chart Performance Tests', () => {\n  \n  test.describe('Load Time Performance', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('Chart loads within performance threshold', async ({ page }) => {\n      const metrics = await measurePerformanceMetrics(page, async () => {\n        await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 100));\n      });\n      \n      // Validate load time\n      expect(metrics.totalTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOAD_TIME_MAX);\n      \n      // Validate first paint\n      expect(metrics.firstPaint).toBeLessThan(PERFORMANCE_THRESHOLDS.PAINT_TIME_MAX);\n      \n      // Validate interactive time\n      expect(metrics.domInteractive).toBeLessThan(PERFORMANCE_THRESHOLDS.INTERACTIVE_TIME_MAX);\n      \n      console.log('Load Performance Metrics:', {\n        loadTime: `${metrics.totalTime}ms`,\n        firstPaint: `${metrics.firstPaint}ms`,\n        interactive: `${metrics.domInteractive}ms`,\n        memoryDelta: `${(metrics.memoryDelta / 1024 / 1024).toFixed(2)}MB`\n      });\n    });\n\n    test('Large dataset handling (1000+ points)', async ({ page }) => {\n      const metrics = await measurePerformanceMetrics(page, async () => {\n        await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA);\n      });\n      \n      // Should still load within reasonable time for large datasets\n      expect(metrics.totalTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOAD_TIME_MAX * 2);\n      \n      // Memory usage should be reasonable\n      expect(metrics.memoryDelta).toBeLessThan(PERFORMANCE_THRESHOLDS.MEMORY_LEAK_THRESHOLD);\n      \n      // Chart should be responsive\n      const chartSvg = page.locator('svg');\n      await expect(chartSvg).toBeVisible();\n      \n      console.log('Large Dataset Performance:', {\n        dataPoints: LARGE_CHART_DATA.length,\n        loadTime: `${metrics.totalTime}ms`,\n        memoryUsage: `${(metrics.memoryDelta / 1024 / 1024).toFixed(2)}MB`\n      });\n    });\n\n    test('Multiple chart types load performance comparison', async ({ page }) => {\n      const chartTypes = ['line', 'area', 'bar', 'stackedBar'];\n      const performanceResults: { [key: string]: any } = {};\n      \n      for (const chartType of chartTypes) {\n        const metrics = await measurePerformanceMetrics(page, async () => {\n          await createPerformanceTestPage(page, chartType, LARGE_CHART_DATA.slice(0, 200));\n        });\n        \n        performanceResults[chartType] = {\n          loadTime: metrics.totalTime,\n          memoryUsage: metrics.memoryDelta,\n          firstPaint: metrics.firstPaint\n        };\n        \n        // Each chart type should load within threshold\n        expect(metrics.totalTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOAD_TIME_MAX);\n        \n        // Clear the page for next test\n        await page.evaluate(() => {\n          const container = document.getElementById('perf-test-container');\n          if (container) container.remove();\n        });\n      }\n      \n      console.log('Chart Type Performance Comparison:', performanceResults);\n    });\n  });\n\n  test.describe('Animation Performance', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('60fps animation target', async ({ page }) => {\n      await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 100), true);\n      \n      // Trigger animation by changing time range\n      const timeButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n      \n      // Monitor frame rate during animation\n      const animationPromise = monitorAnimationFrameRate(page, 1200);\n      await timeButton.click();\n      \n      const frameMetrics = await animationPromise;\n      \n      // Should maintain reasonable frame rate\n      expect(frameMetrics.fps).toBeGreaterThan(PERFORMANCE_THRESHOLDS.FPS_MIN);\n      \n      // Should not have too many dropped frames\n      expect(frameMetrics.droppedFrames).toBeLessThan(frameMetrics.frames * 0.1); // Less than 10% dropped\n      \n      console.log('Animation Performance:', {\n        fps: frameMetrics.fps.toFixed(1),\n        avgFrameTime: `${frameMetrics.avgFrameTime.toFixed(2)}ms`,\n        droppedFrames: frameMetrics.droppedFrames,\n        consistency: frameMetrics.frameTimeVariance.toFixed(2)\n      });\n    });\n\n    test('Animation with reduced motion', async ({ page }) => {\n      // Enable reduced motion\n      await page.emulateMedia({ reducedMotion: 'reduce' });\n      \n      const metrics = await measurePerformanceMetrics(page, async () => {\n        await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 100), false);\n        \n        // Change time range\n        const timeButton = page.locator('[role=\"tab\"]', { hasText: '6M' });\n        await timeButton.click();\n        await page.waitForTimeout(100); // Minimal wait for reduced motion\n      });\n      \n      // Should complete faster with reduced motion\n      expect(metrics.duration).toBeLessThan(500); // Much faster without animations\n      \n      // Chart should still update correctly\n      const selectedButton = page.locator('[role=\"tab\"][aria-selected=\"true\"]', { hasText: '6M' });\n      await expect(selectedButton).toBeVisible();\n    });\n\n    test('Hover animation performance', async ({ page }) => {\n      await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 200));\n      \n      const chartArea = page.locator('.recharts-wrapper');\n      \n      // Monitor performance during hover interactions\n      const frameMetrics = await page.evaluate(async () => {\n        const frames: number[] = [];\n        let frameCount = 0;\n        \n        const recordFrame = () => {\n          frames.push(performance.now());\n          frameCount++;\n          if (frameCount < 60) { // Record for ~1 second at 60fps\n            requestAnimationFrame(recordFrame);\n          }\n        };\n        \n        requestAnimationFrame(recordFrame);\n        \n        // Simulate hover events\n        const chartElement = document.querySelector('.recharts-wrapper') as HTMLElement;\n        if (chartElement) {\n          const rect = chartElement.getBoundingClientRect();\n          \n          // Simulate multiple hover positions\n          for (let i = 0; i < 10; i++) {\n            const x = rect.left + (rect.width / 10) * i;\n            const y = rect.top + rect.height / 2;\n            \n            const mouseEvent = new MouseEvent('mousemove', {\n              clientX: x,\n              clientY: y,\n              bubbles: true\n            });\n            chartElement.dispatchEvent(mouseEvent);\n            \n            await new Promise(resolve => setTimeout(resolve, 50));\n          }\n        }\n        \n        // Wait for frame collection to complete\n        await new Promise(resolve => setTimeout(resolve, 1100));\n        \n        // Calculate metrics\n        const totalTime = frames[frames.length - 1] - frames[0];\n        const fps = (frames.length / totalTime) * 1000;\n        \n        return { fps, frames: frames.length };\n      });\n      \n      // Should maintain good frame rate during hover\n      expect(frameMetrics.fps).toBeGreaterThan(25); // Slightly lower threshold for hover\n    });\n  });\n\n  test.describe('Memory Usage and Cleanup', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('Memory usage remains stable', async ({ page }) => {\n      const initialMemory = await page.evaluate(() => {\n        return 'memory' in performance ? (performance as any).memory.usedJSHeapSize : 0;\n      });\n      \n      // Create and destroy multiple charts\n      for (let i = 0; i < 5; i++) {\n        await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 100));\n        \n        // Interact with chart\n        const timeButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n        await timeButton.click();\n        await page.waitForTimeout(200);\n        \n        // Remove chart\n        await page.evaluate(() => {\n          const container = document.getElementById('perf-test-container');\n          if (container) container.remove();\n        });\n        \n        // Force garbage collection if available\n        await page.evaluate(() => {\n          if ('gc' in window) {\n            (window as any).gc();\n          }\n        });\n      }\n      \n      const finalMemory = await page.evaluate(() => {\n        return 'memory' in performance ? (performance as any).memory.usedJSHeapSize : 0;\n      });\n      \n      const memoryDelta = finalMemory - initialMemory;\n      \n      // Memory should not increase significantly\n      expect(memoryDelta).toBeLessThan(PERFORMANCE_THRESHOLDS.MEMORY_LEAK_THRESHOLD);\n      \n      console.log('Memory Usage Test:', {\n        initial: `${(initialMemory / 1024 / 1024).toFixed(2)}MB`,\n        final: `${(finalMemory / 1024 / 1024).toFixed(2)}MB`,\n        delta: `${(memoryDelta / 1024 / 1024).toFixed(2)}MB`\n      });\n    });\n\n    test('Event listener cleanup', async ({ page }) => {\n      await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 50));\n      \n      // Count initial event listeners\n      const initialListeners = await page.evaluate(() => {\n        const events = ['mousemove', 'mouseenter', 'mouseleave', 'click', 'keydown'];\n        let count = 0;\n        \n        events.forEach(eventType => {\n          const listeners = (document as any).getEventListeners?.(document.body)?.[eventType] || [];\n          count += listeners.length;\n        });\n        \n        return count;\n      });\n      \n      // Remove chart\n      await page.evaluate(() => {\n        const container = document.getElementById('perf-test-container');\n        if (container) container.remove();\n      });\n      \n      // Check event listeners after cleanup\n      const finalListeners = await page.evaluate(() => {\n        const events = ['mousemove', 'mouseenter', 'mouseleave', 'click', 'keydown'];\n        let count = 0;\n        \n        events.forEach(eventType => {\n          const listeners = (document as any).getEventListeners?.(document.body)?.[eventType] || [];\n          count += listeners.length;\n        });\n        \n        return count;\n      });\n      \n      // Event listeners should be cleaned up\n      expect(finalListeners).toBeLessThanOrEqual(initialListeners);\n    });\n  });\n\n  test.describe('Responsive Performance', () => {\n    test('Performance across different desktop sizes', async ({ page }) => {\n      const viewports = [\n        { width: 1280, height: 720, name: 'HD' },\n        { width: 1920, height: 1080, name: 'Full HD' },\n        { width: 2560, height: 1440, name: 'QHD' }\n      ];\n      \n      const performanceResults: { [key: string]: any } = {};\n      \n      for (const viewport of viewports) {\n        await page.setViewportSize(viewport);\n        \n        const metrics = await measurePerformanceMetrics(page, async () => {\n          await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 150));\n        });\n        \n        performanceResults[viewport.name] = {\n          loadTime: metrics.totalTime,\n          memoryUsage: metrics.memoryDelta,\n          firstPaint: metrics.firstPaint\n        };\n        \n        // Should perform well at all resolutions\n        expect(metrics.totalTime).toBeLessThan(PERFORMANCE_THRESHOLDS.LOAD_TIME_MAX);\n        \n        // Clear for next test\n        await page.evaluate(() => {\n          const container = document.getElementById('perf-test-container');\n          if (container) container.remove();\n        });\n      }\n      \n      console.log('Viewport Performance Results:', performanceResults);\n    });\n\n    test('Resize performance', async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n      await createPerformanceTestPage(page, 'line', LARGE_CHART_DATA.slice(0, 100));\n      \n      // Monitor performance during resize\n      const resizeMetrics = await measurePerformanceMetrics(page, async () => {\n        // Simulate multiple resizes\n        const sizes = [\n          { width: 1440, height: 900 },\n          { width: 1280, height: 720 },\n          { width: 1600, height: 900 },\n          { width: 1920, height: 1080 }\n        ];\n        \n        for (const size of sizes) {\n          await page.setViewportSize(size);\n          await page.waitForTimeout(100); // Allow resize to process\n        }\n      });\n      \n      // Resize operations should be fast\n      expect(resizeMetrics.duration).toBeLessThan(1000); // 1 second for all resizes\n      \n      // Chart should still be visible and functional\n      const chartSvg = page.locator('svg');\n      await expect(chartSvg).toBeVisible();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/desktop-chart-tests.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":50,"column":40}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Desktop Chart Components Test Suite\n * \n * Mission: Execute comprehensive Playwright tests for all chart components on desktop viewports (â‰¥1280px)\n * \n * Test Coverage:\n * - GraphBase foundation functionality\n * - LineChart rendering and interactions\n * - AreaChart gradient rendering\n * - StackedBarChart category interactions\n * - TimeRangeToggle selection behavior\n * - Desktop-specific features (hover, keyboard nav, multi-chart coordination)\n * - Apple UX validation (colors, typography, animation)\n * - Financial data accuracy (currency formatting, large numbers)\n * - Visual regression testing\n * - Performance and accessibility compliance\n */\n\nimport { test, expect, Page, BrowserContext } from '@playwright/test';\n\n// Desktop viewport configurations\nconst DESKTOP_VIEWPORTS = [\n  { name: 'HD', width: 1280, height: 720 },\n  { name: 'MacBook Air', width: 1440, height: 900 },\n  { name: 'Full HD', width: 1920, height: 1080 },\n  { name: 'QHD', width: 2560, height: 1440 }\n];\n\n// Test data for charts\nconst CHART_TEST_DATA = {\n  lineChart: [\n    { date: '2024-01-01', value: 50000, spending: 3200, income: 5500 },\n    { date: '2024-02-01', value: 52000, spending: 3400, income: 5600 },\n    { date: '2024-03-01', value: 48000, spending: 3800, income: 5400 },\n    { date: '2024-04-01', value: 55000, spending: 3100, income: 5800 },\n    { date: '2024-05-01', value: 58000, spending: 2900, income: 6000 },\n    { date: '2024-06-01', value: 62000, spending: 3300, income: 6200 }\n  ],\n  largeNumbers: [\n    { date: '2024-01-01', portfolio: 850000, assets: 1200000, liabilities: 350000 },\n    { date: '2024-02-01', portfolio: 875000, assets: 1225000, liabilities: 350000 },\n    { date: '2024-03-01', portfolio: 920000, assets: 1270000, liabilities: 350000 },\n    { date: '2024-04-01', portfolio: 890000, assets: 1240000, liabilities: 350000 },\n    { date: '2024-05-01', portfolio: 960000, assets: 1310000, liabilities: 350000 },\n    { date: '2024-06-01', portfolio: 1050000, assets: 1400000, liabilities: 350000 }\n  ]\n};\n\n// Helper function to create a test page with chart demo\nasync function createChartTestPage(page: Page, chartType: string, data: any[], options: any = {}) {\n  await page.goto('/');\n  \n  // Inject test chart into the page\n  await page.evaluate(({ chartType, data, options }) => {\n    // Create a container for the test chart\n    const container = document.createElement('div');\n    container.id = 'test-chart-container';\n    container.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100vw;\n      height: 100vh;\n      z-index: 9999;\n      background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);\n      padding: 2rem;\n      box-sizing: border-box;\n    `;\n    \n    document.body.appendChild(container);\n    \n    // Create React component script\n    const script = document.createElement('script');\n    script.type = 'module';\n    script.textContent = `\n      import React from 'react';\n      import { createRoot } from 'react-dom/client';\n      import { GraphBase } from '/src/components/charts/index.ts';\n      \n      const TestChart = () => {\n        return React.createElement(GraphBase, {\n          type: '${chartType}',\n          data: ${JSON.stringify(data)},\n          title: 'Test ${chartType.charAt(0).toUpperCase() + chartType.slice(1)} Chart',\n          subtitle: 'Desktop viewport testing',\n          timeControls: {\n            show: true,\n            options: ['1W', '1M', '3M', '6M', '1Y', 'ALL'],\n            defaultRange: '1M'\n          },\n          dimensions: {\n            height: 400,\n            responsive: true\n          },\n          accessibility: {\n            keyboardNavigation: true,\n            screenReaderSupport: true,\n            dataTableAlternative: true,\n            liveRegion: true\n          },\n          animation: {\n            enable: true,\n            duration: 800\n          },\n          tooltip: {\n            show: true\n          },\n          grid: {\n            show: true,\n            horizontal: true,\n            vertical: false\n          },\n          ...${JSON.stringify(options)}\n        });\n      };\n      \n      const root = createRoot(document.getElementById('test-chart-container'));\n      root.render(React.createElement(TestChart));\n    `;\n    \n    document.head.appendChild(script);\n  }, { chartType, data, options });\n  \n  // Wait for chart to render\n  await page.waitForSelector('[data-testid=\"chart-container\"], .chart-component', { timeout: 10000 });\n  await page.waitForTimeout(1000); // Allow animations to complete\n}\n\n// Performance monitoring helper\nasync function measurePerformance(page: Page, action: () => Promise<void>) {\n  const metrics = await page.evaluate(() => {\n    performance.mark('test-start');\n    return {\n      start: performance.now()\n    };\n  });\n  \n  await action();\n  \n  const endMetrics = await page.evaluate(() => {\n    performance.mark('test-end');\n    performance.measure('test-duration', 'test-start', 'test-end');\n    \n    const measure = performance.getEntriesByName('test-duration')[0];\n    return {\n      duration: measure.duration,\n      end: performance.now()\n    };\n  });\n  \n  return endMetrics;\n}\n\n// Visual regression test helper\nasync function compareScreenshot(page: Page, name: string, options: any = {}) {\n  const screenshot = await page.screenshot({\n    fullPage: false,\n    clip: { x: 0, y: 0, width: page.viewportSize()!.width, height: page.viewportSize()!.height },\n    ...options\n  });\n  \n  expect(screenshot).toMatchSnapshot(`desktop-${name}.png`);\n}\n\ntest.describe('Desktop Chart Components - Comprehensive Test Suite', () => {\n  \n  test.describe('Viewport Matrix Tests', () => {\n    for (const viewport of DESKTOP_VIEWPORTS) {\n      test.describe(`${viewport.name} (${viewport.width}x${viewport.height})`, () => {\n        \n        test.beforeEach(async ({ page }) => {\n          await page.setViewportSize({ width: viewport.width, height: viewport.height });\n        });\n\n        test('GraphBase foundation renders correctly', async ({ page }) => {\n          await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n          \n          // Check basic structure\n          const chartContainer = page.locator('.chart-component');\n          await expect(chartContainer).toBeVisible();\n          \n          // Check title rendering\n          const title = page.locator('h2', { hasText: 'Test Line Chart' });\n          await expect(title).toBeVisible();\n          \n          // Check time controls\n          const timeControls = page.locator('[role=\"tablist\"]');\n          await expect(timeControls).toBeVisible();\n          \n          // Verify Apple typography is applied\n          const titleStyles = await title.evaluate(el => getComputedStyle(el));\n          expect(titleStyles.fontFamily).toContain('SF Pro');\n          \n          // Take screenshot for visual regression\n          await compareScreenshot(page, `graphbase-${viewport.name.toLowerCase().replace(' ', '-')}`);\n        });\n\n        test('LineChart renders with proper styling', async ({ page }) => {\n          await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n          \n          // Wait for SVG elements to render\n          await page.waitForSelector('svg .recharts-line', { timeout: 5000 });\n          \n          // Check line elements\n          const lines = page.locator('svg .recharts-line');\n          const lineCount = await lines.count();\n          expect(lineCount).toBeGreaterThan(0);\n          \n          // Check stroke properties\n          const firstLine = lines.first();\n          const strokeWidth = await firstLine.evaluate(el => getComputedStyle(el).strokeWidth);\n          expect(parseInt(strokeWidth)).toBeGreaterThan(0);\n          \n          // Visual regression test\n          await compareScreenshot(page, `linechart-${viewport.name.toLowerCase().replace(' ', '-')}`);\n        });\n\n        test('AreaChart gradient rendering', async ({ page }) => {\n          await createChartTestPage(page, 'area', CHART_TEST_DATA.lineChart);\n          \n          // Wait for area elements\n          await page.waitForSelector('svg .recharts-area', { timeout: 5000 });\n          \n          // Check area elements\n          const areas = page.locator('svg .recharts-area');\n          const areaCount = await areas.count();\n          expect(areaCount).toBeGreaterThan(0);\n          \n          // Check fill opacity\n          const firstArea = areas.first();\n          const fillOpacity = await firstArea.evaluate(el => getComputedStyle(el).fillOpacity);\n          expect(parseFloat(fillOpacity)).toBeGreaterThan(0);\n          expect(parseFloat(fillOpacity)).toBeLessThanOrEqual(1);\n          \n          // Visual regression test\n          await compareScreenshot(page, `areachart-${viewport.name.toLowerCase().replace(' ', '-')}`);\n        });\n\n        test('StackedBarChart category interactions', async ({ page }) => {\n          await createChartTestPage(page, 'stackedBar', CHART_TEST_DATA.lineChart);\n          \n          // Wait for bar elements\n          await page.waitForSelector('svg .recharts-bar', { timeout: 5000 });\n          \n          // Check bar elements\n          const bars = page.locator('svg .recharts-bar');\n          const barCount = await bars.count();\n          expect(barCount).toBeGreaterThan(0);\n          \n          // Test hover interaction\n          const firstBar = bars.first();\n          await firstBar.hover();\n          \n          // Check for tooltip appearance\n          const tooltip = page.locator('.recharts-tooltip-wrapper');\n          await expect(tooltip).toBeVisible({ timeout: 2000 });\n          \n          // Visual regression test\n          await compareScreenshot(page, `stackedbarchart-${viewport.name.toLowerCase().replace(' ', '-')}`);\n        });\n\n        test('TimeRangeToggle selection behavior', async ({ page }) => {\n          await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n          \n          // Find time range buttons\n          const timeButtons = page.locator('[role=\"tab\"]');\n          await expect(timeButtons.first()).toBeVisible();\n          \n          // Test each time range option\n          const buttonCount = await timeButtons.count();\n          expect(buttonCount).toBeGreaterThanOrEqual(6); // Should have at least 6 options\n          \n          // Test button selection\n          const threeMonthButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n          await threeMonthButton.click();\n          \n          // Check aria-selected attribute\n          const isSelected = await threeMonthButton.getAttribute('aria-selected');\n          expect(isSelected).toBe('true');\n          \n          // Visual state should change\n          const buttonClasses = await threeMonthButton.getAttribute('class');\n          expect(buttonClasses).toContain('bg-white/15');\n        });\n      });\n    }\n  });\n\n  test.describe('Desktop-Specific Features', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 }); // Use Full HD for feature tests\n    });\n\n    test('Hover interactions and tooltips', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Wait for chart to be ready\n      await page.waitForSelector('svg .recharts-line', { timeout: 5000 });\n      \n      // Test hover on data points\n      const chartArea = page.locator('.recharts-wrapper');\n      \n      // Hover over the chart area\n      await chartArea.hover({ position: { x: 200, y: 200 } });\n      \n      // Check for tooltip\n      const tooltip = page.locator('.recharts-tooltip-wrapper');\n      await expect(tooltip).toBeVisible({ timeout: 3000 });\n      \n      // Check tooltip content\n      const tooltipContent = page.locator('.recharts-tooltip-wrapper .recharts-default-tooltip');\n      await expect(tooltipContent).toBeVisible();\n      \n      // Move mouse away and tooltip should disappear\n      await page.mouse.move(50, 50);\n      await expect(tooltip).not.toBeVisible({ timeout: 2000 });\n    });\n\n    test('Keyboard navigation flows', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Focus on the chart component\n      const chartContainer = page.locator('.chart-component');\n      await chartContainer.focus();\n      \n      // Test Tab navigation through time controls\n      await page.keyboard.press('Tab');\n      const focusedElement = page.locator(':focus');\n      \n      // Should focus on first time control button\n      const firstTimeButton = page.locator('[role=\"tab\"]').first();\n      await expect(firstTimeButton).toBeFocused();\n      \n      // Test arrow key navigation\n      await page.keyboard.press('ArrowRight');\n      const secondTimeButton = page.locator('[role=\"tab\"]').nth(1);\n      await expect(secondTimeButton).toBeFocused();\n      \n      // Test Enter key activation\n      await page.keyboard.press('Enter');\n      const isSelected = await secondTimeButton.getAttribute('aria-selected');\n      expect(isSelected).toBe('true');\n      \n      // Test Alt+T for data table toggle\n      await chartContainer.focus();\n      await page.keyboard.press('Alt+KeyT');\n      \n      // Check for data table appearance\n      const dataTable = page.locator('.chart-data-table');\n      await expect(dataTable).toBeVisible({ timeout: 2000 });\n    });\n\n    test('Multi-chart coordination with global time range', async ({ page }) => {\n      // Create two charts with global time range\n      await page.goto('/');\n      \n      await page.evaluate(() => {\n        // Create container for multiple charts\n        const container = document.createElement('div');\n        container.id = 'multi-chart-container';\n        container.style.cssText = `\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100vw;\n          height: 100vh;\n          z-index: 9999;\n          background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);\n          padding: 2rem;\n          display: grid;\n          grid-template-columns: 1fr 1fr;\n          gap: 2rem;\n          box-sizing: border-box;\n        `;\n        \n        document.body.appendChild(container);\n        \n        // Create React component script for multiple charts\n        const script = document.createElement('script');\n        script.type = 'module';\n        script.textContent = `\n          import React, { useState } from 'react';\n          import { createRoot } from 'react-dom/client';\n          import { GraphBase } from '/src/components/charts/index.ts';\n          \n          const MultiChartDemo = () => {\n            const [globalTimeRange, setGlobalTimeRange] = useState('1M');\n            \n            const data = ${JSON.stringify(CHART_TEST_DATA.lineChart)};\n            \n            return React.createElement('div', { style: { display: 'contents' } }, [\n              React.createElement(GraphBase, {\n                key: 'chart1',\n                type: 'line',\n                data: data,\n                title: 'Chart 1',\n                timeRange: globalTimeRange,\n                onTimeRangeChange: setGlobalTimeRange,\n                timeControls: {\n                  show: true,\n                  options: ['1W', '1M', '3M', '6M', '1Y', 'ALL'],\n                  defaultRange: '1M'\n                },\n                dimensions: { height: 300, responsive: true }\n              }),\n              React.createElement(GraphBase, {\n                key: 'chart2',\n                type: 'area',\n                data: data,\n                title: 'Chart 2',\n                timeRange: globalTimeRange,\n                onTimeRangeChange: setGlobalTimeRange,\n                timeControls: {\n                  show: true,\n                  options: ['1W', '1M', '3M', '6M', '1Y', 'ALL'],\n                  defaultRange: '1M'\n                },\n                dimensions: { height: 300, responsive: true }\n              })\n            ]);\n          };\n          \n          const root = createRoot(document.getElementById('multi-chart-container'));\n          root.render(React.createElement(MultiChartDemo));\n        `;\n        \n        document.head.appendChild(script);\n      });\n      \n      // Wait for both charts to render\n      await page.waitForSelector('.chart-component', { timeout: 10000 });\n      const charts = page.locator('.chart-component');\n      await expect(charts).toHaveCount(2);\n      \n      // Change time range on first chart\n      const firstChart = charts.first();\n      const firstChartTimeButton = firstChart.locator('[role=\"tab\"]', { hasText: '3M' });\n      await firstChartTimeButton.click();\n      \n      // Verify both charts update\n      const allTimeButtons = page.locator('[role=\"tab\"][aria-selected=\"true\"]', { hasText: '3M' });\n      await expect(allTimeButtons).toHaveCount(2);\n    });\n\n    test('High-resolution rendering quality', async ({ page }) => {\n      await page.setViewportSize({ width: 2560, height: 1440 }); // QHD resolution\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Check SVG scaling\n      const svg = page.locator('svg').first();\n      const svgBox = await svg.boundingBox();\n      \n      expect(svgBox!.width).toBeGreaterThan(800); // Should scale well on high-res\n      \n      // Check text readability\n      const axisLabels = page.locator('svg text');\n      const labelCount = await axisLabels.count();\n      expect(labelCount).toBeGreaterThan(0);\n      \n      // Check font sizes are appropriate for high-res\n      const firstLabel = axisLabels.first();\n      const fontSize = await firstLabel.evaluate(el => getComputedStyle(el).fontSize);\n      expect(parseInt(fontSize)).toBeGreaterThanOrEqual(10);\n      \n      // Visual regression test for high-res\n      await compareScreenshot(page, 'high-resolution-quality', { \n        threshold: 0.3 // Allow slight variations in high-res rendering\n      });\n    });\n  });\n\n  test.describe('Apple UX Validation', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1440, height: 900 }); // MacBook Air viewport\n    });\n\n    test('Color accuracy (Apple system colors)', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Check background gradient\n      const chartContainer = page.locator('.chart-component');\n      const backgroundStyle = await chartContainer.evaluate(el => getComputedStyle(el).background);\n      \n      // Should contain blue/purple gradient colors\n      expect(backgroundStyle).toMatch(/(rgb\\(30, 58, 138\\)|rgb\\(55, 48, 163\\)|rgb\\(88, 28, 135\\))/);\n      \n      // Check text colors\n      const title = page.locator('h2');\n      const titleColor = await title.evaluate(el => getComputedStyle(el).color);\n      \n      // Should be white or close to white for contrast\n      expect(titleColor).toMatch(/rgb\\(255, 255, 255\\)|rgba\\(255, 255, 255/);\n      \n      // Check chart line colors\n      const chartLine = page.locator('svg .recharts-line path').first();\n      const strokeColor = await chartLine.evaluate(el => getComputedStyle(el).stroke);\n      \n      // Should use defined color palette\n      expect(strokeColor).toMatch(/rgb\\(|rgba\\(|#[0-9a-fA-F]{6}/);\n    });\n\n    test('Typography rendering (SF Pro fallbacks)', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Check title font\n      const title = page.locator('h2');\n      const titleFont = await title.evaluate(el => getComputedStyle(el).fontFamily);\n      \n      // Should include SF Pro in font stack\n      expect(titleFont).toContain('SF Pro');\n      \n      // Check axis labels\n      const axisLabels = page.locator('svg text');\n      if (await axisLabels.count() > 0) {\n        const labelFont = await axisLabels.first().evaluate(el => getComputedStyle(el).fontFamily);\n        expect(labelFont).toContain('SF Pro');\n      }\n      \n      // Check font weights\n      const titleWeight = await title.evaluate(el => getComputedStyle(el).fontWeight);\n      expect(parseInt(titleWeight)).toBeGreaterThanOrEqual(600); // Should be semibold or bold\n    });\n\n    test('Animation smoothness and timing', async ({ page }) => {\n      // Enable performance monitoring\n      await page.addInitScript(() => {\n        window.animationFrames = [];\n        const originalRAF = window.requestAnimationFrame;\n        window.requestAnimationFrame = function(callback) {\n          window.animationFrames.push(Date.now());\n          return originalRAF(callback);\n        };\n      });\n      \n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart, {\n        animation: { enable: true, duration: 800 }\n      });\n      \n      // Wait for initial animation to complete\n      await page.waitForTimeout(1000);\n      \n      // Trigger animation by changing time range\n      const timeButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n      await timeButton.click();\n      \n      // Wait for animation to complete\n      await page.waitForTimeout(1000);\n      \n      // Check animation frame rate\n      const frameData = await page.evaluate(() => window.animationFrames);\n      \n      if (frameData && frameData.length > 10) {\n        // Calculate frame rate\n        const totalTime = frameData[frameData.length - 1] - frameData[0];\n        const avgFrameTime = totalTime / frameData.length;\n        const fps = 1000 / avgFrameTime;\n        \n        // Should maintain reasonable frame rate (at least 30fps)\n        expect(fps).toBeGreaterThan(30);\n      }\n    });\n\n    test('Responsive behavior between 1280-1440px', async ({ page }) => {\n      // Test at 1280px\n      await page.setViewportSize({ width: 1280, height: 720 });\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      let chartBox = await page.locator('.chart-component').boundingBox();\n      const smallWidth = chartBox!.width;\n      \n      // Test at 1440px\n      await page.setViewportSize({ width: 1440, height: 900 });\n      await page.waitForTimeout(500); // Allow resize\n      \n      chartBox = await page.locator('.chart-component').boundingBox();\n      const largeWidth = chartBox!.width;\n      \n      // Chart should scale responsively\n      expect(largeWidth).toBeGreaterThan(smallWidth);\n      \n      // Elements should remain proportional\n      const title = page.locator('h2');\n      const titleSize = await title.evaluate(el => getComputedStyle(el).fontSize);\n      expect(parseInt(titleSize)).toBeGreaterThanOrEqual(16);\n    });\n\n    test('Focus states and accessibility', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Test chart container focus\n      const chartContainer = page.locator('.chart-component');\n      await chartContainer.focus();\n      \n      // Check focus outline\n      const focusOutline = await chartContainer.evaluate(el => getComputedStyle(el).outline);\n      // Should have some focus indication (outline or box-shadow)\n      const hasFocusStyle = focusOutline !== 'none' || \n        await chartContainer.evaluate(el => getComputedStyle(el).boxShadow !== 'none');\n      expect(hasFocusStyle).toBeTruthy();\n      \n      // Test time control focus\n      const timeButton = page.locator('[role=\"tab\"]').first();\n      await timeButton.focus();\n      \n      // Check focus ring\n      const buttonFocusStyle = await timeButton.evaluate(el => getComputedStyle(el).boxShadow);\n      expect(buttonFocusStyle).toContain('rgb(59, 130, 246)'); // Should have blue focus ring\n    });\n  });\n\n  test.describe('Financial Data Accuracy', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('Currency formatting precision', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Hover to show tooltip with currency values\n      const chartArea = page.locator('.recharts-wrapper');\n      await chartArea.hover({ position: { x: 200, y: 200 } });\n      \n      // Check tooltip content\n      const tooltip = page.locator('.recharts-tooltip-wrapper');\n      await expect(tooltip).toBeVisible({ timeout: 3000 });\n      \n      const tooltipText = await tooltip.textContent();\n      \n      // Should format currency correctly\n      expect(tooltipText).toMatch(/\\$[\\d,]+/); // Should have dollar sign and comma formatting\n      \n      // Check data table for currency formatting\n      await page.keyboard.press('Alt+KeyT');\n      const dataTable = page.locator('.chart-data-table');\n      await expect(dataTable).toBeVisible();\n      \n      const tableCells = page.locator('.chart-data-table td');\n      const cellCount = await tableCells.count();\n      \n      if (cellCount > 0) {\n        const firstCellText = await tableCells.first().textContent();\n        expect(firstCellText).toMatch(/\\$[\\d,]+/);\n      }\n    });\n\n    test('Large number handling ($500K+)', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.largeNumbers);\n      \n      // Wait for chart to render\n      await page.waitForSelector('svg', { timeout: 5000 });\n      \n      // Check Y-axis labels for large number formatting\n      const yAxisLabels = page.locator('svg .recharts-yAxis .recharts-text');\n      const labelCount = await yAxisLabels.count();\n      \n      if (labelCount > 0) {\n        const labelText = await yAxisLabels.first().textContent();\n        // Should handle large numbers appropriately (K, M notation or comma separation)\n        expect(labelText).toMatch(/[\\d,]+[KM]?|\\$[\\d,]+/);\n      }\n      \n      // Test tooltip with large numbers\n      const chartArea = page.locator('.recharts-wrapper');\n      await chartArea.hover({ position: { x: 300, y: 200 } });\n      \n      const tooltip = page.locator('.recharts-tooltip-wrapper');\n      await expect(tooltip).toBeVisible({ timeout: 3000 });\n      \n      const tooltipText = await tooltip.textContent();\n      \n      // Should format large numbers correctly\n      expect(tooltipText).toMatch(/\\$[\\d,]+/);\n      expect(tooltipText).toMatch(/[5-9]\\d{2},\\d{3}|1,\\d{3},\\d{3}/); // Should show 500K+ range\n    });\n\n    test('Percentage calculations', async ({ page }) => {\n      const percentageData = [\n        { date: '2024-01-01', growth: 5.5, allocation: 45.2, performance: 12.8 },\n        { date: '2024-02-01', growth: 3.2, allocation: 47.1, performance: 8.9 },\n        { date: '2024-03-01', growth: -2.1, allocation: 42.8, performance: -5.2 },\n        { date: '2024-04-01', growth: 8.7, allocation: 49.3, performance: 15.6 }\n      ];\n      \n      await createChartTestPage(page, 'line', percentageData);\n      \n      // Test tooltip percentage formatting\n      const chartArea = page.locator('.recharts-wrapper');\n      await chartArea.hover({ position: { x: 250, y: 200 } });\n      \n      const tooltip = page.locator('.recharts-tooltip-wrapper');\n      await expect(tooltip).toBeVisible({ timeout: 3000 });\n      \n      const tooltipText = await tooltip.textContent();\n      \n      // Should show percentage values with % symbol\n      expect(tooltipText).toMatch(/\\d+\\.?\\d*%/);\n      \n      // Should handle negative percentages\n      expect(tooltipText).toMatch(/-?\\d+\\.?\\d*%/);\n    });\n\n    test('Time-based data filtering', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Test different time ranges\n      const timeRanges = ['1M', '3M', '6M'];\n      \n      for (const range of timeRanges) {\n        const timeButton = page.locator('[role=\"tab\"]', { hasText: range });\n        await timeButton.click();\n        \n        // Wait for chart to update\n        await page.waitForTimeout(500);\n        \n        // Check that chart still renders\n        const chartSvg = page.locator('svg');\n        await expect(chartSvg).toBeVisible();\n        \n        // Check that data points are still present\n        const dataPoints = page.locator('svg .recharts-line');\n        await expect(dataPoints.first()).toBeVisible();\n      }\n    });\n\n    test('Chart data synchronization', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Change time range and verify data consistency\n      const sixMonthButton = page.locator('[role=\"tab\"]', { hasText: '6M' });\n      await sixMonthButton.click();\n      \n      // Wait for update\n      await page.waitForTimeout(500);\n      \n      // Check tooltip data consistency\n      const chartArea = page.locator('.recharts-wrapper');\n      await chartArea.hover({ position: { x: 200, y: 200 } });\n      \n      const tooltip = page.locator('.recharts-tooltip-wrapper');\n      await expect(tooltip).toBeVisible({ timeout: 3000 });\n      \n      // Move to different position and check another data point\n      await chartArea.hover({ position: { x: 400, y: 200 } });\n      await page.waitForTimeout(200);\n      \n      // Tooltip should still be visible with different data\n      await expect(tooltip).toBeVisible();\n      \n      // Check data table consistency\n      await page.keyboard.press('Alt+KeyT');\n      const dataTable = page.locator('.chart-data-table');\n      await expect(dataTable).toBeVisible();\n      \n      // Should have the same number of rows as original data\n      const tableRows = page.locator('.chart-data-table tbody tr');\n      const rowCount = await tableRows.count();\n      expect(rowCount).toBe(CHART_TEST_DATA.lineChart.length);\n    });\n  });\n\n  test.describe('Performance and Accessibility', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('60fps animations and load times', async ({ page }) => {\n      const startTime = Date.now();\n      \n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart, {\n        animation: { enable: true, duration: 1000 }\n      });\n      \n      const loadTime = Date.now() - startTime;\n      \n      // Should load within reasonable time\n      expect(loadTime).toBeLessThan(5000); // 5 seconds max\n      \n      // Test animation performance\n      const performanceMetrics = await measurePerformance(page, async () => {\n        // Trigger animation by changing time range\n        const timeButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n        await timeButton.click();\n        await page.waitForTimeout(1100); // Wait for animation to complete\n      });\n      \n      // Animation should complete within expected time\n      expect(performanceMetrics.duration).toBeLessThan(1500); // Allow some overhead\n    });\n\n    test('ARIA attributes and screen reader support', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Check main chart ARIA attributes\n      const chartContainer = page.locator('.chart-component');\n      \n      const ariaLabel = await chartContainer.getAttribute('aria-label');\n      expect(ariaLabel).toBeTruthy();\n      expect(ariaLabel).toContain('chart');\n      \n      const role = await chartContainer.getAttribute('role');\n      expect(role).toBe('img');\n      \n      // Check time controls ARIA\n      const timeControls = page.locator('[role=\"tablist\"]');\n      await expect(timeControls).toBeVisible();\n      \n      const ariaLabelControls = await timeControls.getAttribute('aria-label');\n      expect(ariaLabelControls).toContain('Time range');\n      \n      // Check individual time buttons\n      const timeButtons = page.locator('[role=\"tab\"]');\n      const buttonCount = await timeButtons.count();\n      \n      for (let i = 0; i < Math.min(buttonCount, 3); i++) {\n        const button = timeButtons.nth(i);\n        const ariaSelected = await button.getAttribute('aria-selected');\n        expect(ariaSelected).toMatch(/true|false/);\n      }\n      \n      // Check data table accessibility\n      await page.keyboard.press('Alt+KeyT');\n      const dataTable = page.locator('.chart-data-table');\n      await expect(dataTable).toBeVisible();\n      \n      const tableRole = await dataTable.getAttribute('role');\n      expect(tableRole).toBe('table');\n      \n      const tableCaption = page.locator('.chart-data-table caption');\n      await expect(tableCaption).toBeVisible();\n      \n      // Check live region\n      const liveRegion = page.locator('[aria-live=\"polite\"]');\n      await expect(liveRegion).toBeAttached();\n    });\n\n    test('Focus order and keyboard navigation', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Start from chart container\n      const chartContainer = page.locator('.chart-component');\n      await chartContainer.focus();\n      \n      // Tab through focusable elements\n      const focusableElements = [];\n      \n      // Chart should be focusable\n      let currentFocus = page.locator(':focus');\n      let focusedElement = await currentFocus.getAttribute('class');\n      focusableElements.push(focusedElement);\n      \n      // Tab to time controls\n      await page.keyboard.press('Tab');\n      currentFocus = page.locator(':focus');\n      \n      // Should focus on first time control\n      const isTimeControl = await currentFocus.getAttribute('role');\n      expect(isTimeControl).toBe('tab');\n      \n      // Arrow key navigation within time controls\n      await page.keyboard.press('ArrowRight');\n      const nextTimeControl = page.locator(':focus');\n      const nextIsTimeControl = await nextTimeControl.getAttribute('role');\n      expect(nextIsTimeControl).toBe('tab');\n      \n      // Tab order should be logical\n      expect(focusableElements.length).toBeGreaterThan(0);\n    });\n\n    test('High contrast and reduced motion support', async ({ page }) => {\n      // Test with reduced motion preference\n      await page.emulateMedia({ reducedMotion: 'reduce' });\n      \n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart, {\n        accessibility: { reducedMotion: true }\n      });\n      \n      // Should still render chart\n      const chartSvg = page.locator('svg');\n      await expect(chartSvg).toBeVisible();\n      \n      // Test time range change with reduced motion\n      const timeButton = page.locator('[role=\"tab\"]', { hasText: '3M' });\n      await timeButton.click();\n      \n      // Should still update but without animation delay\n      await page.waitForTimeout(100); // Minimal wait\n      \n      const isSelected = await timeButton.getAttribute('aria-selected');\n      expect(isSelected).toBe('true');\n      \n      // Test high contrast mode\n      await page.emulateMedia({ colorScheme: 'dark' });\n      \n      // Check contrast ratios\n      const title = page.locator('h2');\n      const titleColor = await title.evaluate(el => getComputedStyle(el).color);\n      const backgroundColor = await title.evaluate(el => getComputedStyle(el).backgroundColor);\n      \n      // In high contrast mode, should have sufficient contrast\n      expect(titleColor).toMatch(/rgb\\(255, 255, 255\\)|rgba\\(255, 255, 255/);\n    });\n  });\n\n  test.describe('Visual Regression Tests', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('Chart component visual consistency', async ({ page }) => {\n      // Test all chart types for visual consistency\n      const chartTypes = ['line', 'area', 'bar', 'stackedBar'];\n      \n      for (const chartType of chartTypes) {\n        await createChartTestPage(page, chartType, CHART_TEST_DATA.lineChart);\n        \n        // Wait for rendering\n        await page.waitForTimeout(1000);\n        \n        // Take screenshot\n        await compareScreenshot(page, `${chartType}-visual-consistency`, {\n          threshold: 0.2,\n          maxDiffPixels: 1000\n        });\n      }\n    });\n\n    test('Theme and color scheme consistency', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Test light theme\n      await page.emulateMedia({ colorScheme: 'light' });\n      await page.waitForTimeout(500);\n      await compareScreenshot(page, 'light-theme-consistency');\n      \n      // Test dark theme\n      await page.emulateMedia({ colorScheme: 'dark' });\n      await page.waitForTimeout(500);\n      await compareScreenshot(page, 'dark-theme-consistency');\n    });\n\n    test('Responsive layout visual regression', async ({ page }) => {\n      await createChartTestPage(page, 'line', CHART_TEST_DATA.lineChart);\n      \n      // Test different desktop sizes\n      const sizes = [\n        { width: 1280, height: 720, name: 'desktop-small' },\n        { width: 1920, height: 1080, name: 'desktop-large' },\n        { width: 2560, height: 1440, name: 'desktop-xl' }\n      ];\n      \n      for (const size of sizes) {\n        await page.setViewportSize(size);\n        await page.waitForTimeout(500);\n        await compareScreenshot(page, `responsive-${size.name}`, {\n          fullPage: false,\n          clip: { x: 0, y: 0, width: size.width, height: size.height }\n        });\n      }\n    });\n  });\n\n  test.describe('Error Handling and Edge Cases', () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: 1920, height: 1080 });\n    });\n\n    test('Empty data state', async ({ page }) => {\n      await createChartTestPage(page, 'line', []);\n      \n      // Should show empty state\n      const emptyState = page.locator('text=No data available');\n      await expect(emptyState).toBeVisible();\n      \n      // Should not show chart SVG\n      const chartSvg = page.locator('svg .recharts-line');\n      await expect(chartSvg).not.toBeVisible();\n      \n      // Time controls should still be visible but disabled\n      const timeControls = page.locator('[role=\"tablist\"]');\n      await expect(timeControls).toBeVisible();\n    });\n\n    test('Loading state', async ({ page }) => {\n      await page.goto('/');\n      \n      // Create loading state\n      await page.evaluate(() => {\n        const container = document.createElement('div');\n        container.id = 'loading-test-container';\n        container.style.cssText = `\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100vw;\n          height: 100vh;\n          z-index: 9999;\n          background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);\n          padding: 2rem;\n        `;\n        \n        document.body.appendChild(container);\n        \n        const script = document.createElement('script');\n        script.type = 'module';\n        script.textContent = `\n          import React from 'react';\n          import { createRoot } from 'react-dom/client';\n          import { GraphBase } from '/src/components/charts/index.ts';\n          \n          const LoadingChart = () => {\n            return React.createElement(GraphBase, {\n              type: 'line',\n              data: [],\n              loading: true,\n              title: 'Loading Chart Test',\n              dimensions: { height: 400, responsive: true }\n            });\n          };\n          \n          const root = createRoot(document.getElementById('loading-test-container'));\n          root.render(React.createElement(LoadingChart));\n        `;\n        \n        document.head.appendChild(script);\n      });\n      \n      // Should show loading skeleton\n      const skeleton = page.locator('.animate-pulse');\n      await expect(skeleton).toBeVisible();\n      \n      // Should show skeleton bars\n      const skeletonBars = page.locator('.bg-white\\\\/10');\n      await expect(skeletonBars.first()).toBeVisible();\n    });\n\n    test('Error state', async ({ page }) => {\n      await page.goto('/');\n      \n      // Create error state\n      await page.evaluate(() => {\n        const container = document.createElement('div');\n        container.id = 'error-test-container';\n        container.style.cssText = `\n          position: fixed;\n          top: 0;\n          left: 0;\n          width: 100vw;\n          height: 100vh;\n          z-index: 9999;\n          background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 50%, #581c87 100%);\n          padding: 2rem;\n        `;\n        \n        document.body.appendChild(container);\n        \n        const script = document.createElement('script');\n        script.type = 'module';\n        script.textContent = `\n          import React from 'react';\n          import { createRoot } from 'react-dom/client';\n          import { GraphBase } from '/src/components/charts/index.ts';\n          \n          const ErrorChart = () => {\n            return React.createElement(GraphBase, {\n              type: 'line',\n              data: [],\n              error: 'Failed to load chart data',\n              title: 'Error Chart Test',\n              dimensions: { height: 400, responsive: true },\n              errorConfig: {\n                showRetry: true,\n                retryText: 'Try Again'\n              }\n            });\n          };\n          \n          const root = createRoot(document.getElementById('error-test-container'));\n          root.render(React.createElement(ErrorChart));\n        `;\n        \n        document.head.appendChild(script);\n      });\n      \n      // Should show error message\n      const errorMessage = page.locator('text=Unable to load chart');\n      await expect(errorMessage).toBeVisible();\n      \n      // Should show retry button\n      const retryButton = page.locator('button', { hasText: 'Try Again' });\n      await expect(retryButton).toBeVisible();\n      \n      // Test retry button click\n      await retryButton.click();\n      // In a real scenario, this would trigger a retry\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/desktop-responsive-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/feature-cloud-debug.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/feature-cloud-navigation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/feature-cloud-quick-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/final-analytics-verification.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":22,"column":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('ðŸ›¡ï¸ Final Analytics Bulletproof Verification', () => {\n  const DESTRUCTURING_ERROR_PATTERNS = [\n    'Right side of assignment cannot be destructured',\n    'Cannot read property',\n    'Cannot read properties of undefined',\n    'Cannot read properties of null',\n    'TypeError: Cannot destructure',\n    'undefined is not an object',\n    'null is not an object',\n    'Cannot access before initialization'\n  ];\n\n  test.beforeEach(async ({ page }) => {\n    // Navigate to the homepage first\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('âœ… Analytics tab loads without destructuring crashes', async ({ page }) => {\n    const consoleErrors: string[] = [];\n    const jsErrors: string[] = [];\n    \n    // Capture all console errors\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        consoleErrors.push(msg.text());\n      }\n    });\n    \n    // Capture JavaScript errors\n    page.on('pageerror', error => {\n      jsErrors.push(error.message);\n    });\n\n    // Navigate directly to analytics tab\n    await page.goto('/?tab=analytics');\n    \n    // Wait for analytics dashboard to load\n    await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n    \n    // Wait for charts to render\n    await page.waitForTimeout(3000);\n    \n    // Verify dashboard content is visible\n    await expect(page.locator('h1:has-text(\"Financial Analytics Dashboard\")')).toBeVisible();\n    \n    // Verify at least one chart is rendered\n    const chartCount = await page.locator('.recharts-wrapper').count();\n    expect(chartCount).toBeGreaterThan(0);\n    \n    // Check for any destructuring-specific errors\n    const allErrors = [...consoleErrors, ...jsErrors];\n    const destructuringErrors = allErrors.filter(error =>\n      DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n        error.toLowerCase().includes(pattern.toLowerCase())\n      )\n    );\n\n    // âœ… ZERO TOLERANCE for destructuring errors\n    if (destructuringErrors.length > 0) {\n      console.log('Found destructuring errors:', destructuringErrors);\n    }\n    expect(destructuringErrors).toHaveLength(0);\n    \n    // Log success\n    console.log('âœ… Analytics tab loaded successfully without destructuring crashes');\n    console.log(`ðŸ“Š Charts rendered: ${chartCount}`);\n    console.log(`ðŸš« Total errors found: ${allErrors.length}`);\n    console.log(`ðŸ›¡ï¸ Destructuring errors: ${destructuringErrors.length}`);\n  });\n\n  test('âœ… Chart switching works without crashes', async ({ page }) => {\n    const errors: string[] = [];\n    \n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        errors.push(msg.text());\n      }\n    });\n    \n    page.on('pageerror', error => {\n      errors.push(error.message);\n    });\n\n    // Navigate to analytics\n    await page.goto('/?tab=analytics');\n    await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n    \n    // Test switching between different chart types\n    const chartTypes = ['Net Worth', 'Cash Flow', 'Spending', 'Portfolio'];\n    \n    for (const chartType of chartTypes) {\n      console.log(`Testing chart: ${chartType}`);\n      \n      // Click the chart type button\n      await page.click(`button:has-text(\"${chartType}\")`);\n      \n      // Wait for chart to render\n      await page.waitForTimeout(1000);\n      \n      // Verify chart is still visible\n      const chartExists = await page.locator('.recharts-wrapper').count() > 0;\n      expect(chartExists).toBe(true);\n    }\n    \n    // Check for destructuring errors during chart switching\n    const destructuringErrors = errors.filter(error =>\n      DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n        error.toLowerCase().includes(pattern.toLowerCase())\n      )\n    );\n    \n    expect(destructuringErrors).toHaveLength(0);\n    console.log('âœ… Chart switching completed without errors');\n  });\n\n  test('âœ… Timeframe changes work without crashes', async ({ page }) => {\n    const errors: string[] = [];\n    \n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        errors.push(msg.text());\n      }\n    });\n    \n    page.on('pageerror', error => {\n      errors.push(error.message);\n    });\n\n    // Navigate to analytics\n    await page.goto('/?tab=analytics');\n    await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n    \n    // Test different timeframes\n    const timeframes = ['1M', '3M', '6M', '1Y'];\n    \n    for (const timeframe of timeframes) {\n      console.log(`Testing timeframe: ${timeframe}`);\n      \n      // Click the timeframe button\n      await page.click(`button:has-text(\"${timeframe}\")`);\n      \n      // Wait for data to refresh\n      await page.waitForTimeout(1500);\n      \n      // Verify charts are still rendered\n      const chartCount = await page.locator('.recharts-wrapper').count();\n      expect(chartCount).toBeGreaterThan(0);\n    }\n    \n    // Check for destructuring errors during timeframe changes\n    const destructuringErrors = errors.filter(error =>\n      DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n        error.toLowerCase().includes(pattern.toLowerCase())\n      )\n    );\n    \n    expect(destructuringErrors).toHaveLength(0);\n    console.log('âœ… Timeframe changes completed without errors');\n  });\n\n  test('âœ… Rapid navigation stress test', async ({ page }) => {\n    const errors: string[] = [];\n    \n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        errors.push(msg.text());\n      }\n    });\n    \n    page.on('pageerror', error => {\n      errors.push(error.message);\n    });\n\n    // Rapid navigation between different tabs including analytics\n    const tabs = ['dashboard', 'accounts', 'analytics', 'insights', 'budget'];\n    \n    for (let cycle = 0; cycle < 3; cycle++) {\n      for (const tab of tabs) {\n        console.log(`Cycle ${cycle + 1}: Navigating to ${tab}`);\n        \n        await page.goto(`/?tab=${tab}`);\n        \n        if (tab === 'analytics') {\n          await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n          \n          // Verify charts are rendered\n          const chartCount = await page.locator('.recharts-wrapper').count();\n          expect(chartCount).toBeGreaterThan(0);\n        }\n        \n        await page.waitForTimeout(500);\n      }\n    }\n    \n    // Check for destructuring errors during rapid navigation\n    const destructuringErrors = errors.filter(error =>\n      DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n        error.toLowerCase().includes(pattern.toLowerCase())\n      )\n    );\n    \n    expect(destructuringErrors).toHaveLength(0);\n    console.log('âœ… Rapid navigation stress test completed without errors');\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/final-comprehensive-navigation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/financial-calculators.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/financial-planning-comprehensive.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":211,"column":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Financial Planning - Comprehensive Testing', () => {\n  \n  // Test multiple viewport sizes as per UltraThink requirements\n  const viewports = [\n    { name: 'Mobile', width: 375, height: 667 },\n    { name: 'Tablet', width: 768, height: 1024 },\n    { name: 'Desktop', width: 1440, height: 900 }\n  ];\n\n  viewports.forEach(({ name, width, height }) => {\n    test.describe(`${name} (${width}x${height})`, () => {\n      \n      test.beforeEach(async ({ page }) => {\n        await page.setViewportSize({ width, height });\n        await page.goto('http://localhost:5173/');\n        \n        // Navigate to planning page\n        await page.getByRole('button', { name: /planning/i }).click();\n        await page.waitForLoadState('networkidle');\n      });\n\n      test('should load planning page without errors', async ({ page }) => {\n        // Verify page loads\n        await expect(page.locator('h1')).toContainText('Financial Planning');\n        await expect(page.locator('text=Set goals, track progress, and plan for your financial future')).toBeVisible();\n      });\n\n      test('should display all tab navigation options', async ({ page }) => {\n        // Check all tabs are present\n        const tabs = ['Overview', 'Goals', 'Retirement', 'Debt Payoff', 'Life Planning'];\n        \n        for (const tab of tabs) {\n          await expect(page.getByRole('button', { name: tab })).toBeVisible();\n        }\n      });\n\n      test('should navigate between tabs successfully', async ({ page }) => {\n        // Test Overview tab (default)\n        await expect(page.locator('text=Financial Health Score')).toBeVisible();\n        \n        // Test Goals tab\n        await page.getByRole('button', { name: 'Goals' }).click();\n        await page.waitForTimeout(500);\n        await expect(page.locator('text=Emergency Fund')).toBeVisible();\n        \n        // Test Retirement tab\n        await page.getByRole('button', { name: 'Retirement' }).click();\n        await page.waitForTimeout(1000);\n        await expect(page.locator('text=Retirement Planning')).toBeVisible();\n        \n        // Test Debt tab\n        await page.getByRole('button', { name: /Debt/i }).click();\n        await page.waitForTimeout(1000);\n        await expect(page.locator('text=Debt Payoff Strategy')).toBeVisible();\n        \n        // Test Life Planning tab\n        await page.getByRole('button', { name: /Life Planning/i }).click();\n        await page.waitForTimeout(1000);\n        await expect(page.locator('text=Life Event Planning')).toBeVisible();\n      });\n\n      test('should display financial data correctly', async ({ page }) => {\n        // Overview tab financial data\n        await expect(page.locator('text=/\\\\$[0-9,]+/')).toBeVisible();\n        \n        // Goals tab progress\n        await page.getByRole('button', { name: 'Goals' }).click();\n        await page.waitForTimeout(500);\n        await expect(page.locator('text=On Track')).toBeVisible();\n      });\n\n      test('should handle responsive design correctly', async ({ page }) => {\n        // Check if content fits viewport without horizontal scroll\n        const horizontalScrollWidth = await page.evaluate(() => {\n          return document.documentElement.scrollWidth - document.documentElement.clientWidth;\n        });\n        \n        expect(horizontalScrollWidth).toBeLessThanOrEqual(1);\n      });\n\n      test('should display charts and visualizations', async ({ page }) => {\n        // Go to retirement tab which has projections\n        await page.getByRole('button', { name: 'Retirement' }).click();\n        await page.waitForTimeout(2000);\n        \n        // Check for chart elements\n        await expect(page.locator('text=Retirement Savings Projection')).toBeVisible();\n      });\n\n      test('should maintain dark theme consistency', async ({ page }) => {\n        // Check cards use consistent dark styling\n        const cards = page.locator('[class*=\"bg-white/[0.02]\"]');\n        await expect(cards.first()).toBeVisible();\n      });\n    });\n  });\n\n  test.describe('Accessibility Testing', () => {\n    test('should meet basic accessibility requirements', async ({ page }) => {\n      await page.goto('http://localhost:5173/');\n      await page.getByRole('button', { name: /planning/i }).click();\n      \n      // Check for proper heading hierarchy\n      const h1Elements = page.locator('h1');\n      await expect(h1Elements).toHaveCount(1);\n      \n      // Check that interactive elements are keyboard accessible\n      const buttons = page.locator('button');\n      const buttonCount = await buttons.count();\n      expect(buttonCount).toBeGreaterThan(0);\n      \n      // Check for proper contrast (basic check)\n      const headings = page.locator('h1, h2, h3');\n      await expect(headings.first()).toBeVisible();\n    });\n\n    test('should support keyboard navigation', async ({ page }) => {\n      await page.goto('http://localhost:5173/');\n      await page.getByRole('button', { name: /planning/i }).click();\n      \n      // Tab through navigation elements\n      await page.keyboard.press('Tab');\n      await page.keyboard.press('Tab');\n      \n      // Should be able to activate tabs with keyboard\n      await page.keyboard.press('Enter');\n      \n      // Check that focus is visible and logical\n      const focusedElement = page.locator(':focus');\n      await expect(focusedElement).toBeVisible();\n    });\n  });\n\n  test.describe('Data Validation', () => {\n    test('should display consistent currency formatting', async ({ page }) => {\n      await page.goto('http://localhost:5173/');\n      await page.getByRole('button', { name: /planning/i }).click();\n      \n      // Check that all currency amounts follow consistent format\n      const currencyElements = page.locator('text=/\\\\$[0-9,]+/');\n      const currencyCount = await currencyElements.count();\n      \n      expect(currencyCount).toBeGreaterThan(0);\n      \n      // Spot check a few currency formats\n      for (let i = 0; i < Math.min(3, currencyCount); i++) {\n        const currencyText = await currencyElements.nth(i).textContent();\n        expect(currencyText).toMatch(/^\\$[0-9,]+$/);\n      }\n    });\n\n    test('should display realistic financial data', async ({ page }) => {\n      await page.goto('http://localhost:5173/');\n      await page.getByRole('button', { name: /planning/i }).click();\n      \n      // Check retirement tab data\n      await page.getByRole('button', { name: 'Retirement' }).click();\n      await page.waitForTimeout(1000);\n      \n      // Validate data ranges make sense\n      const savingsAmount = page.locator('text=Current Savings').locator('..').locator('text=/\\\\$[0-9,]+/');\n      const savingsText = await savingsAmount.textContent();\n      \n      if (savingsText) {\n        const amount = parseInt(savingsText.replace(/[$,]/g, ''));\n        expect(amount).toBeGreaterThan(1000); // Reasonable savings amount\n        expect(amount).toBeLessThan(10000000); // Not unrealistically high\n      }\n    });\n  });\n});\n\n// Performance-specific tests\ntest.describe('Performance Validation', () => {\n  test('should meet Core Web Vitals targets', async ({ page }) => {\n    await page.goto('http://localhost:5173/');\n    \n    // Navigate to planning which has the most complex UI\n    await page.getByRole('button', { name: /planning/i }).click();\n    \n    // Measure LCP (Largest Contentful Paint) - should be < 2.5s\n    const lcp = await page.evaluate(() => {\n      return new Promise((resolve) => {\n        new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1];\n          resolve(lastEntry.startTime);\n        }).observe({ entryTypes: ['largest-contentful-paint'] });\n        \n        // Fallback timeout\n        setTimeout(() => resolve(0), 3000);\n      });\n    });\n    \n    if (typeof lcp === 'number' && lcp > 0) {\n      expect(lcp).toBeLessThan(2500); // 2.5 seconds\n    }\n    \n    // Check that there are no excessive reflows/repaints\n    await page.getByRole('button', { name: 'Retirement' }).click();\n    await page.waitForTimeout(500);\n    \n    // The page should be stable (no layout shifts after loading)\n    const isStable = await page.evaluate(() => {\n      return new Promise((resolve) => {\n        let cumulativeShift = 0;\n        new PerformanceObserver((list) => {\n          for (const entry of list.getEntries()) {\n            if (entry.entryType === 'layout-shift' && !(entry as any).hadRecentInput) {\n              cumulativeShift += (entry as any).value;\n            }\n          }\n        }).observe({ entryTypes: ['layout-shift'] });\n        \n        setTimeout(() => {\n          resolve(cumulativeShift < 0.1); // CLS should be < 0.1\n        }, 1000);\n      });\n    });\n    \n    expect(isStable).toBe(true);\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/generate-ui-manifest.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":12,"column":44}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { chromium, FullConfig } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\n/**\n * Playwright globalSetup\n * Crawls the application starting at the root route and builds a manifest of all\n * interactive elements (anchor, button, tab, or element with an onclick attr).\n * The resulting JSON is written to the project root as `ui-map.json` and is\n * used by `e2e/all-interactions.spec.ts` to drive exhaustive UI interaction tests.\n */\nexport default async function globalSetup(_: FullConfig) {\n  // Base URL will usually come from the shared `use.baseURL` setting.\n  const baseURL = process.env.BASE_URL || 'http://localhost:5173';\n\n  // Launch a headless Chromium instance for fast crawling.\n  const browser = await chromium.launch();\n  const context = await browser.newContext();\n  const page = await context.newPage();\n\n  // Track where we've been and where we still need to visit â€“ root first.\n  const visited = new Set<string>();\n  const queue: string[] = ['/'];\n\n  type ManifestEntry = {\n    selector: string;\n    type: 'a' | 'button' | 'tab' | 'onclick';\n    originPage: string;\n    expectUrlChange: boolean;\n  };\n  const manifest: ManifestEntry[] = [];\n\n  while (queue.length) {\n    const currentPath = queue.shift() as string;\n    if (visited.has(currentPath)) continue;\n    visited.add(currentPath);\n\n    try {\n      await page.goto(`${baseURL}${currentPath}`, { waitUntil: 'domcontentloaded' });\n    } catch (err) {\n      // If navigation fails, skip this route and continue.\n      /* eslint-disable no-console */\n      console.warn(`[playwright-audit] Failed to load ${currentPath}:`, err);\n      continue;\n    }\n\n    // Grab interactive DOM elements on the page.\n    const entries: ManifestEntry[] = await page.evaluate(() => {\n      function buildSelector(el: Element): string | null {\n        // Prefer id\n        if (el.id) return `#${el.id}`;\n        // Fallback: text content (first 40 characters) for stability with Playwright's text selector.\n        const text = el.textContent?.trim();\n        if (text) return `text=${text.substring(0, 40)}`;\n        return null;\n      }\n\n      const elements = Array.from(document.querySelectorAll('a, button, [role=\"tab\"], [onclick]'));\n      return elements\n        .map((el) => {\n          const tag = el.tagName.toLowerCase();\n          const selector = buildSelector(el);\n          if (!selector) return null;\n\n          let type: ManifestEntry['type'] = tag as ManifestEntry['type'];\n          if (el.getAttribute('role') === 'tab') type = 'tab';\n          if (el.hasAttribute('onclick')) type = 'onclick';\n\n          const hrefAttr = (el as HTMLAnchorElement).getAttribute?.('href');\n          const expectUrlChange = !!hrefAttr && hrefAttr !== '#' && !hrefAttr?.startsWith('javascript:');\n\n          return { selector, type, originPage: window.location.pathname, expectUrlChange } as ManifestEntry;\n        })\n        .filter(Boolean) as ManifestEntry[];\n    });\n\n    // Append to manifest and queue up new routes found via anchors.\n    for (const entry of entries) {\n      manifest.push(entry);\n\n      // If the element is a link to same-origin path, queue it for crawling.\n      const href = (await page.locator(entry.selector).getAttribute('href')) || undefined;\n      if (href && href.startsWith('/') && !visited.has(href) && !queue.includes(href)) {\n        queue.push(href);\n      }\n    }\n  }\n\n  await browser.close();\n\n  // Persist manifest to the repository root so the spec file can import it.\n  const outPath = path.resolve(process.cwd(), 'ui-map.json');\n  fs.writeFileSync(outPath, JSON.stringify(manifest, null, 2));\n  console.log(`ðŸ—ºï¸  UI interaction map generated with ${manifest.length} entries -> ${outPath}`);\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/hook-validation-config.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token page","line":5,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect, Page, Locator } from '@playwright/test';\n\n// Hook violation detection utilities\nexport class HookValidationMonitor {\n  private page: Page;\n  private errors: string[] = [];\n  private hookCounts: Map<string, number> = new Map();\n\n  constructor(page: Page) {\n    this.page = page;\n  }\n\n  // Monitor console for React hook errors\n  async startMonitoring(): Promise<void> {\n    this.page.on('console', (message) => {\n      const text = message.text();\n      if (text.includes('rendered more hooks') || \n          text.includes('hook') && text.includes('error') ||\n          text.includes('useEffect') && text.includes('error') ||\n          text.includes('useState') && text.includes('error')) {\n        this.errors.push(text);\n        console.error('Hook validation error detected:', text);\n      }\n    });\n\n    this.page.on('pageerror', (error) => {\n      if (error.message.includes('hook')) {\n        this.errors.push(error.message);\n        console.error('Page error related to hooks:', error.message);\n      }\n    });\n  }\n\n  // Check for hook violations\n  getErrors(): string[] {\n    return [...this.errors];\n  }\n\n  hasHookViolations(): boolean {\n    return this.errors.length > 0;\n  }\n\n  // Reset monitoring\n  reset(): void {\n    this.errors = [];\n    this.hookCounts.clear();\n  }\n\n  // Get performance metrics\n  async getPerformanceMetrics() {\n    return await this.page.evaluate(() => {\n      const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n      return {\n        loadTime: navigationTiming.loadEventEnd - navigationTiming.loadEventStart,\n        domContentLoaded: navigationTiming.domContentLoadedEventEnd - navigationTiming.domContentLoadedEventStart,\n        firstPaint: performance.getEntriesByType('paint').find(entry => entry.name === 'first-paint')?.startTime || 0,\n        firstContentfulPaint: performance.getEntriesByType('paint').find(entry => entry.name === 'first-contentful-paint')?.startTime || 0\n      };\n    });\n  }\n}\n\n// Navigation test utilities\nexport class NavigationTester {\n  private page: Page;\n  private monitor: HookValidationMonitor;\n\n  constructor(page: Page, monitor: HookValidationMonitor) {\n    this.page = page;\n    this.monitor = monitor;\n  }\n\n  // Test navigation between tabs\n  async navigateToTab(tabName: string): Promise<void> {\n    const tabButton = this.page.locator(`[data-testid=\"nav-${tabName}\"], button:has-text(\"${tabName}\"), a:has-text(\"${tabName}\")`).first();\n    \n    await expect(tabButton).toBeVisible();\n    await tabButton.click();\n    \n    // Wait for navigation to complete\n    await this.page.waitForTimeout(500);\n    \n    // Check for hook violations after navigation\n    if (this.monitor.hasHookViolations()) {\n      throw new Error(`Hook violations detected after navigating to ${tabName}: ${this.monitor.getErrors().join(', ')}`);\n    }\n  }\n\n  // Test rapid navigation\n  async testRapidNavigation(tabs: string[]): Promise<void> {\n    for (const tab of tabs) {\n      await this.navigateToTab(tab);\n      await this.page.waitForTimeout(100); // Brief pause between navigations\n    }\n  }\n\n  // Test URL parameter changes\n  async testUrlParameterNavigation(tab: string): Promise<void> {\n    await this.page.goto(`/?tab=${tab}`);\n    await this.page.waitForLoadState('networkidle');\n    \n    if (this.monitor.hasHookViolations()) {\n      throw new Error(`Hook violations detected with URL parameter navigation to ${tab}: ${this.monitor.getErrors().join(', ')}`);\n    }\n  }\n}\n\n// Component validation utilities\nexport class ComponentValidator {\n  private page: Page;\n\n  constructor(page: Page) {\n    this.page = page;\n  }\n\n  // Validate component is rendered and functional\n  async validateComponent(selector: string, componentName: string): Promise<void> {\n    const component = this.page.locator(selector);\n    await expect(component).toBeVisible({ timeout: 10000 });\n    \n    // Check if component is interactive\n    const isInteractive = await component.isEnabled();\n    if (!isInteractive) {\n      console.warn(`Component ${componentName} is not interactive`);\n    }\n  }\n\n  // Check for React dev tools markers\n  async hasReactComponents(): Promise<boolean> {\n    return await this.page.evaluate(() => {\n      // Check for React fiber nodes or dev tools\n      const hasReactFiber = document.querySelector('[data-reactroot]') !== null;\n      const hasReactDevTools = (window as unknown as { __REACT_DEVTOOLS_GLOBAL_HOOK__?: unknown }).__REACT_DEVTOOLS_GLOBAL_HOOK__ !== undefined;\n      return hasReactFiber || hasReactDevTools;\n    });\n  }\n\n  // Validate specific UI elements exist\n  async validateUIElements(elements: { selector: string; name: string }[]): Promise<void> {\n    for (const element of elements) {\n      await expect(this.page.locator(element.selector)).toBeVisible({ \n        timeout: 5000 \n      });\n    }\n  }\n}\n\n// Memory and performance testing\nexport class PerformanceTester {\n  private page: Page;\n\n  constructor(page: Page) {\n    this.page = page;\n  }\n\n  // Memory pressure test\n  async memoryPressureTest(): Promise<void> {\n    await this.page.evaluate(() => {\n      // Create memory pressure\n      const arrays = [];\n      for (let i = 0; i < 100; i++) {\n        arrays.push(new Array(10000).fill(Math.random()));\n      }\n      \n      // Force garbage collection if available\n      const windowWithGC = window as unknown as { gc?: () => void };\n      if (windowWithGC.gc) {\n        windowWithGC.gc();\n      }\n    });\n  }\n\n  // CPU stress test\n  async cpuStressTest(): Promise<void> {\n    await this.page.evaluate(() => {\n      // CPU intensive operation\n      const start = Date.now();\n      let cpuWork = 0;\n      while (Date.now() - start < 1000) {\n        cpuWork += Math.random() * Math.random();\n      }\n    });\n  }\n\n  // Network throttling simulation\n  async simulateSlowNetwork(): Promise<void> {\n    await this.page.route('**/*', async route => {\n      await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay\n      await route.continue();\n    });\n  }\n}\n\n// Test configuration\nexport const TEST_CONFIG = {\n  tabs: ['dashboard', 'accounts', 'transactions', 'insights', 'reports', 'wrapped', 'profile'],\n  selectors: {\n    navigation: '[data-testid=\"navigation\"]',\n    mainContent: 'main',\n    errorBoundary: '[data-testid=\"error-boundary\"]',\n    loading: '[data-testid=\"loading\"]'\n  },\n  timeouts: {\n    navigation: 5000,\n    component: 10000,\n    api: 15000\n  }\n};","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/hook-violations.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":5,"column":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\nimport { HookValidationMonitor, NavigationTester, ComponentValidator, TEST_CONFIG } from './hook-validation-config';\n\ntest.describe('React Hook Violations Detection', () => {\n  let hookMonitor: HookValidationMonitor;\n  let navigator: NavigationTester;\n  let validator: ComponentValidator;\n\n  test.beforeEach(async ({ page }) => {\n    hookMonitor = new HookValidationMonitor(page);\n    navigator = new NavigationTester(page, hookMonitor);\n    validator = new ComponentValidator(page);\n    \n    await hookMonitor.startMonitoring();\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('should load homepage without hook violations', async ({ page }) => {\n    // Wait for initial render\n    await page.waitForTimeout(2000);\n    \n    // Check for hook violations\n    const errors = hookMonitor.getErrors();\n    expect(errors).toHaveLength(0);\n    \n    // Verify React is working\n    const hasReact = await validator.hasReactComponents();\n    expect(hasReact).toBe(true);\n  });\n\n  test('should navigate to all tabs without hook violations', async ({ page }) => {\n    for (const tab of TEST_CONFIG.tabs) {\n      hookMonitor.reset();\n      \n      try {\n        await navigator.navigateToTab(tab);\n        \n        // Wait for tab to fully load\n        await page.waitForTimeout(1000);\n        \n        // Check for hook violations\n        const errors = hookMonitor.getErrors();\n        expect(errors, `Hook violations found on ${tab} tab: ${errors.join(', ')}`).toHaveLength(0);\n        \n        // Verify tab content is visible\n        await expect(page.locator('main')).toBeVisible();\n        \n      } catch (error) {\n        throw new Error(`Failed on ${tab} tab: ${error.message}`);\n      }\n    }\n  });\n\n  test('should handle rapid navigation without hook violations', async ({ page }) => {\n    const rapidTabs = ['dashboard', 'accounts', 'transactions', 'dashboard', 'profile', 'insights'];\n    \n    hookMonitor.reset();\n    await navigator.testRapidNavigation(rapidTabs);\n    \n    // Check for accumulated hook violations\n    const errors = hookMonitor.getErrors();\n    expect(errors, `Hook violations during rapid navigation: ${errors.join(', ')}`).toHaveLength(0);\n  });\n\n  test('should handle URL parameter navigation without hook violations', async ({ page }) => {\n    for (const tab of ['dashboard', 'accounts', 'transactions', 'profile']) {\n      hookMonitor.reset();\n      \n      await navigator.testUrlParameterNavigation(tab);\n      \n      const errors = hookMonitor.getErrors();\n      expect(errors, `Hook violations with URL param navigation to ${tab}: ${errors.join(', ')}`).toHaveLength(0);\n    }\n  });\n\n  test('should handle page refresh without hook violations', async ({ page }) => {\n    // Navigate to a specific tab first\n    await navigator.navigateToTab('accounts');\n    \n    hookMonitor.reset();\n    \n    // Refresh the page\n    await page.reload();\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(2000);\n    \n    const errors = hookMonitor.getErrors();\n    expect(errors, `Hook violations after page refresh: ${errors.join(', ')}`).toHaveLength(0);\n  });\n\n  test('should validate Index.tsx hook order fix', async ({ page }) => {\n    // This test specifically validates that the Index.tsx fix is working\n    \n    // Navigate to page and trigger potential hook order issues\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    // Wait for any async effects\n    await page.waitForTimeout(2000);\n    \n    // Check specifically for the \"rendered more hooks\" error\n    const errors = hookMonitor.getErrors();\n    const hookOrderErrors = errors.filter(error => \n      error.includes('rendered more hooks') || \n      error.includes('hook order')\n    );\n    \n    expect(hookOrderErrors, `Hook order violations detected: ${hookOrderErrors.join(', ')}`).toHaveLength(0);\n  });\n\n  test('should validate PerformanceMonitor component hook fix', async ({ page }) => {\n    // Check if performance monitor is enabled (development mode)\n    const perfMonitor = page.locator('[data-testid=\"performance-monitor\"], .performance-monitor');\n    \n    if (await perfMonitor.count() > 0) {\n      hookMonitor.reset();\n      \n      // Wait for performance monitor initialization\n      await page.waitForTimeout(2000);\n      \n      const errors = hookMonitor.getErrors();\n      expect(errors, `PerformanceMonitor hook violations: ${errors.join(', ')}`).toHaveLength(0);\n    }\n  });\n\n  test('should handle error boundary scenarios without hook violations', async ({ page }) => {\n    // Test that error boundaries don't cause hook violations\n    hookMonitor.reset();\n    \n    // Try to navigate to a potentially problematic route\n    await page.goto('/non-existent-route');\n    await page.waitForTimeout(1000);\n    \n    // Should show 404 page without hook violations\n    const errors = hookMonitor.getErrors();\n    expect(errors, `Hook violations in error boundary: ${errors.join(', ')}`).toHaveLength(0);\n  });\n\n  test('should validate component mounting/unmounting', async ({ page }) => {\n    // Test mounting and unmounting of components through navigation\n    const tabs = ['dashboard', 'wrapped', 'profile', 'dashboard'];\n    \n    for (const tab of tabs) {\n      hookMonitor.reset();\n      \n      await navigator.navigateToTab(tab);\n      await page.waitForTimeout(500);\n      \n      const errors = hookMonitor.getErrors();\n      expect(errors, `Hook violations during ${tab} mount/unmount: ${errors.join(', ')}`).toHaveLength(0);\n    }\n  });\n\n  test('should validate Suspense boundaries work correctly', async ({ page }) => {\n    // Test that Suspense boundaries don't cause hook violations\n    hookMonitor.reset();\n    \n    // Navigate to wrapped page which was previously nested in Suspense\n    await navigator.navigateToTab('wrapped');\n    await page.waitForTimeout(2000);\n    \n    const errors = hookMonitor.getErrors();\n    expect(errors, `Hook violations with Suspense boundaries: ${errors.join(', ')}`).toHaveLength(0);\n  });\n\n  test('should validate context providers are working', async ({ page }) => {\n    // Test that the new context providers don't cause issues\n    hookMonitor.reset();\n    \n    // Navigate through all tabs to test context usage\n    for (const tab of ['dashboard', 'accounts', 'insights']) {\n      await navigator.navigateToTab(tab);\n      await page.waitForTimeout(500);\n    }\n    \n    const errors = hookMonitor.getErrors();\n    expect(errors, `Hook violations with context providers: ${errors.join(', ')}`).toHaveLength(0);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/mobile-cross-browser.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":408,"column":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, devices } from '@playwright/test';\n\n// Mobile device configurations\nconst mobileDevices = [\n  { name: 'iPhone 12', device: devices['iPhone 12'] },\n  { name: 'iPhone 12 Pro', device: devices['iPhone 12 Pro'] },\n  { name: 'Pixel 5', device: devices['Pixel 5'] },\n  { name: 'Galaxy S21', device: devices['Galaxy S21'] },\n];\n\n// Desktop browser configurations  \nconst desktopBrowsers = [\n  { name: 'Chromium', use: { ...devices['Desktop Chrome'] } },\n  { name: 'Firefox', use: { ...devices['Desktop Firefox'] } },\n  { name: 'WebKit', use: { ...devices['Desktop Safari'] } },\n];\n\ntest.describe('Mobile and Cross-Browser Testing', () => {\n  \n  test.describe('Mobile Responsiveness Tests', () => {\n    mobileDevices.forEach(({ name, device }) => {\n      test.describe(`${name} Tests`, () => {\n        test.use(device);\n        \n        test(`should display correctly on ${name}`, async ({ page }) => {\n          await page.goto('/');\n          await page.waitForLoadState('networkidle');\n          \n          // Check viewport is correct\n          const viewport = page.viewportSize();\n          expect(viewport?.width).toBeLessThanOrEqual(500);\n          \n          // Verify mobile layout\n          await expect(page.locator('[data-testid=\"mobile-menu-toggle\"]')).toBeVisible();\n          await expect(page.locator('[data-testid=\"desktop-nav\"]')).not.toBeVisible();\n          \n          // Check account cards stack vertically\n          const accountCards = page.locator('[data-testid=\"account-card\"]');\n          const cardCount = await accountCards.count();\n          \n          if (cardCount >= 2) {\n            const firstCard = await accountCards.first().boundingBox();\n            const secondCard = await accountCards.nth(1).boundingBox();\n            \n            if (firstCard && secondCard) {\n              // Cards should stack vertically on mobile\n              expect(firstCard.y).toBeLessThan(secondCard.y);\n            }\n          }\n        });\n\n        test(`should handle touch interactions on ${name}`, async ({ page }) => {\n          await page.goto('/transactions');\n          \n          // Test touch scroll\n          await page.touchscreen.tap(200, 300);\n          await page.mouse.wheel(0, 500);\n          \n          // Should scroll smoothly\n          await expect(page.locator('[data-testid=\"transaction-list\"]')).toBeVisible();\n          \n          // Test swipe gestures\n          const transaction = page.locator('[data-testid=\"transaction-item\"]').first();\n          if (await transaction.isVisible()) {\n            const box = await transaction.boundingBox();\n            if (box) {\n              // Swipe left to reveal actions\n              await page.touchscreen.tap(box.x + box.width - 10, box.y + box.height / 2);\n              await page.mouse.move(box.x + 10, box.y + box.height / 2);\n              \n              // Should reveal swipe actions\n              await expect(page.locator('[data-testid=\"swipe-actions\"]')).toBeVisible();\n            }\n          }\n        });\n\n        test(`should handle mobile navigation on ${name}`, async ({ page }) => {\n          await page.goto('/');\n          \n          // Open mobile menu\n          await page.click('[data-testid=\"mobile-menu-toggle\"]');\n          await expect(page.locator('[data-testid=\"mobile-nav\"]')).toBeVisible();\n          \n          // Navigate to different sections\n          await page.click('[data-testid=\"mobile-nav-transactions\"]');\n          await expect(page).toHaveURL(/\\/transactions/);\n          \n          await page.click('[data-testid=\"mobile-menu-toggle\"]');\n          await page.click('[data-testid=\"mobile-nav-budget\"]');\n          await expect(page).toHaveURL(/\\/budget/);\n          \n          await page.click('[data-testid=\"mobile-menu-toggle\"]');\n          await page.click('[data-testid=\"mobile-nav-insights\"]');\n          await expect(page).toHaveURL(/\\/insights/);\n        });\n\n        test(`should optimize charts for mobile on ${name}`, async ({ page }) => {\n          await page.goto('/insights');\n          \n          // Charts should be responsive\n          const chart = page.locator('[data-testid=\"spending-trends-chart\"]');\n          await expect(chart).toBeVisible();\n          \n          const chartBox = await chart.boundingBox();\n          const viewport = page.viewportSize();\n          \n          if (chartBox && viewport) {\n            // Chart should fit within mobile viewport with margin\n            expect(chartBox.width).toBeLessThanOrEqual(viewport.width - 40);\n          }\n          \n          // Test chart interactions on mobile\n          if (chartBox) {\n            await page.touchscreen.tap(chartBox.x + chartBox.width / 2, chartBox.y + chartBox.height / 2);\n            \n            // Should show tooltip or details\n            const tooltip = page.locator('[data-testid=\"chart-tooltip\"]');\n            if (await tooltip.isVisible()) {\n              await expect(tooltip).toBeVisible();\n            }\n          }\n        });\n\n        test(`should handle mobile form inputs on ${name}`, async ({ page }) => {\n          await page.goto('/calculators');\n          await page.click('text=Compound Interest Calculator');\n          \n          // Mobile keyboard should not obstruct inputs\n          await page.fill('[data-testid=\"principal-input\"]', '10000');\n          await expect(page.locator('[data-testid=\"principal-input\"]')).toHaveValue('10000');\n          \n          await page.fill('[data-testid=\"rate-input\"]', '5');\n          await expect(page.locator('[data-testid=\"rate-input\"]')).toHaveValue('5');\n          \n          // Test mobile-friendly input controls\n          await page.click('[data-testid=\"calculate-button\"]');\n          await expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n        });\n\n        test(`should maintain performance on ${name}`, async ({ page }) => {\n          const startTime = Date.now();\n          \n          await page.goto('/');\n          await page.waitForLoadState('networkidle');\n          \n          const loadTime = Date.now() - startTime;\n          \n          // Should load within reasonable time on mobile\n          expect(loadTime).toBeLessThan(5000);\n          \n          // Test navigation performance\n          const navStart = Date.now();\n          await page.click('[data-testid=\"mobile-menu-toggle\"]');\n          await page.click('[data-testid=\"mobile-nav-insights\"]');\n          await page.waitForLoadState('networkidle');\n          const navTime = Date.now() - navStart;\n          \n          expect(navTime).toBeLessThan(3000);\n        });\n      });\n    });\n  });\n\n  test.describe('Cross-Browser Compatibility Tests', () => {\n    desktopBrowsers.forEach(({ name, use }) => {\n      test.describe(`${name} Browser Tests`, () => {\n        test.use(use);\n        \n        test(`should render correctly in ${name}`, async ({ page }) => {\n          await page.goto('/');\n          await page.waitForLoadState('networkidle');\n          \n          // Basic layout should work\n          await expect(page.locator('h1').filter({ hasText: 'Dashboard' })).toBeVisible();\n          await expect(page.locator('[data-testid=\"account-card\"]')).toHaveCount(4);\n          \n          // Navigation should be visible\n          await expect(page.locator('[data-testid=\"desktop-nav\"]')).toBeVisible();\n          await expect(page.locator('[data-testid=\"mobile-menu-toggle\"]')).not.toBeVisible();\n        });\n\n        test(`should handle CSS features in ${name}`, async ({ page }) => {\n          await page.goto('/');\n          \n          // Test backdrop-blur support\n          const glassCard = page.locator('[data-testid=\"glass-card\"]').first();\n          if (await glassCard.isVisible()) {\n            const styles = await glassCard.evaluate(el => getComputedStyle(el));\n            \n            // Should have backdrop filter or fallback\n            const hasBackdrop = styles.backdropFilter !== 'none';\n            const hasFallback = styles.backgroundColor.includes('rgba') || styles.background.includes('rgba');\n            \n            expect(hasBackdrop || hasFallback).toBe(true);\n          }\n          \n          // Test CSS Grid support\n          const layout = page.locator('[data-testid=\"dashboard-grid\"]');\n          if (await layout.isVisible()) {\n            const styles = await layout.evaluate(el => getComputedStyle(el));\n            expect(styles.display).toContain('grid');\n          }\n        });\n\n        test(`should handle JavaScript features in ${name}`, async ({ page }) => {\n          await page.goto('/calculators');\n          await page.click('text=Compound Interest Calculator');\n          \n          // Test ES6+ features\n          await page.fill('[data-testid=\"principal-input\"]', '10000');\n          await page.fill('[data-testid=\"rate-input\"]', '5');\n          await page.fill('[data-testid=\"years-input\"]', '10');\n          \n          await page.click('[data-testid=\"calculate-button\"]');\n          \n          // Modern JavaScript should work\n          await expect(page.locator('[data-testid=\"result\"]')).toBeVisible();\n          \n          // Test async/await\n          await page.click('[data-testid=\"save-calculation\"]');\n          await page.fill('[data-testid=\"calculation-name\"]', 'Test Calc');\n          await page.click('[data-testid=\"confirm-save\"]');\n          \n          await expect(page.locator('text=Calculation saved')).toBeVisible();\n        });\n\n        test(`should handle charts and visualization in ${name}`, async ({ page }) => {\n          await page.goto('/insights');\n          \n          // Charts should render\n          await expect(page.locator('[data-testid=\"spending-trends-chart\"]')).toBeVisible();\n          await expect(page.locator('[data-testid=\"category-breakdown-chart\"]')).toBeVisible();\n          \n          // Test chart interactions\n          const chart = page.locator('[data-testid=\"spending-trends-chart\"]');\n          await chart.hover();\n          \n          // Should show interactive elements\n          const tooltip = page.locator('[data-testid=\"chart-tooltip\"]');\n          if (await tooltip.isVisible()) {\n            await expect(tooltip).toBeVisible();\n          }\n        });\n\n        test(`should handle WebGL and animations in ${name}`, async ({ page }) => {\n          await page.goto('/');\n          \n          // Test liquid glass animations\n          const liquidElement = page.locator('[data-testid=\"liquid-glass-nav\"]');\n          if (await liquidElement.isVisible()) {\n            // Should have animation properties\n            const styles = await liquidElement.evaluate(el => getComputedStyle(el));\n            const hasTransition = styles.transition !== 'none' && styles.transition !== '';\n            const hasTransform = styles.transform !== 'none';\n            \n            expect(hasTransition || hasTransform).toBe(true);\n          }\n          \n          // Test performance of animations\n          const startTime = Date.now();\n          await page.hover('[data-testid=\"account-card\"]');\n          await page.waitForTimeout(500);\n          const endTime = Date.now();\n          \n          // Animations should be smooth\n          expect(endTime - startTime).toBeGreaterThanOrEqual(400);\n          expect(endTime - startTime).toBeLessThan(1000);\n        });\n\n        test(`should handle local storage in ${name}`, async ({ page }) => {\n          await page.goto('/');\n          \n          // Test setting preferences\n          await page.click('[data-testid=\"theme-toggle\"]');\n          \n          // Reload page\n          await page.reload();\n          \n          // Theme should persist\n          const htmlElement = page.locator('html');\n          const className = await htmlElement.getAttribute('class');\n          expect(className).toBeDefined();\n        });\n\n        test(`should handle error scenarios in ${name}`, async ({ page }) => {\n          // Test 404 page\n          await page.goto('/nonexistent-page');\n          await expect(page.locator('text=Page not found')).toBeVisible();\n          \n          // Test navigation back\n          await page.click('[data-testid=\"back-to-dashboard\"]');\n          await expect(page).toHaveURL('/');\n          \n          // Test error boundary\n          await page.goto('/calculators');\n          \n          // Trigger error condition\n          await page.evaluate(() => {\n            // Simulate error\n            const event = new CustomEvent('triggerError');\n            window.dispatchEvent(event);\n          });\n          \n          // Should show error boundary or handle gracefully\n          const errorMessage = page.locator('[data-testid=\"error-boundary\"]');\n          if (await errorMessage.isVisible()) {\n            await expect(errorMessage).toContainText('Something went wrong');\n          }\n        });\n      });\n    });\n  });\n\n  test.describe('Accessibility Cross-Platform Tests', () => {\n    test('should maintain keyboard navigation across devices', async ({ page }) => {\n      await page.goto('/calculators');\n      \n      // Tab through elements\n      await page.keyboard.press('Tab');\n      await page.keyboard.press('Tab');\n      await page.keyboard.press('Tab');\n      \n      // Should be able to activate with Enter\n      await page.keyboard.press('Enter');\n      \n      // Should navigate to calculator\n      await expect(page.locator('[data-testid=\"calculator-form\"]')).toBeVisible();\n    });\n\n    test('should provide proper ARIA labels', async ({ page }) => {\n      await page.goto('/');\n      \n      // Check for ARIA landmarks\n      await expect(page.locator('main[role=\"main\"]')).toBeVisible();\n      await expect(page.locator('nav[role=\"navigation\"]')).toBeVisible();\n      \n      // Check buttons have labels\n      const buttons = page.locator('button');\n      const buttonCount = await buttons.count();\n      \n      for (let i = 0; i < Math.min(buttonCount, 10); i++) {\n        const button = buttons.nth(i);\n        const hasLabel = await button.getAttribute('aria-label') || \n                        await button.textContent() ||\n                        await button.getAttribute('title');\n        expect(hasLabel).toBeTruthy();\n      }\n    });\n\n    test('should support screen readers', async ({ page }) => {\n      await page.goto('/transactions');\n      \n      // Check for screen reader friendly content\n      const transactions = page.locator('[data-testid=\"transaction-item\"]');\n      const count = await transactions.count();\n      \n      if (count > 0) {\n        const firstTransaction = transactions.first();\n        \n        // Should have accessible description\n        const ariaLabel = await firstTransaction.getAttribute('aria-label');\n        const ariaDescribedBy = await firstTransaction.getAttribute('aria-describedby');\n        \n        expect(ariaLabel || ariaDescribedBy).toBeTruthy();\n      }\n    });\n  });\n\n  test.describe('Performance Across Platforms', () => {\n    test('should maintain consistent performance', async ({ page }) => {\n      const measurements = [];\n      \n      // Test multiple page loads\n      for (let i = 0; i < 3; i++) {\n        const startTime = Date.now();\n        await page.goto('/');\n        await page.waitForLoadState('networkidle');\n        const loadTime = Date.now() - startTime;\n        measurements.push(loadTime);\n      }\n      \n      // Calculate average\n      const avgLoadTime = measurements.reduce((a, b) => a + b, 0) / measurements.length;\n      \n      // Should be consistently fast\n      expect(avgLoadTime).toBeLessThan(3000);\n      \n      // Variance should be low\n      const variance = measurements.reduce((acc, time) => acc + Math.pow(time - avgLoadTime, 2), 0) / measurements.length;\n      expect(variance).toBeLessThan(1000000); // Low variance\n    });\n\n    test('should handle memory efficiently', async ({ page }) => {\n      await page.goto('/');\n      \n      // Navigate through multiple pages\n      const pages = ['/transactions', '/budget', '/insights', '/calculators', '/'];\n      \n      for (const path of pages) {\n        await page.goto(path);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(1000);\n      }\n      \n      // Check for memory leaks (basic test)\n      const metrics = await page.evaluate(() => {\n        if ('memory' in performance) {\n          return (performance as unknown as { memory?: { usedJSHeapSize: number; totalJSHeapSize: number; jsHeapSizeLimit: number } }).memory;\n        }\n        return null;\n      });\n      \n      if (metrics) {\n        // Heap size should be reasonable\n        expect(metrics.usedJSHeapSize).toBeLessThan(50 * 1024 * 1024); // 50MB limit\n      }\n    });\n  });\n\n  test.describe('Network Conditions Testing', () => {\n    test('should work on slow networks', async ({ page }) => {\n      // Simulate slow 3G\n      await page.route('**/*', route => {\n        setTimeout(() => route.continue(), 1000); // 1 second delay\n      });\n      \n      await page.goto('/');\n      \n      // Should show loading states\n      await expect(page.locator('[data-testid=\"loading-indicator\"]')).toBeVisible();\n      \n      // Should eventually load\n      await expect(page.locator('h1').filter({ hasText: 'Dashboard' })).toBeVisible({ timeout: 10000 });\n    });\n\n    test('should handle offline mode', async ({ page }) => {\n      await page.goto('/');\n      await page.waitForLoadState('networkidle');\n      \n      // Go offline\n      await page.context().setOffline(true);\n      \n      // Try to navigate\n      await page.click('[data-testid=\"nav-transactions\"]');\n      \n      // Should show offline indicator\n      await expect(page.locator('[data-testid=\"offline-indicator\"]')).toBeVisible();\n      \n      // Should still show cached content\n      await expect(page.locator('[data-testid=\"transaction-list\"]')).toBeVisible();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/mobile-responsive-financial-pages.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/mobile-ui-validation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/navigation-hook-validation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":4,"column":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page } from '@playwright/test';\n\ntest.describe('Navigation Hook Validation Tests', () => {\n  let reactErrors: string[] = [];\n  let hookWarnings: string[] = [];\n\n  test.beforeEach(async ({ page }) => {\n    // Reset error tracking\n    reactErrors = [];\n    hookWarnings = [];\n\n    // Enhanced console monitoring\n    page.on('console', (msg) => {\n      const text = msg.text();\n      const type = msg.type();\n      \n      if (type === 'error') {\n        if (text.includes('Hook') || text.includes('React') || text.includes('rendered more hooks')) {\n          reactErrors.push(`ERROR: ${text}`);\n        }\n      } else if (type === 'warning') {\n        if (text.includes('Hook') || text.includes('React')) {\n          hookWarnings.push(`WARNING: ${text}`);\n        }\n      }\n    });\n\n    // Monitor page errors\n    page.on('pageerror', (error) => {\n      if (error.message.includes('Hook') || error.message.includes('React')) {\n        reactErrors.push(`PAGE ERROR: ${error.message}`);\n      }\n    });\n\n    // Navigate to initial page\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('should handle all tab navigation sequences without hook violations', async ({ page }) => {\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights', 'reports', 'wrapped', 'profile'];\n    \n    // Test every possible tab transition\n    for (const fromTab of tabs) {\n      for (const toTab of tabs) {\n        if (fromTab !== toTab) {\n          console.log(`Testing navigation: ${fromTab} â†’ ${toTab}`);\n          \n          // Navigate to source tab\n          await page.goto(`/?tab=${fromTab}`);\n          await page.waitForLoadState('networkidle');\n          await page.waitForTimeout(300);\n          \n          // Clear errors before transition\n          const preTransitionErrors = reactErrors.length;\n          \n          // Navigate to destination tab\n          await page.goto(`/?tab=${toTab}`);\n          await page.waitForLoadState('networkidle');\n          await page.waitForTimeout(300);\n          \n          // Check for new hook errors\n          const newErrors = reactErrors.slice(preTransitionErrors);\n          if (newErrors.length > 0) {\n            console.error(`Hook errors during ${fromTab} â†’ ${toTab}:`, newErrors);\n          }\n          \n          expect(newErrors, `Hook violations during ${fromTab} â†’ ${toTab}: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n        }\n      }\n    }\n  });\n\n  test('should handle bottom navigation tab switching without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Test bottom navigation if available\n    const bottomNavButtons = [\n      '[data-testid=\"nav-dashboard\"]',\n      '[data-testid=\"nav-accounts\"]', \n      '[data-testid=\"nav-transactions\"]',\n      '[data-testid=\"nav-insights\"]',\n      '[data-testid=\"nav-reports\"]',\n      '[data-testid=\"nav-wrapped\"]',\n      '[data-testid=\"nav-profile\"]'\n    ];\n    \n    for (const buttonSelector of bottomNavButtons) {\n      const button = page.locator(buttonSelector);\n      if (await button.isVisible()) {\n        console.log(`Clicking bottom nav button: ${buttonSelector}`);\n        await button.click();\n        await page.waitForTimeout(500);\n      }\n    }\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during bottom nav switching: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle URL state changes without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Test various URL state changes that might affect hook order\n    const urlChanges = [\n      { url: '/', description: 'Root URL' },\n      { url: '/?tab=dashboard', description: 'Dashboard with tab param' },\n      { url: '/?tab=insights&view=overview', description: 'Insights with sub-param' },\n      { url: '/?tab=transactions&filter=recent&sort=date', description: 'Transactions with multiple params' },\n      { url: '/?tab=reports&period=monthly&category=all', description: 'Reports with filters' },\n      { url: '/?tab=profile&section=settings&subsection=privacy', description: 'Profile with nested params' },\n      { url: '/#/legacy-route', description: 'Legacy hash route' },\n      { url: '/?invalid=param&tab=dashboard', description: 'Invalid param with valid tab' }\n    ];\n    \n    for (const { url, description } of urlChanges) {\n      console.log(`Testing URL change: ${description} - ${url}`);\n      \n      await page.goto(url);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(400);\n    }\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during URL state changes: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle browser back/forward navigation without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Build navigation history\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(300);\n    \n    await page.goto('/?tab=transactions');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(300);\n    \n    await page.goto('/?tab=insights');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(300);\n    \n    await page.goto('/?tab=reports');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(300);\n    \n    // Test back navigation\n    for (let i = 0; i < 3; i++) {\n      console.log(`Browser back navigation #${i + 1}`);\n      await page.goBack();\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    // Test forward navigation\n    for (let i = 0; i < 3; i++) {\n      console.log(`Browser forward navigation #${i + 1}`);\n      await page.goForward();\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during browser navigation: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle rapid navigation stress test without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    // Rapid navigation stress test\n    console.log('Starting rapid navigation stress test...');\n    \n    for (let cycle = 0; cycle < 10; cycle++) {\n      for (const tab of tabs) {\n        await page.goto(`/?tab=${tab}`);\n        // Very short wait to stress test React's reconciliation\n        await page.waitForTimeout(50);\n      }\n    }\n    \n    // Final wait for everything to settle\n    await page.waitForTimeout(2000);\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during rapid navigation: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle navigation with viewport changes without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    const viewports = [\n      { width: 1920, height: 1080, name: 'Desktop Large' },\n      { width: 1366, height: 768, name: 'Desktop Medium' },\n      { width: 768, height: 1024, name: 'Tablet' },\n      { width: 375, height: 667, name: 'Mobile' },\n      { width: 320, height: 568, name: 'Mobile Small' }\n    ];\n    \n    const tabs = ['dashboard', 'transactions', 'insights'];\n    \n    for (const viewport of viewports) {\n      console.log(`Testing navigation on ${viewport.name} (${viewport.width}x${viewport.height})`);\n      \n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      await page.waitForTimeout(200);\n      \n      for (const tab of tabs) {\n        await page.goto(`/?tab=${tab}`);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(300);\n      }\n    }\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during viewport navigation: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle navigation during component lazy loading without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Test navigation to wrapped tab (lazy loaded) multiple times\n    for (let i = 0; i < 5; i++) {\n      console.log(`Lazy loading test iteration ${i + 1}`);\n      \n      // Navigate to wrapped tab\n      await page.goto('/?tab=wrapped');\n      await page.waitForLoadState('networkidle');\n      \n      // Wait for lazy component to potentially load\n      await page.waitForTimeout(1000);\n      \n      // Navigate away to unmount\n      await page.goto('/?tab=dashboard');\n      await page.waitForTimeout(300);\n      \n      // Navigate back to trigger re-mount and potential lazy loading\n      await page.goto('/?tab=wrapped');\n      await page.waitForTimeout(300);\n    }\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during lazy loading navigation: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle navigation error recovery without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Test navigation to potentially problematic routes\n    const problematicUrls = [\n      '/?tab=nonexistent',\n      '/?tab=',\n      '/?tab=dashboard&corrupt=true',\n      '/nonexistent-route',\n      '/?tab=insights&invalid[param]=test'\n    ];\n    \n    for (const url of problematicUrls) {\n      console.log(`Testing potentially problematic URL: ${url}`);\n      \n      try {\n        await page.goto(url);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(500);\n        \n        // Try to recover by navigating to a known good route\n        await page.goto('/?tab=dashboard');\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(300);\n      } catch (error) {\n        console.log(`Expected error for problematic URL ${url}:`, error.message);\n      }\n    }\n    \n    // Check for hook errors (not general navigation errors)\n    const newErrors = reactErrors.slice(initialErrorCount);\n    const hookSpecificErrors = newErrors.filter(error => \n      error.includes('rendered more hooks') || \n      error.includes('Hook call') ||\n      error.includes('Invalid hook call')\n    );\n    \n    expect(hookSpecificErrors, `Hook violations during error recovery: ${JSON.stringify(hookSpecificErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle concurrent navigation events without hook violations', async ({ page }) => {\n    const initialErrorCount = reactErrors.length;\n    \n    // Test handling multiple navigation events in quick succession\n    console.log('Testing concurrent navigation events...');\n    \n    // Start multiple navigation operations concurrently\n    const navigationPromises = [\n      page.goto('/?tab=dashboard'),\n      page.goto('/?tab=transactions'),\n      page.goto('/?tab=insights')\n    ];\n    \n    // Wait for one to complete\n    await Promise.race(navigationPromises);\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(1000);\n    \n    // Test rapid sequential navigation\n    await page.goto('/?tab=accounts');\n    await page.goto('/?tab=reports');\n    await page.goto('/?tab=wrapped');\n    \n    // Wait for everything to settle\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(2000);\n    \n    // Check for hook errors\n    const newErrors = reactErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during concurrent navigation: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should validate specific hook violation patterns', async ({ page }) => {\n    // This test looks for the exact patterns that cause hook violations\n    \n    let specificHookError = '';\n    page.on('console', (msg) => {\n      if (msg.type() === 'error') {\n        const text = msg.text();\n        if (text.includes('rendered more hooks than during the previous render')) {\n          specificHookError = text;\n        }\n      }\n    });\n    \n    // Reproduce the exact scenario from the error reports\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Navigate to insights (commonly reported problem area)\n    await page.goto('/?tab=insights');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(1000);\n    \n    // Switch to mobile viewport (common trigger)\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.waitForTimeout(500);\n    \n    // Navigate back to dashboard\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    // Switch back to desktop\n    await page.setViewportSize({ width: 1200, height: 800 });\n    await page.waitForTimeout(500);\n    \n    // Navigate to transactions\n    await page.goto('/?tab=transactions');\n    await page.waitForLoadState('networkidle');\n    \n    // Final check\n    await page.waitForTimeout(2000);\n    \n    if (specificHookError) {\n      console.error('SPECIFIC HOOK VIOLATION REPRODUCED:', specificHookError);\n      throw new Error(`Hook violation pattern detected: ${specificHookError}`);\n    }\n    \n    expect(specificHookError).toBe('');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/performance-hook-validation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":4,"column":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page } from '@playwright/test';\n\ntest.describe('Performance and Stress Testing for Hook Violations', () => {\n  let performanceErrors: string[] = [];\n  let memoryWarnings: string[] = [];\n\n  test.beforeEach(async ({ page }) => {\n    performanceErrors = [];\n    memoryWarnings = [];\n\n    // Monitor console for performance-related hook issues\n    page.on('console', (msg) => {\n      const text = msg.text();\n      if (msg.type() === 'error' && (\n        text.includes('Hook') || \n        text.includes('rendered more hooks') ||\n        text.includes('memory leak') ||\n        text.includes('performance')\n      )) {\n        performanceErrors.push(text);\n      }\n      \n      if (msg.type() === 'warning' && (\n        text.includes('memory') ||\n        text.includes('performance') ||\n        text.includes('Hook')\n      )) {\n        memoryWarnings.push(text);\n      }\n    });\n\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n  });\n\n  test('should handle high-frequency navigation without hook violations', async ({ page }) => {\n    const startTime = Date.now();\n    const initialErrorCount = performanceErrors.length;\n    \n    // High-frequency navigation test\n    console.log('Starting high-frequency navigation test...');\n    \n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights', 'reports'];\n    \n    // Perform 100 rapid navigations\n    for (let i = 0; i < 100; i++) {\n      const tab = tabs[i % tabs.length];\n      await page.goto(`/?tab=${tab}`);\n      // Minimal wait to stress test\n      await page.waitForTimeout(10);\n      \n      if (i % 20 === 0) {\n        console.log(`Navigation iteration: ${i + 1}/100`);\n      }\n    }\n    \n    // Final settlement\n    await page.waitForTimeout(2000);\n    \n    const endTime = Date.now();\n    const duration = endTime - startTime;\n    \n    console.log(`High-frequency navigation completed in ${duration}ms`);\n    \n    // Check for performance-related hook errors\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Performance hook violations: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n    \n    // Ensure reasonable performance (should complete in under 30 seconds)\n    expect(duration).toBeLessThan(30000);\n  });\n\n  test('should handle memory stress during navigation without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    // Create memory pressure scenario\n    console.log('Starting memory stress test...');\n    \n    // Inject memory pressure\n    await page.evaluate(() => {\n      // Create some memory pressure\n      const memoryArray: number[][] = [];\n      for (let i = 0; i < 1000; i++) {\n        memoryArray.push(new Array(1000).fill(Math.random()));\n      }\n      (window as unknown as { memoryPressure?: number[][] }).memoryPressure = memoryArray;\n    });\n    \n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    // Navigate under memory pressure\n    for (let cycle = 0; cycle < 10; cycle++) {\n      console.log(`Memory stress cycle: ${cycle + 1}/10`);\n      \n      for (const tab of tabs) {\n        await page.goto(`/?tab=${tab}`);\n        await page.waitForLoadState('networkidle');\n        await page.waitForTimeout(100);\n        \n        // Add more memory pressure each cycle\n        await page.evaluate((cycleNum) => {\n          const additionalMemory = new Array(500).fill(`cycle-${cycleNum}-${Math.random()}`);\n          const windowWithMemory = window as unknown as { memoryPressure?: (number[][] | string[])[] };\n          windowWithMemory.memoryPressure?.push(additionalMemory);\n        }, cycle);\n      }\n    }\n    \n    // Clean up memory\n    await page.evaluate(() => {\n      delete (window as unknown as { memoryPressure?: unknown }).memoryPressure;\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    // Check for hook errors under memory pressure\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations under memory pressure: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle CPU stress during navigation without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting CPU stress test...');\n    \n    // Create CPU stress in background\n    await page.evaluate(() => {\n      let cpuStress = true;\n      const stressCPU = () => {\n        if (cpuStress) {\n          // Perform some CPU-intensive calculations\n          let result = 0;\n          for (let i = 0; i < 100000; i++) {\n            result += Math.sin(i) * Math.cos(i);\n          }\n          setTimeout(stressCPU, 1);\n        }\n      };\n      stressCPU();\n      \n      // Stop after 30 seconds\n      setTimeout(() => {\n        cpuStress = false;\n      }, 30000);\n    });\n    \n    const tabs = ['dashboard', 'transactions', 'insights', 'reports'];\n    \n    // Navigate under CPU stress\n    for (let i = 0; i < 20; i++) {\n      const tab = tabs[i % tabs.length];\n      console.log(`CPU stress navigation ${i + 1}/20: ${tab}`);\n      \n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(200);\n    }\n    \n    await page.waitForTimeout(2000);\n    \n    // Check for hook errors under CPU stress\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations under CPU stress: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle network throttling during navigation without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting network throttling test...');\n    \n    // Simulate slow network\n    const client = await page.context().newCDPSession(page);\n    await client.send('Network.emulateNetworkConditions', {\n      offline: false,\n      downloadThroughput: 50 * 1024, // 50 KB/s\n      uploadThroughput: 20 * 1024,   // 20 KB/s\n      latency: 500 // 500ms latency\n    });\n    \n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    // Navigate under network throttling\n    for (const tab of tabs) {\n      console.log(`Throttled navigation to: ${tab}`);\n      \n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle', { timeout: 30000 });\n      await page.waitForTimeout(500);\n    }\n    \n    // Restore normal network\n    await client.send('Network.emulateNetworkConditions', {\n      offline: false,\n      downloadThroughput: -1,\n      uploadThroughput: -1,\n      latency: 0\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    // Check for hook errors under network stress\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations under network throttling: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle multiple concurrent user interactions without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting concurrent interactions test...');\n    \n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    // Simulate multiple concurrent user interactions\n    const interactions = [\n      // Mouse movements\n      page.mouse.move(100, 100),\n      page.mouse.move(200, 200),\n      page.mouse.move(300, 300),\n      \n      // Navigation attempts\n      page.goto('/?tab=transactions'),\n      page.goBack(),\n      page.goForward(),\n      \n      // Keyboard events\n      page.keyboard.press('Tab'),\n      page.keyboard.press('Enter'),\n      page.keyboard.press('Escape'),\n      \n      // Touch events (for mobile simulation)\n      page.touchscreen.tap(150, 150),\n      \n      // Viewport changes\n      page.setViewportSize({ width: 800, height: 600 }),\n      page.setViewportSize({ width: 1200, height: 800 })\n    ];\n    \n    // Execute all interactions concurrently\n    await Promise.allSettled(interactions);\n    \n    // Wait for everything to settle\n    await page.waitForTimeout(2000);\n    \n    // Navigate through tabs after concurrent interactions\n    const tabs = ['dashboard', 'accounts', 'transactions'];\n    for (const tab of tabs) {\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    // Check for hook errors after concurrent interactions\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during concurrent interactions: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle page lifecycle events without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting page lifecycle test...');\n    \n    // Test various page lifecycle events\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    // Simulate page visibility changes\n    await page.evaluate(() => {\n      // Simulate page becoming hidden\n      Object.defineProperty(document, 'hidden', {\n        writable: true,\n        value: true\n      });\n      Object.defineProperty(document, 'visibilityState', {\n        writable: true,\n        value: 'hidden'\n      });\n      document.dispatchEvent(new Event('visibilitychange'));\n    });\n    \n    await page.waitForTimeout(500);\n    \n    // Navigate while \"hidden\"\n    await page.goto('/?tab=transactions');\n    await page.waitForTimeout(300);\n    \n    // Simulate page becoming visible again\n    await page.evaluate(() => {\n      Object.defineProperty(document, 'hidden', {\n        writable: true,\n        value: false\n      });\n      Object.defineProperty(document, 'visibilityState', {\n        writable: true,\n        value: 'visible'\n      });\n      document.dispatchEvent(new Event('visibilitychange'));\n    });\n    \n    await page.waitForTimeout(500);\n    \n    // Test focus/blur events\n    await page.evaluate(() => {\n      window.dispatchEvent(new Event('blur'));\n    });\n    \n    await page.goto('/?tab=insights');\n    await page.waitForTimeout(300);\n    \n    await page.evaluate(() => {\n      window.dispatchEvent(new Event('focus'));\n    });\n    \n    await page.waitForTimeout(1000);\n    \n    // Check for hook errors during lifecycle events\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during lifecycle events: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle error conditions without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting error conditions test...');\n    \n    // Simulate various error conditions\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    \n    // Simulate JavaScript errors\n    await page.evaluate(() => {\n      // Inject a non-hook-related error\n      setTimeout(() => {\n        try {\n          throw new Error('Simulated non-React error');\n        } catch (e) {\n          console.error('Caught simulated error:', e);\n        }\n      }, 100);\n    });\n    \n    await page.waitForTimeout(200);\n    \n    // Navigate after error\n    await page.goto('/?tab=transactions');\n    await page.waitForLoadState('networkidle');\n    \n    // Simulate network error\n    await page.route('**/*', route => {\n      if (Math.random() < 0.1) { // 10% chance of network error\n        route.abort();\n      } else {\n        route.continue();\n      }\n    });\n    \n    // Navigate with potential network errors\n    await page.goto('/?tab=insights');\n    await page.waitForLoadState('networkidle');\n    \n    // Clear route handler\n    await page.unroute('**/*');\n    \n    await page.waitForTimeout(1000);\n    \n    // Check for hook errors (not general errors)\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    const hookSpecificErrors = newErrors.filter(error => \n      error.includes('rendered more hooks') || \n      error.includes('Hook call') ||\n      error.includes('Invalid hook call')\n    );\n    \n    expect(hookSpecificErrors, `Hook violations during error conditions: ${JSON.stringify(hookSpecificErrors)}`).toHaveLength(0);\n  });\n\n  test('should handle resource cleanup during navigation without hook violations', async ({ page }) => {\n    const initialErrorCount = performanceErrors.length;\n    \n    console.log('Starting resource cleanup test...');\n    \n    // Track resource usage\n    await page.evaluate(() => {\n      (window as any).resourceTracker = {\n        intervals: [],\n        timeouts: [],\n        listeners: []\n      };\n      \n      // Mock some resource creation\n      const originalSetInterval = window.setInterval;\n      const originalSetTimeout = window.setTimeout;\n      const originalAddEventListener = window.addEventListener;\n      \n      window.setInterval = function(fn, delay) {\n        const id = originalSetInterval(fn, delay);\n        (window as any).resourceTracker.intervals.push(id);\n        return id;\n      };\n      \n      window.setTimeout = function(fn, delay) {\n        const id = originalSetTimeout(fn, delay);\n        (window as any).resourceTracker.timeouts.push(id);\n        return id;\n      };\n      \n      window.addEventListener = function(type, listener, options) {\n        originalAddEventListener.call(this, type, listener, options);\n        (window as any).resourceTracker.listeners.push({ type, listener });\n      };\n    });\n    \n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    // Navigate and create resources\n    for (const tab of tabs) {\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      \n      // Create some mock resources\n      await page.evaluate(() => {\n        // Create interval\n        setInterval(() => {}, 1000);\n        \n        // Create timeout\n        setTimeout(() => {}, 5000);\n        \n        // Add event listener\n        addEventListener('resize', () => {});\n      });\n      \n      await page.waitForTimeout(300);\n    }\n    \n    // Check resource cleanup\n    const resourceCount = await page.evaluate(() => {\n      const tracker = (window as any).resourceTracker;\n      return {\n        intervals: tracker.intervals.length,\n        timeouts: tracker.timeouts.length,\n        listeners: tracker.listeners.length\n      };\n    });\n    \n    console.log('Resource count:', resourceCount);\n    \n    // Navigate one more time to trigger cleanup\n    await page.goto('/?tab=dashboard');\n    await page.waitForTimeout(1000);\n    \n    // Check for hook errors related to cleanup\n    const newErrors = performanceErrors.slice(initialErrorCount);\n    expect(newErrors, `Hook violations during resource cleanup: ${JSON.stringify(newErrors)}`).toHaveLength(0);\n  });\n\n  test('should measure and validate performance metrics', async ({ page }) => {\n    console.log('Starting performance metrics validation...');\n    \n    const navigationTimes: number[] = [];\n    const tabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    for (const tab of tabs) {\n      const startTime = Date.now();\n      \n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      \n      const endTime = Date.now();\n      const navigationTime = endTime - startTime;\n      navigationTimes.push(navigationTime);\n      \n      console.log(`Navigation to ${tab}: ${navigationTime}ms`);\n    }\n    \n    // Calculate performance metrics\n    const avgNavigationTime = navigationTimes.reduce((a, b) => a + b, 0) / navigationTimes.length;\n    const maxNavigationTime = Math.max(...navigationTimes);\n    \n    console.log(`Average navigation time: ${avgNavigationTime}ms`);\n    console.log(`Max navigation time: ${maxNavigationTime}ms`);\n    \n    // Performance assertions\n    expect(avgNavigationTime, 'Average navigation time should be reasonable').toBeLessThan(3000);\n    expect(maxNavigationTime, 'No single navigation should take too long').toBeLessThan(5000);\n    \n    // Ensure no hook-related performance issues\n    expect(performanceErrors.filter(e => e.includes('Hook'))).toHaveLength(0);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/performance-responsive.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":36,"column":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Responsive Performance Test Suite\n * Monitors CLS and LCP across multiple viewports\n * Fails if performance thresholds are breached\n */\n\nimport { test, expect, Page } from '@playwright/test';\n\n// Performance thresholds\nconst PERFORMANCE_THRESHOLDS = {\n  LCP: 2000,    // 2 seconds max\n  CLS: 0.05,    // 0.05 max cumulative layout shift\n  TTI: 3000,    // 3 seconds max time to interactive\n  FCP: 1500,    // 1.5 seconds first contentful paint\n};\n\n// Viewport configurations for testing\nconst VIEWPORTS = [\n  { name: 'Mobile', width: 320, height: 568 },     // iPhone SE\n  { name: 'Mobile Large', width: 480, height: 854 }, // Large mobile\n  { name: 'Tablet', width: 768, height: 1024 },      // iPad\n  { name: 'Desktop', width: 1024, height: 768 },     // Small desktop\n  { name: 'Desktop Large', width: 1440, height: 900 }, // Large desktop\n];\n\n// Critical routes to test\nconst CRITICAL_ROUTES = [\n  { path: '/', name: 'Dashboard' },\n  { path: '/accounts', name: 'Accounts' },\n  { path: '/transactions', name: 'Transactions' },\n  { path: '/insights', name: 'Insights' },\n  { path: '/calculators', name: 'Calculators' },\n];\n\n// Web Vitals collection utility\nconst collectWebVitals = async (page: Page) => {\n  return await page.evaluate(() => {\n    return new Promise((resolve) => {\n      const vitals: any = {};\n      let pendingMetrics = 3; // LCP, CLS, FCP\n\n      const handleMetric = (name: string, value: number) => {\n        vitals[name] = value;\n        pendingMetrics--;\n        if (pendingMetrics === 0) {\n          resolve(vitals);\n        }\n      };\n\n      // Import web-vitals if available, otherwise use Performance Observer\n      try {\n        import('web-vitals').then(({ onLCP, onCLS, onFCP }) => {\n          onLCP(({ value }) => handleMetric('LCP', value));\n          onCLS(({ value }) => handleMetric('CLS', value));  \n          onFCP(({ value }) => handleMetric('FCP', value));\n        }).catch(() => {\n          // Fallback to Performance Observer API\n          const observer = new PerformanceObserver((list) => {\n            const entries = list.getEntries();\n            entries.forEach((entry) => {\n              if (entry.entryType === 'largest-contentful-paint') {\n                handleMetric('LCP', entry.startTime);\n              } else if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n                vitals.CLS = (vitals.CLS || 0) + entry.value;\n              }\n            });\n          });\n          \n          observer.observe({ entryTypes: ['largest-contentful-paint', 'layout-shift', 'paint'] });\n          \n          // Fallback values after timeout\n          setTimeout(() => {\n            if (!vitals.LCP) vitals.LCP = performance.now();\n            if (!vitals.CLS) vitals.CLS = 0;\n            if (!vitals.FCP) vitals.FCP = performance.now();\n            resolve(vitals);\n          }, 5000);\n        });\n      } catch (error) {\n        // Manual fallback\n        setTimeout(() => {\n          vitals.LCP = performance.now();\n          vitals.CLS = 0;\n          vitals.FCP = performance.now();\n          resolve(vitals);\n        }, 3000);\n      }\n    });\n  });\n};\n\n// Main test suite\nfor (const viewport of VIEWPORTS) {\n  test.describe(`Performance Tests - ${viewport.name} (${viewport.width}x${viewport.height})`, () => {\n    test.beforeEach(async ({ page }) => {\n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      \n      // Enable performance monitoring\n      await page.addInitScript(() => {\n        // Monitor for layout shifts\n        window.__CLSScore = 0;\n        new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach((entry: any) => {\n            if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n              window.__CLSScore += entry.value;\n            }\n          });\n        }).observe({ entryTypes: ['layout-shift'] });\n      });\n    });\n\n    for (const route of CRITICAL_ROUTES) {\n      test(`${route.name} performance on ${viewport.name}`, async ({ page }) => {\n        const startTime = Date.now();\n        \n        // Navigate to route\n        await page.goto(`http://localhost:5000${route.path}`, {\n          waitUntil: 'networkidle',\n          timeout: 30000\n        });\n\n        // Wait for page to stabilize\n        await page.waitForTimeout(2000);\n\n        // Collect Web Vitals\n        const vitals = await collectWebVitals(page);\n        \n        // Get additional metrics\n        const navigationTiming = await page.evaluate(() => {\n          const timing = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n          return {\n            domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,\n            loadComplete: timing.loadEventEnd - timing.loadEventStart,\n            timeToInteractive: Date.now() - timing.navigationStart\n          };\n        });\n\n        // Get CLS score\n        const clsScore = await page.evaluate(() => window.__CLSScore || 0);\n\n        // Performance assertions\n        console.log(`ðŸ“Š ${route.name} on ${viewport.name}:\n          LCP: ${vitals.LCP?.toFixed(2)}ms (threshold: ${PERFORMANCE_THRESHOLDS.LCP}ms)\n          CLS: ${clsScore.toFixed(4)} (threshold: ${PERFORMANCE_THRESHOLDS.CLS})\n          FCP: ${vitals.FCP?.toFixed(2)}ms (threshold: ${PERFORMANCE_THRESHOLDS.FCP}ms)\n          TTI: ${navigationTiming.timeToInteractive?.toFixed(2)}ms (threshold: ${PERFORMANCE_THRESHOLDS.TTI}ms)`);\n\n        // Assertions with clear error messages\n        expect(vitals.LCP, `LCP too slow on ${viewport.name}: ${vitals.LCP}ms > ${PERFORMANCE_THRESHOLDS.LCP}ms`)\n          .toBeLessThanOrEqual(PERFORMANCE_THRESHOLDS.LCP);\n        \n        expect(clsScore, `CLS too high on ${viewport.name}: ${clsScore} > ${PERFORMANCE_THRESHOLDS.CLS}`)\n          .toBeLessThanOrEqual(PERFORMANCE_THRESHOLDS.CLS);\n\n        expect(vitals.FCP, `FCP too slow on ${viewport.name}: ${vitals.FCP}ms > ${PERFORMANCE_THRESHOLDS.FCP}ms`)\n          .toBeLessThanOrEqual(PERFORMANCE_THRESHOLDS.FCP);\n\n        // Layout stability test\n        await test.step('Layout stability check', async () => {\n          const initialHTML = await page.content();\n          await page.waitForTimeout(1000);\n          \n          // Scroll to trigger any lazy-loaded content\n          await page.evaluate(() => {\n            window.scrollTo(0, document.body.scrollHeight / 2);\n          });\n          await page.waitForTimeout(500);\n          \n          const finalCLS = await page.evaluate(() => window.__CLSScore || 0);\n          expect(finalCLS, `Layout shift after scroll: ${finalCLS} > ${PERFORMANCE_THRESHOLDS.CLS}`)\n            .toBeLessThanOrEqual(PERFORMANCE_THRESHOLDS.CLS);\n        });\n\n        // Check for horizontal scroll\n        await test.step('No horizontal scroll', async () => {\n          const hasHorizontalScroll = await page.evaluate(() => {\n            return document.documentElement.scrollWidth > document.documentElement.clientWidth;\n          });\n          expect(hasHorizontalScroll, `Horizontal scroll detected on ${viewport.name}`).toBeFalsy();\n        });\n\n        // Verify critical content is visible\n        await test.step('Critical content visibility', async () => {\n          if (route.path === '/') {\n            await expect(page.locator('[data-testid=\"dashboard-header\"]')).toBeVisible();\n          }\n          \n          // Check for error states\n          const errorElements = await page.locator('[data-testid*=\"error\"], .error-message, [role=\"alert\"]').count();\n          expect(errorElements, `Error elements found on ${route.name}`).toBe(0);\n        });\n      });\n    }\n\n    test(`Bundle size budget check on ${viewport.name}`, async ({ page }) => {\n      // Monitor network requests\n      const responses: any[] = [];\n      page.on('response', response => {\n        if (response.url().includes('.js') || response.url().includes('.css')) {\n          responses.push({\n            url: response.url(),\n            size: response.headers()['content-length'] || 0,\n            compressed: response.headers()['content-encoding']\n          });\n        }\n      });\n\n      await page.goto('http://localhost:5000/', { waitUntil: 'networkidle' });\n\n      // Calculate total bundle size\n      const totalJS = responses\n        .filter(r => r.url.includes('.js'))\n        .reduce((sum, r) => sum + parseInt(r.size || '0'), 0);\n\n      const totalCSS = responses\n        .filter(r => r.url.includes('.css'))\n        .reduce((sum, r) => sum + parseInt(r.size || '0'), 0);\n\n      console.log(`ðŸ“¦ Bundle sizes on ${viewport.name}:\n        JS: ${(totalJS / 1024).toFixed(2)} KB\n        CSS: ${(totalCSS / 1024).toFixed(2)} KB\n        Total: ${((totalJS + totalCSS) / 1024).toFixed(2)} KB`);\n\n      // Budget assertions (2.2MB total target)\n      expect(totalJS, `JS bundle too large: ${totalJS} bytes`).toBeLessThanOrEqual(2200 * 1024);\n    });\n  });\n}\n\n// Global performance summary test\ntest('Performance summary across all viewports', async () => {\n  // This test should run after all viewport tests\n  console.log(`\n  ðŸ“ˆ Performance Summary Complete\n  âœ… Tested ${VIEWPORTS.length} viewports\n  âœ… Tested ${CRITICAL_ROUTES.length} critical routes  \n  âœ… Verified CLS < ${PERFORMANCE_THRESHOLDS.CLS}\n  âœ… Verified LCP < ${PERFORMANCE_THRESHOLDS.LCP}ms\n  âœ… No horizontal scroll issues\n  âœ… Bundle size within budget\n  `);\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/performance-vitals.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":39,"column":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Vitals E2E Tests\n * Captures real Web Vitals metrics and enforces performance budgets\n * Fails CI if performance degradation is detected\n */\n\nimport { test, expect, Page } from '@playwright/test';\n\n// Performance thresholds matching our goals\nconst PERFORMANCE_BUDGETS = {\n  mobile: {\n    LCP: 2000,      // Largest Contentful Paint\n    CLS: 0.05,      // Cumulative Layout Shift  \n    FCP: 1800,      // First Contentful Paint\n    TTI: 2500,      // Time to Interactive\n    TBT: 200,       // Total Blocking Time\n    SI: 2500        // Speed Index\n  },\n  desktop: {\n    LCP: 1500,\n    CLS: 0.05,\n    FCP: 1200,\n    TTI: 2000,\n    TBT: 150,\n    SI: 2000\n  }\n};\n\n// Core pages to test\nconst CRITICAL_PAGES = [\n  { path: '/', name: 'Home' },\n  { path: '/dashboard', name: 'Dashboard' },\n  { path: '/insights', name: 'Insights' },\n  { path: '/calculators', name: 'Calculators' },\n  { path: '/savings', name: 'Savings' }\n];\n\n// Capture Web Vitals using the real web-vitals library\nasync function captureWebVitals(page: Page) {\n  // Inject web-vitals library and capture metrics\n  await page.addScriptTag({\n    url: 'https://unpkg.com/web-vitals@3/dist/web-vitals.iife.js'\n  });\n\n  const vitals = await page.evaluate(() => {\n    return new Promise((resolve) => {\n      const metrics: Record<string, number> = {};\n      let collectedCount = 0;\n      const expectedMetrics = 4; // LCP, CLS, FCP, TTI\n\n      function collectMetric(metric: any) {\n        metrics[metric.name] = metric.value;\n        collectedCount++;\n        \n        if (collectedCount >= expectedMetrics) {\n          resolve(metrics);\n        }\n      }\n\n      // @ts-ignore - web-vitals is loaded globally\n      if (typeof webVitals !== 'undefined') {\n        webVitals.onLCP(collectMetric);\n        webVitals.onCLS(collectMetric);\n        webVitals.onFCP(collectMetric);\n        \n        // Fallback resolve after timeout\n        setTimeout(() => resolve(metrics), 10000);\n      } else {\n        resolve({});\n      }\n    });\n  });\n\n  return vitals as Record<string, number>;\n}\n\n// Get performance navigation metrics\nasync function getNavigationMetrics(page: Page) {\n  return await page.evaluate(() => {\n    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    const paint = performance.getEntriesByType('paint');\n    \n    return {\n      domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n      loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\n      domInteractive: navigation.domInteractive - navigation.navigationStart,\n      firstPaint: paint.find(p => p.name === 'first-paint')?.startTime || 0,\n      firstContentfulPaint: paint.find(p => p.name === 'first-contentful-paint')?.startTime || 0,\n      resourceCount: performance.getEntriesByType('resource').length,\n      totalTransferSize: performance.getEntriesByType('resource').reduce((acc: number, r: any) => acc + (r.transferSize || 0), 0)\n    };\n  });\n}\n\n// Test performance on mobile viewports\ntest.describe('Mobile Performance Budget', () => {\n  test.beforeEach(async ({ page }) => {\n    // Configure mobile viewport\n    await page.setViewportSize({ width: 375, height: 812 });\n    await page.emulate({ \n      userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15',\n      viewport: { width: 375, height: 812 },\n      deviceScaleFactor: 3,\n      isMobile: true,\n      hasTouch: true\n    });\n  });\n\n  for (const route of CRITICAL_PAGES) {\n    test(`${route.name} page meets mobile performance budget`, async ({ page }) => {\n      console.log(`ðŸ” Testing mobile performance for ${route.name} (${route.path})`);\n      \n      // Navigate and measure\n      const startTime = Date.now();\n      await page.goto(route.path, { waitUntil: 'networkidle' });\n      const navigationTime = Date.now() - startTime;\n\n      // Capture Web Vitals\n      const vitals = await captureWebVitals(page);\n      const navMetrics = await getNavigationMetrics(page);\n\n      console.log(`ðŸ“Š ${route.name} Mobile Metrics:`, {\n        navigationTime,\n        vitals,\n        navMetrics\n      });\n\n      // Assert performance budgets\n      if (vitals.LCP) {\n        expect(vitals.LCP).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.mobile.LCP);\n      }\n      \n      if (vitals.CLS !== undefined) {\n        expect(vitals.CLS).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.mobile.CLS);\n      }\n      \n      if (vitals.FCP) {\n        expect(vitals.FCP).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.mobile.FCP);\n      }\n\n      // Navigation timing budgets\n      expect(navigationTime).toBeLessThanOrEqual(3000); // 3s total navigation\n      expect(navMetrics.domContentLoaded).toBeLessThanOrEqual(1500);\n      expect(navMetrics.resourceCount).toBeLessThanOrEqual(50);\n      expect(navMetrics.totalTransferSize).toBeLessThanOrEqual(2 * 1024 * 1024); // 2MB\n    });\n  }\n});\n\n// Test performance on desktop viewports  \ntest.describe('Desktop Performance Budget', () => {\n  test.beforeEach(async ({ page }) => {\n    // Configure desktop viewport\n    await page.setViewportSize({ width: 1440, height: 900 });\n  });\n\n  for (const route of CRITICAL_PAGES) {\n    test(`${route.name} page meets desktop performance budget`, async ({ page }) => {\n      console.log(`ðŸ” Testing desktop performance for ${route.name} (${route.path})`);\n      \n      // Navigate and measure\n      const startTime = Date.now();\n      await page.goto(route.path, { waitUntil: 'networkidle' });\n      const navigationTime = Date.now() - startTime;\n\n      // Capture Web Vitals\n      const vitals = await captureWebVitals(page);\n      const navMetrics = await getNavigationMetrics(page);\n\n      console.log(`ðŸ“Š ${route.name} Desktop Metrics:`, {\n        navigationTime,\n        vitals,\n        navMetrics\n      });\n\n      // Assert performance budgets (stricter for desktop)\n      if (vitals.LCP) {\n        expect(vitals.LCP).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.desktop.LCP);\n      }\n      \n      if (vitals.CLS !== undefined) {\n        expect(vitals.CLS).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.desktop.CLS);\n      }\n      \n      if (vitals.FCP) {\n        expect(vitals.FCP).toBeLessThanOrEqual(PERFORMANCE_BUDGETS.desktop.FCP);\n      }\n\n      // Navigation timing budgets\n      expect(navigationTime).toBeLessThanOrEqual(2000); // 2s total navigation\n      expect(navMetrics.domContentLoaded).toBeLessThanOrEqual(1000);\n      expect(navMetrics.resourceCount).toBeLessThanOrEqual(50);\n    });\n  }\n});\n\n// Chart loading performance specific tests\ntest.describe('Chart Loading Performance', () => {\n  test('Dashboard charts load within performance budget', async ({ page }) => {\n    await page.goto('/dashboard');\n    \n    // Wait for charts to appear\n    await page.waitForSelector('[data-testid=\"insights-card\"]', { timeout: 5000 });\n    \n    // Measure chart loading time\n    const chartLoadTime = await page.evaluate(() => {\n      return new Promise((resolve) => {\n        const observer = new PerformanceObserver((list) => {\n          const chartEntries = list.getEntries().filter(entry => \n            entry.name.includes('chart') || entry.name.includes('Chart')\n          );\n          \n          if (chartEntries.length > 0) {\n            const maxDuration = Math.max(...chartEntries.map(e => e.duration));\n            resolve(maxDuration);\n          }\n        });\n        \n        observer.observe({ entryTypes: ['measure', 'mark'] });\n        \n        // Fallback\n        setTimeout(() => resolve(0), 3000);\n      });\n    });\n\n    // Charts should load quickly\n    if (chartLoadTime > 0) {\n      expect(chartLoadTime).toBeLessThanOrEqual(500); // 500ms budget\n    }\n  });\n});\n\n// Network resource optimization tests\ntest.describe('Resource Optimization', () => {\n  test('Critical resources are preloaded', async ({ page }) => {\n    const response = await page.goto('/');\n    \n    // Check HTML contains preload hints\n    const html = await page.content();\n    expect(html).toContain('rel=\"preload\"');\n    expect(html).toContain('rel=\"preconnect\"');\n    expect(html).toContain('rel=\"prefetch\"');\n  });\n\n  test('Assets are compressed', async ({ page }) => {\n    // Intercept network requests\n    const responses: any[] = [];\n    \n    page.on('response', response => {\n      if (response.url().includes('.js') || response.url().includes('.css')) {\n        responses.push({\n          url: response.url(),\n          headers: response.headers()\n        });\n      }\n    });\n\n    await page.goto('/');\n    \n    // Check for compression headers\n    responses.forEach(response => {\n      if (response.url.includes('assets/')) {\n        expect(\n          response.headers['content-encoding'] === 'gzip' ||\n          response.headers['content-encoding'] === 'br'\n        ).toBeTruthy();\n      }\n    });\n  });\n\n  test('Bundle sizes within budget', async ({ page }) => {\n    const responses: any[] = [];\n    \n    page.on('response', async response => {\n      if (response.url().includes('.js') && response.url().includes('assets/')) {\n        const contentLength = response.headers()['content-length'];\n        if (contentLength) {\n          responses.push({\n            url: response.url(),\n            size: parseInt(contentLength)\n          });\n        }\n      }\n    });\n\n    await page.goto('/');\n    \n    // Check individual chunk sizes\n    responses.forEach(response => {\n      // No single chunk should exceed 500KB (compressed)\n      expect(response.size).toBeLessThanOrEqual(500 * 1024);\n    });\n  });\n});\n\n// User interaction performance\ntest.describe('Interaction Performance', () => {\n  test('Route navigation is fast', async ({ page }) => {\n    await page.goto('/');\n    \n    // Measure navigation to different routes\n    const routes = ['/dashboard', '/insights', '/calculators'];\n    \n    for (const route of routes) {\n      const startTime = Date.now();\n      await page.click(`[href=\"${route}\"]`);\n      await page.waitForLoadState('networkidle');\n      const navTime = Date.now() - startTime;\n      \n      console.log(`Navigation to ${route}: ${navTime}ms`);\n      expect(navTime).toBeLessThanOrEqual(1000); // 1s budget for SPA navigation\n    }\n  });\n\n  test('Interactive elements respond quickly', async ({ page }) => {\n    await page.goto('/calculators');\n    \n    // Test calculator interaction performance\n    const input = page.locator('input[type=\"number\"]').first();\n    \n    const startTime = Date.now();\n    await input.fill('100000');\n    await input.blur();\n    \n    // Wait for calculation to complete\n    await page.waitForTimeout(100);\n    const responseTime = Date.now() - startTime;\n    \n    console.log(`Calculator response time: ${responseTime}ms`);\n    expect(responseTime).toBeLessThanOrEqual(300); // 300ms budget\n  });\n});\n\n// Memory leak detection\ntest.describe('Memory Performance', () => {\n  test('No memory leaks during navigation', async ({ page }) => {\n    await page.goto('/');\n    \n    // Get initial memory usage\n    const initialMemory = await page.evaluate(() => {\n      return (performance as any).memory?.usedJSHeapSize || 0;\n    });\n\n    // Navigate through several pages\n    const routes = ['/dashboard', '/insights', '/calculators', '/savings', '/'];\n    \n    for (const route of routes) {\n      await page.goto(route);\n      await page.waitForTimeout(500);\n    }\n\n    // Check final memory usage\n    const finalMemory = await page.evaluate(() => {\n      return (performance as any).memory?.usedJSHeapSize || 0;\n    });\n\n    if (initialMemory > 0 && finalMemory > 0) {\n      const memoryIncrease = finalMemory - initialMemory;\n      const increasePercent = (memoryIncrease / initialMemory) * 100;\n      \n      console.log(`Memory usage: ${initialMemory} -> ${finalMemory} (+${increasePercent.toFixed(1)}%)`);\n      \n      // Memory should not increase by more than 50% during navigation\n      expect(increasePercent).toBeLessThanOrEqual(50);\n    }\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/profile-navigation-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/quick-access-rail.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/quick-access-tablet.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/quick-hook-validation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":7,"column":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\nimport { HookValidationMonitor, commonTestScenarios } from './hook-validation-config';\n\ntest.describe('Quick Hook Validation', () => {\n  test.beforeEach(async ({ page }) => {\n    // Reset hook violations tracking\n    const hookViolations: string[] = [];\n  });\n\n  test('should quickly validate basic navigation without hook violations', async ({ page }) => {\n    console.log('ðŸš€ Starting quick hook validation test...');\n    \n    const monitor = new HookValidationMonitor(page);\n    \n    // Monitor for hook violations\n    page.on('console', (msg) => {\n      if (msg.type() === 'error' && msg.text().includes('rendered more hooks')) {\n        hookViolations.push(msg.text());\n        console.error('ðŸš¨ HOOK VIOLATION DETECTED:', msg.text());\n      }\n    });\n    \n    // Quick navigation test\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    console.log('âœ… Initial page load - OK');\n    \n    // Test basic navigation sequence\n    const basicTabs = ['dashboard', 'accounts', 'transactions', 'insights'];\n    \n    for (const tab of basicTabs) {\n      console.log(`ðŸ”„ Testing navigation to: ${tab}`);\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForLoadState('networkidle');\n      await page.waitForTimeout(300);\n    }\n    \n    console.log('âœ… Basic navigation sequence - OK');\n    \n    // Test mobile viewport change\n    console.log('ðŸ“± Testing mobile viewport...');\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.goto('/?tab=dashboard');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(500);\n    \n    await page.goto('/?tab=transactions');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(300);\n    \n    console.log('âœ… Mobile viewport test - OK');\n    \n    // Back to desktop\n    await page.setViewportSize({ width: 1200, height: 800 });\n    await page.waitForTimeout(200);\n    \n    // Test rapid navigation\n    console.log('âš¡ Testing rapid navigation...');\n    for (let i = 0; i < 5; i++) {\n      const tab = basicTabs[i % basicTabs.length];\n      await page.goto(`/?tab=${tab}`);\n      await page.waitForTimeout(100);\n    }\n    \n    // Final settlement\n    await page.waitForTimeout(2000);\n    console.log('âœ… Rapid navigation test - OK');\n    \n    // Generate final report\n    const validation = await monitor.validateHookIntegrity();\n    const report = monitor.generateReport();\n    \n    console.log('ðŸ“Š QUICK VALIDATION REPORT:');\n    console.log(report);\n    \n    // Assert no hook violations\n    expect(hookViolations, `Hook violations detected: ${JSON.stringify(hookViolations)}`).toHaveLength(0);\n    expect(validation.violations, `Monitor detected violations: ${JSON.stringify(validation.violations)}`).toHaveLength(0);\n    expect(validation.passed, 'Quick validation should pass').toBe(true);\n    \n    console.log('ðŸŽ‰ Quick hook validation completed successfully!');\n  });\n  \n  test('should reproduce specific hook violation scenario', async ({ page }) => {\n    console.log('ðŸ”¬ Attempting to reproduce hook violation scenario...');\n    \n    let specificHookError = '';\n    \n    page.on('console', (msg) => {\n      if (msg.type() === 'error' && msg.text().includes('rendered more hooks than during the previous render')) {\n        specificHookError = msg.text();\n        console.error('ðŸŽ¯ SPECIFIC HOOK VIOLATION REPRODUCED:', msg.text());\n      }\n    });\n    \n    // Reproduce the exact problematic scenario\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Navigate to insights (commonly problematic)\n    await page.goto('/?tab=insights');\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(1000);\n    \n    // Mobile viewport change during navigation\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.goto('/?tab=dashboard');\n    await page.waitForTimeout(200);\n    \n    // Back to desktop quickly\n    await page.setViewportSize({ width: 1200, height: 800 });\n    await page.goto('/?tab=transactions');\n    await page.waitForTimeout(200);\n    \n    // Rapid navigation\n    await page.goto('/?tab=insights');\n    await page.waitForTimeout(100);\n    await page.goto('/?tab=dashboard');\n    await page.waitForTimeout(100);\n    \n    // Final check\n    await page.waitForTimeout(2000);\n    \n    if (specificHookError) {\n      console.error('âŒ Hook violation reproduced:', specificHookError);\n      // This test should fail if we reproduce the error\n      throw new Error(`Hook violation reproduced: ${specificHookError}`);\n    } else {\n      console.log('âœ… No hook violations detected - scenario appears to be fixed!');\n      expect(specificHookError).toBe('');\n    }\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/quick-validation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/responsive-overhaul-validation.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":118,"column":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\n/**\n * Responsive Overhaul Validation Test Suite\n * Validates mobile, tablet, desktop, and ultrawide viewport compliance\n * Focuses on More drawer components and global consistency\n */\n\nconst viewports = [\n  { name: 'Mobile Small', width: 320, height: 568 },\n  { name: 'Mobile Large', width: 480, height: 854 },\n  { name: 'Tablet', width: 768, height: 1024 },\n  { name: 'Desktop', width: 1024, height: 768 },\n  { name: 'Large Desktop', width: 1440, height: 900 },\n  { name: 'Ultra Wide', width: 1920, height: 1080 },\n  { name: 'Ultra Wide XL', width: 2560, height: 1440 }\n];\n\nconst moreDrawerRoutes = [\n  { path: '/calculators', name: 'Calculators Hub' },\n  { path: '/profile', name: 'Profile Settings' },\n  { path: '/transaction-demo', name: 'Transaction Demo' }\n];\n\ntest.describe('Responsive Overhaul Validation - More Drawer Priority', () => {\n  \n  test.beforeEach(async ({ page }) => {\n    // Set up performance monitoring\n    await page.goto('/', { waitUntil: 'networkidle' });\n  });\n\n  test('should handle More drawer components across all viewports', async ({ page }) => {\n    console.log('ðŸ” Testing More drawer responsive compliance...');\n    \n    for (const route of moreDrawerRoutes) {\n      console.log(`ðŸ“± Testing ${route.name} across viewports...`);\n      \n      for (const viewport of viewports) {\n        console.log(`  ðŸ“ Testing ${viewport.name} (${viewport.width}x${viewport.height})`);\n        \n        await page.setViewportSize({ width: viewport.width, height: viewport.height });\n        await page.goto(route.path, { waitUntil: 'networkidle', timeout: 10000 });\n        await page.waitForTimeout(1000);\n        \n        // Check for horizontal overflow\n        const hasOverflow = await page.evaluate(() => {\n          return document.body.scrollWidth > window.innerWidth ||\n                 document.documentElement.scrollWidth > window.innerWidth;\n        });\n        \n        expect(hasOverflow).toBeFalsy();\n        \n        // Validate responsive grid layouts\n        const gridAnalysis = await page.evaluate(() => {\n          const grids = document.querySelectorAll('[class*=\"grid\"]');\n          const responsiveGrids = Array.from(grids).filter(grid => \n            Array.from(grid.classList).some(cls => \n              cls.includes('sm:') || cls.includes('md:') || cls.includes('lg:') || \n              cls.includes('xl:') || cls.includes('2xl:')\n            )\n          );\n          \n          return {\n            totalGrids: grids.length,\n            responsiveGrids: responsiveGrids.length,\n            hasResponsiveClasses: responsiveGrids.length > 0\n          };\n        });\n        \n        expect(gridAnalysis.hasResponsiveClasses).toBeTruthy();\n        expect(gridAnalysis.responsiveGrids).toBeGreaterThan(0);\n        \n        // Check for proper spacing and typography scaling\n        const layoutMetrics = await page.evaluate(() => {\n          const main = document.querySelector('main') || document.body;\n          const headings = document.querySelectorAll('h1, h2, h3');\n          const buttons = document.querySelectorAll('button');\n          \n          return {\n            mainWidth: main.offsetWidth,\n            viewportWidth: window.innerWidth,\n            hasHeadings: headings.length > 0,\n            buttonCount: buttons.length,\n            spaceUtilization: main.offsetWidth / window.innerWidth\n          };\n        });\n        \n        expect(layoutMetrics.spaceUtilization).toBeGreaterThan(0.3);\n        expect(layoutMetrics.spaceUtilization).toBeLessThanOrEqual(1.0);\n        \n        console.log(`    âœ… ${viewport.name}: Layout stable, utilization ${Math.round(layoutMetrics.spaceUtilization * 100)}%`);\n      }\n      \n      console.log(`  ðŸŽ¯ ${route.name}: All viewports passed`);\n    }\n  });\n\n  test('should maintain performance budgets across viewports', async ({ page }) => {\n    console.log('âš¡ Testing performance budgets...');\n    \n    const budgets = {\n      cls: 0.1,     // Cumulative Layout Shift\n      lcp: 2500,    // Largest Contentful Paint (ms)\n      fid: 100      // First Input Delay (ms)\n    };\n    \n    for (const viewport of viewports.slice(0, 4)) { // Test key viewports\n      console.log(`ðŸ“Š Performance testing at ${viewport.width}px...`);\n      \n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      \n      // Navigate and measure performance\n      await page.goto('/calculators', { waitUntil: 'networkidle' });\n      \n      const performanceMetrics = await page.evaluate(() => {\n        return new Promise(resolve => {\n          // Simplified performance measurement\n          const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n          \n          setTimeout(() => {\n            resolve({\n              loadTime: navigation.loadEventEnd - navigation.loadEventStart,\n              domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n              firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0\n            });\n          }, 1000);\n        });\n      });\n      \n      // Basic performance validation\n      expect(performanceMetrics.loadTime).toBeLessThan(3000);\n      console.log(`  âš¡ Load time: ${Math.round(performanceMetrics.loadTime)}ms`);\n    }\n  });\n\n  test('should handle grid responsive breakpoints correctly', async ({ page }) => {\n    console.log('ðŸŽ¯ Testing grid breakpoint transitions...');\n    \n    await page.goto('/calculators');\n    \n    const breakpointTests = [\n      { width: 320, expectedCols: 1, name: 'Mobile' },\n      { width: 640, expectedCols: 2, name: 'Small' },\n      { width: 768, expectedCols: 2, name: 'Tablet' },\n      { width: 1024, expectedCols: 3, name: 'Desktop' },\n      { width: 1280, expectedCols: 4, name: 'Large' },\n      { width: 1920, expectedCols: 5, name: 'Ultra-wide' }\n    ];\n    \n    for (const test of breakpointTests) {\n      await page.setViewportSize({ width: test.width, height: 800 });\n      await page.waitForTimeout(500);\n      \n      const gridLayout = await page.evaluate(() => {\n        const calculatorGrid = document.querySelector('[data-testid=\"calculators-grid\"]');\n        if (!calculatorGrid) return { columns: 0, items: 0 };\n        \n        const computedStyle = window.getComputedStyle(calculatorGrid);\n        const gridCols = computedStyle.gridTemplateColumns;\n        const columnCount = gridCols.split(' ').length;\n        const itemCount = calculatorGrid.children.length;\n        \n        return {\n          columns: columnCount,\n          items: itemCount,\n          gridCols: gridCols\n        };\n      });\n      \n      console.log(`  ðŸ“ ${test.name} (${test.width}px): ${gridLayout.columns} columns`);\n      // Allow some flexibility in column count based on content\n      expect(gridLayout.columns).toBeGreaterThanOrEqual(1);\n      expect(gridLayout.columns).toBeLessThanOrEqual(6);\n    }\n  });\n\n  test('should validate unified design tokens usage', async ({ page }) => {\n    console.log('ðŸŽ¨ Testing design token compliance...');\n    \n    await page.goto('/calculators');\n    await page.waitForTimeout(1000);\n    \n    const tokenCompliance = await page.evaluate(() => {\n      const cards = document.querySelectorAll('[data-testid=\"calculator-card\"]');\n      const backgrounds = Array.from(cards).map(card => {\n        const styles = window.getComputedStyle(card);\n        return {\n          background: styles.backgroundColor,\n          border: styles.borderColor,\n          borderRadius: styles.borderRadius\n        };\n      });\n      \n      // Check for consistent styling\n      const uniqueBackgrounds = new Set(backgrounds.map(b => b.background));\n      const uniqueBorders = new Set(backgrounds.map(b => b.border));\n      const uniqueRadius = new Set(backgrounds.map(b => b.borderRadius));\n      \n      return {\n        cardCount: cards.length,\n        consistentBackground: uniqueBackgrounds.size <= 2, // Allow for hover states\n        consistentBorders: uniqueBorders.size <= 2,\n        consistentRadius: uniqueRadius.size <= 2,\n        backgrounds: Array.from(uniqueBackgrounds),\n        borders: Array.from(uniqueBorders)\n      };\n    });\n    \n    expect(tokenCompliance.cardCount).toBeGreaterThan(5);\n    expect(tokenCompliance.consistentBackground).toBeTruthy();\n    expect(tokenCompliance.consistentBorders).toBeTruthy();\n    expect(tokenCompliance.consistentRadius).toBeTruthy();\n    \n    console.log(`  âœ… Token compliance: ${tokenCompliance.cardCount} cards validated`);\n  });\n\n  test('should ensure touch-friendly targets on mobile', async ({ page }) => {\n    console.log('ðŸ‘† Testing touch target accessibility...');\n    \n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.goto('/calculators');\n    await page.waitForTimeout(1000);\n    \n    const touchTargets = await page.evaluate(() => {\n      const interactiveElements = document.querySelectorAll('button, a, [role=\"button\"]');\n      \n      return Array.from(interactiveElements).map(element => {\n        const rect = element.getBoundingClientRect();\n        return {\n          width: rect.width,\n          height: rect.height,\n          area: rect.width * rect.height,\n          isAccessible: rect.width >= 44 && rect.height >= 44\n        };\n      });\n    });\n    \n    const accessibleTargets = touchTargets.filter(target => target.isAccessible);\n    const accessibilityRatio = accessibleTargets.length / touchTargets.length;\n    \n    // Expect at least 80% of interactive elements to meet WCAG guidelines\n    expect(accessibilityRatio).toBeGreaterThan(0.8);\n    \n    console.log(`  âœ… Touch accessibility: ${Math.round(accessibilityRatio * 100)}% compliant`);\n  });\n\n  test('should handle extreme viewport sizes gracefully', async ({ page }) => {\n    console.log('ðŸŒŠ Testing extreme viewport handling...');\n    \n    const extremeViewports = [\n      { width: 280, height: 653, name: 'Very Narrow' },\n      { width: 3440, height: 1440, name: 'Ultra-wide Monitor' },\n      { width: 1024, height: 2000, name: 'Very Tall' }\n    ];\n    \n    for (const viewport of extremeViewports) {\n      console.log(`  ðŸ”¬ Testing ${viewport.name}: ${viewport.width}x${viewport.height}`);\n      \n      await page.setViewportSize({ width: viewport.width, height: viewport.height });\n      await page.goto('/calculators', { waitUntil: 'networkidle' });\n      await page.waitForTimeout(1000);\n      \n      const extremeLayoutCheck = await page.evaluate(() => {\n        const body = document.body;\n        const main = document.querySelector('main') || body;\n        \n        return {\n          hasHorizontalOverflow: body.scrollWidth > window.innerWidth,\n          mainVisible: main.offsetWidth > 0 && main.offsetHeight > 0,\n          contentAccessible: document.querySelector('[data-testid=\"calculators-grid\"]') !== null\n        };\n      });\n      \n      expect(extremeLayoutCheck.hasHorizontalOverflow).toBeFalsy();\n      expect(extremeLayoutCheck.mainVisible).toBeTruthy();\n      expect(extremeLayoutCheck.contentAccessible).toBeTruthy();\n      \n      console.log(`    âœ… ${viewport.name}: Layout stable and accessible`);\n    }\n  });\n\n});\n\ntest.describe('Global Responsive Consistency', () => {\n  \n  test('should maintain navigation consistency across pages', async ({ page }) => {\n    console.log('ðŸ§­ Testing navigation consistency...');\n    \n    const testViewports = [\n      { width: 375, height: 667 },\n      { width: 768, height: 1024 },\n      { width: 1280, height: 800 }\n    ];\n    \n    const routes = ['/', '/calculators', '/profile'];\n    \n    for (const viewport of testViewports) {\n      console.log(`  ðŸ“± Testing navigation at ${viewport.width}px...`);\n      \n      await page.setViewportSize(viewport);\n      \n      for (const route of routes) {\n        await page.goto(route, { waitUntil: 'networkidle' });\n        await page.waitForTimeout(500);\n        \n        const navState = await page.evaluate(() => {\n          const nav = document.querySelector('nav, [role=\"navigation\"]');\n          const mobileMenu = document.querySelector('[aria-label*=\"menu\"], [aria-label*=\"Menu\"]');\n          const bottomNav = document.querySelector('[class*=\"bottom\"], [class*=\"dock\"]');\n          \n          return {\n            hasNavigation: nav !== null,\n            hasMobileMenu: mobileMenu !== null,\n            hasBottomNav: bottomNav !== null,\n            navVisible: nav ? nav.offsetWidth > 0 : false\n          };\n        });\n        \n        expect(navState.hasNavigation).toBeTruthy();\n        console.log(`    ðŸ“ ${route}: Navigation present and functional`);\n      }\n    }\n  });\n\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/responsive-validation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/safe-area-dock-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/security.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":27,"column":60}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Security E2E Tests', () => {\n  test.beforeEach(async ({ page }) => {\n    await page.goto('/');\n  });\n\n  test('should not expose sensitive data in localStorage', async ({ page }) => {\n    // Navigate through the app to trigger some data storage\n    await page.click('[data-testid=\"nav-accounts\"]');\n    await page.click('[data-testid=\"nav-insights\"]');\n    await page.click('[data-testid=\"nav-dashboard\"]');\n\n    // Check localStorage for unencrypted sensitive data\n    const localStorage = await page.evaluate(() => {\n      const items = {};\n      for (let i = 0; i < window.localStorage.length; i++) {\n        const key = window.localStorage.key(i);\n        if (key) {\n          items[key] = window.localStorage.getItem(key);\n        }\n      }\n      return items;\n    });\n\n    // Verify that financial data is not stored in plain text\n    for (const [key, value] of Object.entries(localStorage as Record<string, string>)) {\n      if (value && typeof value === 'string') {\n        // Should not contain obvious financial patterns\n        expect(value).not.toMatch(/\\$[\\d,]+\\.\\d{2}/); // Currency amounts\n        expect(value).not.toMatch(/\\b\\d{4}-\\d{4}-\\d{4}-\\d{4}\\b/); // Credit card numbers\n        expect(value).not.toMatch(/\\b\\d{3}-\\d{2}-\\d{4}\\b/); // SSN patterns\n        \n        // If it contains encrypted data, it should look encrypted\n        if (key.includes('secure') || key.includes('encrypted')) {\n          expect(value).toMatch(/^[A-Za-z0-9+/=]+$/); // Base64-like encrypted data\n        }\n      }\n    }\n  });\n\n  test('should handle session timeout', async ({ page }) => {\n    // Navigate to a secure area\n    await page.click('[data-testid=\"nav-accounts\"]');\n    \n    // Simulate session timeout by manipulating localStorage/sessionStorage\n    await page.evaluate(() => {\n      // Clear session data as if it expired\n      window.localStorage.removeItem('session_token');\n      window.sessionStorage.clear();\n    });\n    \n    // Navigate to another page\n    await page.click('[data-testid=\"nav-insights\"]');\n    \n    // App should handle missing session gracefully\n    // Should not crash and should still be functional with default/demo data\n    await expect(page.locator('body')).toBeVisible();\n  });\n\n  test('should not expose API keys or sensitive config', async ({ page }) => {\n    // Check that no sensitive configuration is exposed in the page source\n    const pageContent = await page.content();\n    \n    // Should not contain common sensitive patterns\n    expect(pageContent).not.toMatch(/api[_-]?key/i);\n    expect(pageContent).not.toMatch(/secret[_-]?key/i);\n    expect(pageContent).not.toMatch(/private[_-]?key/i);\n    expect(pageContent).not.toMatch(/password/i);\n    expect(pageContent).not.toMatch(/token.*[a-zA-Z0-9]{20,}/);\n  });\n\n  test('should validate HTTPS usage in production', async ({ page }) => {\n    // Note: This would be more relevant in a production environment\n    // For now, we just check that the app doesn't break with security headers\n    \n    await page.goto('/');\n    await expect(page.locator('h1')).toContainText('Vueni');\n    \n    // Check that the app loads properly (basic security test)\n    await expect(page.locator('[data-testid=\"transaction-list\"]')).toBeVisible();\n  });\n\n  test('should sanitize user inputs', async ({ page }) => {\n    // Navigate to a page with input fields (if any)\n    await page.goto('/');\n    \n    // Look for any input fields\n    const inputs = page.locator('input, textarea');\n    const inputCount = await inputs.count();\n    \n    if (inputCount > 0) {\n      // Test XSS prevention on first input found\n      const firstInput = inputs.first();\n      await firstInput.fill('<script>alert(\"xss\")</script>');\n      \n      // Check that script tags are not executed\n      const alertHandled = new Promise((resolve) => {\n        page.on('dialog', async (dialog) => {\n          await dialog.dismiss();\n          resolve(false); // Alert shouldn't appear if properly sanitized\n        });\n        setTimeout(() => resolve(true), 1000); // No alert = good\n      });\n      \n      await expect(await alertHandled).toBe(true);\n    }\n  });\n\n  test('should not leak data through console errors', async ({ page }) => {\n    const consoleErrors: string[] = [];\n    \n    page.on('console', (msg) => {\n      if (msg.type() === 'error') {\n        consoleErrors.push(msg.text());\n      }\n    });\n    \n    // Navigate through the app\n    await page.click('[data-testid=\"nav-accounts\"]');\n    await page.click('[data-testid=\"nav-insights\"]');\n    await page.click('[data-testid=\"nav-transactions\"]');\n    await page.click('[data-testid=\"nav-dashboard\"]');\n    \n    // Check that console errors don't contain sensitive information\n    for (const error of consoleErrors) {\n      // Should not contain financial data patterns\n      expect(error).not.toMatch(/\\$[\\d,]+\\.\\d{2}/);\n      expect(error).not.toMatch(/\\b\\d{4}-\\d{4}-\\d{4}-\\d{4}\\b/);\n      expect(error).not.toMatch(/api[_-]?key/i);\n    }\n  });\n\n  test('should handle malformed URLs gracefully', async ({ page }) => {\n    // Test various malformed URLs to ensure no sensitive errors are exposed\n    const malformedUrls = [\n      '/../../../../etc/passwd',\n      '/<script>alert(\"xss\")</script>',\n      '/admin',\n      '/api/users',\n      '/config',\n    ];\n    \n    for (const url of malformedUrls) {\n      await page.goto(url, { waitUntil: 'networkidle' });\n      \n      // Should not crash or expose sensitive information\n      const pageContent = await page.textContent('body');\n      expect(pageContent).not.toMatch(/error.*password/i);\n      expect(pageContent).not.toMatch(/error.*key/i);\n      expect(pageContent).not.toMatch(/stack trace/i);\n    }\n  });\n\n  test('should properly handle encrypted storage operations', async ({ page }) => {\n    // Test that the app can handle encrypted storage operations\n    await page.evaluate(() => {\n      // Try to access the SecureStorage functionality\n      const testData = { amount: 1000, account: 'test' };\n      \n      // This should use our SecureStorage class if implemented correctly\n      window.localStorage.setItem('test_encrypted_data', JSON.stringify(testData));\n    });\n    \n    // Navigate through app to trigger storage reads\n    await page.click('[data-testid=\"nav-accounts\"]');\n    await page.click('[data-testid=\"nav-dashboard\"]');\n    \n    // App should continue to function normally\n    await expect(page.locator('[data-testid=\"transaction-list\"]')).toBeVisible();\n    \n    // Clean up test data\n    await page.evaluate(() => {\n      window.localStorage.removeItem('test_encrypted_data');\n    });\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/tablet-quick-access.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/transaction-alignment.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/transactions-shipping-payment.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/transactions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/ui-refactor-validation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/ultra-analytics-bulletproof.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":31,"column":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('ðŸ”¥ Ultra-Deep Analytics Bulletproof Tests', () => {\n  const viewports = [\n    { name: 'Mobile', width: 390, height: 844 },\n    { name: 'Tablet', width: 834, height: 1194 },\n    { name: 'Desktop', width: 1440, height: 900 },\n    { name: 'Ultra-wide', width: 2560, height: 1440 }\n  ];\n\n  const DESTRUCTURING_ERROR_PATTERNS = [\n    'Right side of assignment cannot be destructured',\n    'Cannot read property',\n    'Cannot read properties of undefined',\n    'Cannot destructure property',\n    'Cannot destructure',\n    'undefined is not iterable',\n    'null is not iterable',\n    'Cannot access before initialization',\n    'TypeError: undefined',\n    'TypeError: null'\n  ];\n\n  viewports.forEach(({ name, width, height }) => {\n    test.describe(`${name} (${width}x${height})`, () => {\n      test.beforeEach(async ({ page }) => {\n        await page.setViewportSize({ width, height });\n      });\n\n      test('BULLETPROOF: Analytics navigation never crashes', async ({ page }) => {\n        const consoleErrors: string[] = [];\n        const jsErrors: string[] = [];\n        \n        // Capture all errors\n        page.on('console', msg => {\n          if (msg.type() === 'error') {\n            consoleErrors.push(msg.text());\n          }\n        });\n        \n        page.on('pageerror', error => {\n          jsErrors.push(error.message);\n        });\n\n        // Navigate to analytics via multiple paths\n        await page.goto('/');\n        await page.waitForLoadState('networkidle');\n\n        // Path 1: Direct navigation\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n        await page.waitForTimeout(2000); // Let all components fully render\n\n        // Path 2: Tab navigation\n        await page.goto('/');\n        await page.waitForLoadState('networkidle');\n        await page.click('button:has-text(\"Analytics\")');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n        await page.waitForTimeout(2000);\n\n        // Path 3: Query parameter navigation\n        await page.goto('/?view=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n        await page.waitForTimeout(2000);\n\n        // Filter for destructuring-specific errors\n        const destructuringErrors = [...consoleErrors, ...jsErrors].filter(error =>\n          DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n            error.toLowerCase().includes(pattern.toLowerCase())\n          )\n        );\n\n        // âœ… ZERO TOLERANCE for destructuring errors\n        expect(destructuringErrors, `Found destructuring errors: ${destructuringErrors.join(', ')}`).toHaveLength(0);\n      });\n\n      test('BULLETPROOF: All chart interactions are safe', async ({ page }) => {\n        const errors: string[] = [];\n        page.on('console', msg => msg.type() === 'error' && errors.push(msg.text()));\n        page.on('pageerror', error => errors.push(error.message));\n\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // Test all chart type switches\n        const chartButtons = ['Net Worth', 'Cash Flow', 'Spending', 'Portfolio'];\n        for (const chartName of chartButtons) {\n          const button = page.locator(`button:has-text(\"${chartName}\")`);\n          if (await button.isVisible()) {\n            await button.click();\n            await page.waitForTimeout(1000);\n            // Verify chart renders\n            await expect(page.locator('.recharts-wrapper')).toBeVisible();\n          }\n        }\n\n        // Test timeframe selectors\n        const timeframes = ['1M', '3M', '6M', '1Y'];\n        for (const timeframe of timeframes) {\n          const button = page.locator(`button:has-text(\"${timeframe}\")`);\n          if (await button.isVisible()) {\n            await button.click();\n            await page.waitForTimeout(1500);\n            await expect(page.locator('.recharts-wrapper')).toBeVisible();\n          }\n        }\n\n        // âœ… No errors during interactions\n        const destructuringErrors = errors.filter(error =>\n          DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n            error.toLowerCase().includes(pattern.toLowerCase())\n          )\n        );\n        expect(destructuringErrors).toHaveLength(0);\n      });\n\n      test('BULLETPROOF: Network failure graceful degradation', async ({ page }) => {\n        const errors: string[] = [];\n        page.on('console', msg => msg.type() === 'error' && errors.push(msg.text()));\n        page.on('pageerror', error => errors.push(error.message));\n\n        // Simulate slow/failing network\n        await page.route('**/*', async route => {\n          if (Math.random() < 0.3) { // 30% failure rate\n            await route.abort();\n          } else {\n            await new Promise(resolve => setTimeout(resolve, 200));\n            await route.continue();\n          }\n        });\n\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 20000 });\n\n        // Even with network issues, should show fallback data\n        await expect(page.locator('.recharts-wrapper, text=\"No Dashboard Data\"')).toBeVisible();\n\n        // âœ… Network failures don't cause destructuring crashes\n        const destructuringErrors = errors.filter(error =>\n          DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n            error.toLowerCase().includes(pattern.toLowerCase())\n          )\n        );\n        expect(destructuringErrors).toHaveLength(0);\n      });\n\n      test('BULLETPROOF: Rapid tab switching stress test', async ({ page }) => {\n        const errors: string[] = [];\n        page.on('console', msg => msg.type() === 'error' && errors.push(msg.text()));\n        page.on('pageerror', error => errors.push(error.message));\n\n        await page.goto('/');\n        await page.waitForLoadState('networkidle');\n\n        // Rapid switching between tabs\n        const tabs = ['dashboard', 'accounts', 'analytics', 'insights', 'budget'];\n        for (let cycle = 0; cycle < 3; cycle++) {\n          for (const tab of tabs) {\n            await page.goto(`/?tab=${tab}`);\n            if (tab === 'analytics') {\n              await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 10000 });\n            }\n            await page.waitForTimeout(500);\n          }\n        }\n\n        // âœ… Rapid switching doesn't break Analytics\n        const destructuringErrors = errors.filter(error =>\n          DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n            error.toLowerCase().includes(pattern.toLowerCase())\n          )\n        );\n        expect(destructuringErrors).toHaveLength(0);\n      });\n\n      test('BULLETPROOF: Page refresh and hot reload resilience', async ({ page }) => {\n        const errors: string[] = [];\n        page.on('console', msg => msg.type() === 'error' && errors.push(msg.text()));\n        page.on('pageerror', error => errors.push(error.message));\n\n        // Initial load\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // Force refresh\n        await page.reload();\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // Hot reload simulation (navigate away and back)\n        await page.goto('/');\n        await page.waitForTimeout(1000);\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // âœ… Refresh cycles are bulletproof\n        const destructuringErrors = errors.filter(error =>\n          DESTRUCTURING_ERROR_PATTERNS.some(pattern => \n            error.toLowerCase().includes(pattern.toLowerCase())\n          )\n        );\n        expect(destructuringErrors).toHaveLength(0);\n      });\n\n      test('BULLETPROOF: Memory leak and performance validation', async ({ page }) => {\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // Measure performance metrics\n        const metrics = await page.evaluate(() => {\n          const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n          return {\n            loadTime: navigation.loadEventEnd - navigation.loadEventStart,\n            domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n            memoryUsed: (performance as any).memory?.usedJSHeapSize || 0\n          };\n        });\n\n        // âœ… Performance within acceptable bounds\n        expect(metrics.loadTime).toBeLessThan(5000); // < 5s load time\n        expect(metrics.domContentLoaded).toBeLessThan(3000); // < 3s DOM ready\n        if (metrics.memoryUsed > 0) {\n          expect(metrics.memoryUsed).toBeLessThan(50 * 1024 * 1024); // < 50MB\n        }\n      });\n\n      test('BULLETPROOF: Accessibility and dark mode consistency', async ({ page }) => {\n        await page.goto('/?tab=analytics');\n        await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n\n        // Verify dark mode colors\n        const backgroundColor = await page.locator('body').evaluate(el => \n          getComputedStyle(el).backgroundColor\n        );\n        expect(backgroundColor).toContain('rgb(3, 7, 18)'); // Dark background\n\n        // Check for light mode artifacts (should be none)\n        const lightArtifacts = page.locator('.bg-white:not([class*=\"bg-white/\"])')\n        expect(await lightArtifacts.count()).toBe(0);\n\n        // âœ… Color contrast accessibility\n        const chartText = page.locator('.recharts-cartesian-axis text').first();\n        if (await chartText.isVisible()) {\n          const textColor = await chartText.evaluate(el => getComputedStyle(el).fill);\n          expect(textColor).toMatch(/#[a-fA-F0-9]{6}|rgb/); // Valid color format\n        }\n      });\n    });\n  });\n\n  test('REGRESSION: Visual consistency across viewports', async ({ page }) => {\n    const screenshots: Buffer[] = [];\n    \n    for (const { name, width, height } of viewports) {\n      await page.setViewportSize({ width, height });\n      await page.goto('/?tab=analytics');\n      await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n      await page.waitForTimeout(3000); // Ensure animations complete\n      \n      const screenshot = await page.screenshot({ fullPage: true });\n      screenshots.push(screenshot);\n      \n      // Basic layout verification\n      await expect(page.locator('h1:has-text(\"Financial Analytics Dashboard\")')).toBeVisible();\n      await expect(page.locator('.recharts-wrapper')).toBeVisible();\n    }\n\n    // âœ… All viewports render successfully\n    expect(screenshots).toHaveLength(viewports.length);\n  });\n\n  test('PERFORMANCE: Bundle size and Lighthouse metrics', async ({ page }) => {\n    // Enable performance monitoring\n    const client = await page.context().newCDPSession(page);\n    await client.send('Performance.enable');\n    \n    await page.goto('/?tab=analytics');\n    await page.waitForSelector('h1:has-text(\"Financial Analytics Dashboard\")', { timeout: 15000 });\n    \n    // Wait for all resources to load\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(5000);\n    \n    // Check Core Web Vitals\n    const vitals = await page.evaluate(() => {\n      return new Promise((resolve) => {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const vitals: any = {};\n          \n          entries.forEach((entry) => {\n            if (entry.name === 'LCP') vitals.lcp = entry.value;\n            if (entry.name === 'FID') vitals.fid = entry.value;\n            if (entry.name === 'CLS') vitals.cls = entry.value;\n          });\n          \n          resolve(vitals);\n        });\n        \n        observer.observe({ entryTypes: ['largest-contentful-paint', 'first-input', 'layout-shift'] });\n        \n        // Fallback timeout\n        setTimeout(() => resolve({}), 2000);\n      });\n    });\n\n    console.log('Core Web Vitals:', vitals);\n    \n    // âœ… Performance targets met\n    // LCP < 2.5s, FID < 100ms, CLS < 0.1\n    if ((vitals as any).lcp) expect((vitals as any).lcp).toBeLessThan(2500);\n    if ((vitals as any).fid) expect((vitals as any).fid).toBeLessThan(100);\n    if ((vitals as any).cls) expect((vitals as any).cls).toBeLessThan(0.1);\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/unified-card-visual-regression.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":23,"column":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\n// Visual regression tests for UnifiedCard implementation\n// Tests at mobile (390Ã—844), tablet (834Ã—1112), and desktop (1440Ã—900) breakpoints\n\nconst BREAKPOINTS = {\n  mobile: { width: 390, height: 844 },\n  tablet: { width: 834, height: 1112 },\n  desktop: { width: 1440, height: 900 }\n};\n\nconst SCREENSHOT_DIR = '__screenshots__/cards';\n\n// Helper to ensure screenshot directory exists\nasync function ensureScreenshotDir() {\n  await fs.mkdir(SCREENSHOT_DIR, { recursive: true });\n}\n\n// Helper to calculate image hash for comparison\nasync function getImageHash(imagePath: string): Promise<string> {\n  try {\n    const imageBuffer = await fs.readFile(imagePath);\n    return crypto.createHash('sha256').update(imageBuffer).digest('hex');\n  } catch (error) {\n    return '';\n  }\n}\n\ntest.describe('UnifiedCard Visual Regression', () => {\n  test.beforeAll(async () => {\n    await ensureScreenshotDir();\n  });\n\n  test.beforeEach(async ({ page }) => {\n    // Set up error logging\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        console.error('Console error:', msg.text());\n      }\n    });\n  });\n\n  test('Dashboard cards match design across all breakpoints', async ({ page }) => {\n    // Navigate to dashboard\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    for (const [device, viewport] of Object.entries(BREAKPOINTS)) {\n      await page.setViewportSize(viewport);\n      await page.waitForTimeout(500); // Allow layout to settle\n\n      // Find all card elements using UnifiedCard\n      const cards = await page.locator('[class*=\"bg-white/\\\\[0\\\\.02\\\\]\"][class*=\"rounded-2xl\"]');\n      const cardCount = await cards.count();\n\n      expect(cardCount).toBeGreaterThan(0); // Ensure cards are found\n\n      // Take full page screenshot\n      const fullPagePath = path.join(SCREENSHOT_DIR, `dashboard-${device}-full.png`);\n      await page.screenshot({ \n        path: fullPagePath,\n        fullPage: true \n      });\n\n      // Take individual card screenshots\n      for (let i = 0; i < Math.min(cardCount, 5); i++) { // Test first 5 cards\n        const card = cards.nth(i);\n        await card.scrollIntoViewIfNeeded();\n        \n        const screenshotPath = path.join(SCREENSHOT_DIR, `dashboard-${device}-card-${i}.png`);\n        await card.screenshot({ path: screenshotPath });\n\n        // Verify card has consistent styling\n        const backgroundColor = await card.evaluate(el => \n          window.getComputedStyle(el).backgroundColor\n        );\n        expect(backgroundColor).toMatch(/rgba?\\(255,\\s*255,\\s*255,\\s*0\\.0[0-9]+\\)/);\n\n        const borderRadius = await card.evaluate(el => \n          window.getComputedStyle(el).borderRadius\n        );\n        expect(borderRadius).toBe('16px'); // rounded-2xl = 1rem = 16px\n\n        const border = await card.evaluate(el => \n          window.getComputedStyle(el).border\n        );\n        expect(border).toMatch(/1px solid rgba?\\(255,\\s*255,\\s*255,\\s*0\\.0[0-9]+\\)/);\n      }\n    }\n  });\n\n  test('Account cards use unified design', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    // Look for account cards\n    const accountCards = await page.locator('[class*=\"CompactAccountCard\"], [class*=\"AccountCard\"]').first();\n    \n    if (await accountCards.isVisible()) {\n      for (const [device, viewport] of Object.entries(BREAKPOINTS)) {\n        await page.setViewportSize(viewport);\n        await page.waitForTimeout(500);\n\n        const screenshotPath = path.join(SCREENSHOT_DIR, `account-card-${device}.png`);\n        await accountCards.screenshot({ path: screenshotPath });\n\n        // Verify unified styling\n        const hasUnifiedBackground = await accountCards.evaluate(el => {\n          const styles = window.getComputedStyle(el);\n          return styles.backgroundColor.includes('rgba(255, 255, 255, 0.02');\n        });\n        expect(hasUnifiedBackground).toBe(true);\n      }\n    }\n  });\n\n  test('Credit score card uses unified design', async ({ page }) => {\n    await page.goto('/credit-score');\n    await page.waitForLoadState('networkidle');\n\n    const creditCard = await page.locator('[class*=\"CreditScoreCard\"], [class*=\"credit\"][class*=\"score\"]').first();\n    \n    if (await creditCard.isVisible()) {\n      for (const [device, viewport] of Object.entries(BREAKPOINTS)) {\n        await page.setViewportSize(viewport);\n        await page.waitForTimeout(500);\n\n        const screenshotPath = path.join(SCREENSHOT_DIR, `credit-score-${device}.png`);\n        await creditCard.screenshot({ path: screenshotPath });\n      }\n    }\n  });\n\n  test('Savings goal cards use unified design', async ({ page }) => {\n    await page.goto('/savings-goals');\n    await page.waitForLoadState('networkidle');\n\n    const goalCards = await page.locator('[class*=\"GoalCard\"], [class*=\"goal\"][class*=\"card\"]');\n    const goalCount = await goalCards.count();\n\n    if (goalCount > 0) {\n      for (const [device, viewport] of Object.entries(BREAKPOINTS)) {\n        await page.setViewportSize(viewport);\n        await page.waitForTimeout(500);\n\n        const firstGoal = goalCards.first();\n        await firstGoal.scrollIntoViewIfNeeded();\n\n        const screenshotPath = path.join(SCREENSHOT_DIR, `savings-goal-${device}.png`);\n        await firstGoal.screenshot({ path: screenshotPath });\n      }\n    }\n  });\n\n  test('Compare screenshots with golden images', async ({ page }) => {\n    // This test compares current screenshots with golden images\n    const files = await fs.readdir(SCREENSHOT_DIR);\n    const pngFiles = files.filter(f => f.endsWith('.png'));\n\n    for (const file of pngFiles) {\n      const currentPath = path.join(SCREENSHOT_DIR, file);\n      const goldenPath = path.join(SCREENSHOT_DIR, 'golden', file);\n\n      // Check if golden image exists\n      try {\n        await fs.access(goldenPath);\n        \n        // Compare hashes\n        const currentHash = await getImageHash(currentPath);\n        const goldenHash = await getImageHash(goldenPath);\n\n        if (currentHash !== goldenHash) {\n          console.warn(`Visual difference detected in ${file}`);\n          // In a real CI/CD pipeline, this would fail the test\n          // expect(currentHash).toBe(goldenHash);\n        }\n      } catch (error) {\n        // No golden image exists, current becomes the golden\n        console.log(`Creating golden image for ${file}`);\n        await fs.mkdir(path.join(SCREENSHOT_DIR, 'golden'), { recursive: true });\n        await fs.copyFile(currentPath, goldenPath);\n      }\n    }\n  });\n\n  test('Card hover states work correctly', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    const card = await page.locator('[class*=\"bg-white/\\\\[0\\\\.02\\\\]\"][class*=\"hover\\\\:bg-white/\\\\[0\\\\.03\\\\]\"]').first();\n    \n    if (await card.isVisible()) {\n      // Get initial background\n      const initialBg = await card.evaluate(el => \n        window.getComputedStyle(el).backgroundColor\n      );\n\n      // Hover over card\n      await card.hover();\n      await page.waitForTimeout(300); // Wait for transition\n\n      // Get hover background\n      const hoverBg = await card.evaluate(el => \n        window.getComputedStyle(el).backgroundColor\n      );\n\n      // Verify background changed on hover\n      expect(initialBg).not.toBe(hoverBg);\n      \n      // Take hover screenshot\n      await card.screenshot({ \n        path: path.join(SCREENSHOT_DIR, 'card-hover-state.png') \n      });\n    }\n  });\n\n  test('Card responsive grid layouts', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n\n    // Test grid at each breakpoint\n    for (const [device, viewport] of Object.entries(BREAKPOINTS)) {\n      await page.setViewportSize(viewport);\n      await page.waitForTimeout(500);\n\n      const grid = await page.locator('[class*=\"grid\"][class*=\"gap-6\"]').first();\n      \n      if (await grid.isVisible()) {\n        const gridColumns = await grid.evaluate(el => {\n          const styles = window.getComputedStyle(el);\n          return styles.gridTemplateColumns;\n        });\n\n        // Verify responsive grid columns\n        switch (device) {\n          case 'mobile':\n            expect(gridColumns).toMatch(/^[^,]+$/); // Single column\n            break;\n          case 'tablet':\n            expect(gridColumns).toMatch(/,/); // Multiple columns\n            break;\n          case 'desktop':\n            expect(gridColumns.split(',').length).toBeGreaterThanOrEqual(3);\n            break;\n        }\n      }\n    }\n  });\n\n  const viewports = [\n    { width: 390, height: 844, name: 'mobile' },\n    { width: 834, height: 1112, name: 'tablet' },\n    { width: 1440, height: 900, name: 'desktop' }\n  ];\n\n  viewports.forEach(viewport => {\n    test(`UnifiedCard consistency - ${viewport.name}`, async ({ page }) => {\n      await page.setViewportSize(viewport);\n\n      // Test all major card components\n      const cardSelectors = [\n        // Core cards\n        { selector: '[class*=\"UnifiedCard\"]', name: 'unified-cards' },\n        { selector: '[class*=\"AccountCard\"]', name: 'account-cards' },\n        { selector: '[class*=\"BalanceCard\"]', name: 'balance-cards' },\n        { selector: '[class*=\"CreditScoreCard\"]', name: 'credit-score-cards' },\n        { selector: '[class*=\"GoalCard\"]', name: 'goal-cards' },\n        { selector: '[class*=\"GlassCard\"]', name: 'glass-cards' },\n        // Financial cards\n        { selector: '[class*=\"CompactAccountCard\"]', name: 'compact-account-cards' },\n        { selector: '[class*=\"CleanAccountCard\"]', name: 'clean-account-cards' },\n        { selector: '[class*=\"CleanCreditScoreCard\"]', name: 'clean-credit-cards' },\n        // Legacy cards that should now use UnifiedCard\n        { selector: '[class*=\"SimpleGlassCard\"]', name: 'simple-glass-cards' },\n        { selector: '[class*=\"MetricCard\"]', name: 'metric-cards' },\n        { selector: '[class*=\"ScoreCard\"]', name: 'score-cards' }\n      ];\n\n      for (const card of cardSelectors) {\n        const elements = await page.locator(card.selector);\n        const count = await elements.count();\n        \n        if (count > 0) {\n          console.log(`Found ${count} ${card.name} on ${viewport.name}`);\n          \n          // Take screenshots of each card type\n          for (let i = 0; i < Math.min(count, 3); i++) {\n            const element = elements.nth(i);\n            await element.waitFor({ state: 'visible' });\n            \n            // Verify they all have consistent UnifiedCard styling\n            const hasUnifiedStyling = await element.evaluate(el => {\n              const styles = window.getComputedStyle(el);\n              const bgColor = styles.backgroundColor;\n              const borderColor = styles.borderColor;\n              const borderRadius = styles.borderRadius;\n              \n              // Check for UnifiedCard's signature styling\n              return {\n                hasGlassEffect: bgColor.includes('rgba') && bgColor.includes('0.02'),\n                hasBorder: borderColor.includes('rgba') && borderColor.includes('0.08'),\n                hasRoundedCorners: borderRadius.includes('16px') || borderRadius.includes('1rem'),\n                backdropFilter: styles.backdropFilter || (styles as any).webkitBackdropFilter\n              };\n            });\n            \n            // Assert all cards have unified styling\n            expect(hasUnifiedStyling.hasGlassEffect).toBe(true);\n            expect(hasUnifiedStyling.hasBorder).toBe(true);\n            expect(hasUnifiedStyling.hasRoundedCorners).toBe(true);\n            \n            // Take screenshot for visual comparison\n            await element.screenshot({\n              path: path.join('__screenshots__', 'cards', `${card.name}-${i}-${viewport.name}.png`)\n            });\n          }\n        }\n      }\n    });\n  });\n\n  test('UnifiedCard Token Consistency', async ({ page }) => {\n    // Navigate to a page with multiple card types\n    await page.goto('/');\n    \n    // Check that all cards use the same design tokens\n    const tokenConsistency = await page.evaluate(() => {\n      const cards = document.querySelectorAll('[class*=\"Card\"]');\n      const styles: Array<{\n        background: string;\n        border: string;\n        borderRadius: string;\n        backdropFilter: string;\n      }> = [];\n      \n      cards.forEach(card => {\n        const computed = window.getComputedStyle(card);\n        styles.push({\n          background: computed.backgroundColor,\n          border: computed.borderColor,\n          borderRadius: computed.borderRadius,\n          backdropFilter: computed.backdropFilter || (computed as any).webkitBackdropFilter || ''\n        });\n      });\n      \n      // Check if all cards have consistent styling\n      const firstStyle = styles[0];\n      return styles.every(style => \n        style.background === firstStyle.background &&\n        style.border === firstStyle.border &&\n        style.borderRadius === firstStyle.borderRadius\n      );\n    });\n    \n    expect(tokenConsistency).toBe(true);\n  });\n\n  test('UnifiedCard Responsive Grid', async ({ page }) => {\n    // Test grid layouts at different breakpoints\n    for (const viewport of viewports) {\n      await page.setViewportSize(viewport);\n      \n      // Check grid behavior\n      const gridContainers = await page.locator('.grid');\n      const count = await gridContainers.count();\n      \n      for (let i = 0; i < count; i++) {\n        const container = gridContainers.nth(i);\n        const gridClass = await container.getAttribute('class');\n        \n        // Verify responsive grid classes\n        if (viewport.name === 'mobile') {\n          expect(gridClass).toContain('grid-cols-1');\n        } else if (viewport.name === 'tablet') {\n          expect(gridClass).toMatch(/md:grid-cols-[2-3]/);\n        } else {\n          expect(gridClass).toMatch(/lg:grid-cols-[3-4]/);\n        }\n      }\n    }\n  });\n\n  test('UnifiedCard Interaction States', async ({ page }) => {\n    // Test hover and click states\n    const interactiveCards = await page.locator('[class*=\"UnifiedCard\"][class*=\"interactive\"]');\n    const count = await interactiveCards.count();\n    \n    if (count > 0) {\n      const card = interactiveCards.first();\n      \n      // Test hover state\n      await card.hover();\n      const hoverStyles = await card.evaluate(el => {\n        const styles = window.getComputedStyle(el);\n        return {\n          transform: styles.transform,\n          backgroundColor: styles.backgroundColor\n        };\n      });\n      \n      // Verify hover effects\n      expect(hoverStyles.transform).toContain('scale');\n      \n      // Test click state\n      await card.click();\n      \n      // Take screenshot of interaction states\n      await page.screenshot({\n        path: path.join('__screenshots__', 'cards', 'unified-card-interactions.png')\n      });\n    }\n  });\n\n  test('Generate Card Migration Report', async ({ page }) => {\n    // Generate a report of all card components and their migration status\n    const report = await page.evaluate(() => {\n      const allCards = document.querySelectorAll('[class*=\"Card\"]');\n      const cardTypes = new Map();\n      \n      allCards.forEach(card => {\n        const className = card.className;\n        const cardType = className.match(/(\\w+Card)/)?.[1] || 'UnknownCard';\n        \n        if (!cardTypes.has(cardType)) {\n          cardTypes.set(cardType, {\n            count: 0,\n            hasUnifiedStyling: false,\n            examples: []\n          });\n        }\n        \n        const entry = cardTypes.get(cardType);\n        entry.count++;\n        \n        // Check for UnifiedCard styling\n        const styles = window.getComputedStyle(card);\n        entry.hasUnifiedStyling = \n          styles.backgroundColor.includes('0.02') &&\n          styles.borderColor.includes('0.08');\n        \n        if (entry.examples.length < 3) {\n          entry.examples.push({\n            html: card.outerHTML.substring(0, 200) + '...',\n            parent: card.parentElement?.className || 'root'\n          });\n        }\n      });\n      \n      return Array.from(cardTypes.entries()).map(([type, data]) => ({\n        type,\n        ...data\n      }));\n    });\n    \n    console.log('Card Migration Report:', JSON.stringify(report, null, 2));\n    \n    // Assert all cards have unified styling\n    report.forEach(card => {\n      expect(card.hasUnifiedStyling).toBe(true);\n    });\n  });\n});\n\n// Performance test for card rendering\ntest('UnifiedCard performance', async ({ page }) => {\n  await page.goto('/');\n  \n  // Measure card rendering performance\n  const metrics = await page.evaluate(() => {\n    const paintTiming = performance.getEntriesByType('paint');\n    const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n    \n    return {\n      firstPaint: paintTiming.find(p => p.name === 'first-paint')?.startTime || 0,\n      firstContentfulPaint: paintTiming.find(p => p.name === 'first-contentful-paint')?.startTime || 0,\n      domContentLoaded: navigationTiming.domContentLoadedEventEnd - navigationTiming.domContentLoadedEventStart,\n      loadComplete: navigationTiming.loadEventEnd - navigationTiming.loadEventStart\n    };\n  });\n\n  // Performance thresholds\n  expect(metrics.firstContentfulPaint).toBeLessThan(3000); // 3 seconds\n  expect(metrics.domContentLoaded).toBeLessThan(2000); // 2 seconds\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/user-journeys.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/visual-regression-dock.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":14,"column":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, devices } from '@playwright/test';\nimport { Page } from '@playwright/test';\n\n// Define device profiles\nconst deviceProfiles = [\n  { name: 'iPhone SE', device: devices['iPhone SE'] },\n  { name: 'iPhone 15 Pro Max', device: { ...devices['iPhone 15 Pro Max'], viewport: { width: 430, height: 932 } } },\n  { name: 'Pixel 7', device: devices['Pixel 7'] },\n  { name: 'iPad Mini', device: devices['iPad Mini'] },\n  { name: 'Desktop 1440', device: { viewport: { width: 1440, height: 900 } } },\n];\n\n// Helper function to capture dock and gradient areas\nasync function captureVisualAreas(page: Page, deviceName: string) {\n  await page.waitForLoadState('networkidle');\n  \n  // Capture full page screenshot\n  const fullPageScreenshot = await page.screenshot({\n    fullPage: true,\n    path: `.cursor/artifacts/full-page-${deviceName.replace(/\\s+/g, '-')}.png`\n  });\n  \n  // Capture dock area specifically\n  const dock = await page.locator('.bottom-navigation');\n  if (await dock.isVisible()) {\n    await dock.screenshot({\n      path: `.cursor/artifacts/dock-${deviceName.replace(/\\s+/g, '-')}.png`\n    });\n  }\n  \n  // Capture gradient background check\n  const gradientElement = await page.locator('.global-gradient-background');\n  const hasGradient = await gradientElement.count() > 0;\n  \n  return { fullPageScreenshot, hasGradient };\n}\n\n// Test each device profile\ndeviceProfiles.forEach(({ name, device }) => {\n  test.describe(`Visual Regression - ${name}`, () => {\n    test.use(device);\n    \n    test('Dock should be flush full-width', async ({ page }) => {\n      await page.goto('/');\n      \n      // Capture baseline\n      await captureVisualAreas(page, name);\n      \n      // Check dock positioning\n      const dock = await page.locator('.bottom-navigation');\n      const dockBox = await dock.boundingBox();\n      const viewport = page.viewportSize();\n      \n      if (dockBox && viewport) {\n        // Dock should start at x=0 (flush left)\n        expect(dockBox.x).toBe(0);\n        \n        // Dock should be full viewport width\n        expect(dockBox.width).toBe(viewport.width);\n        \n        // Log measurements for debugging\n        console.log(`${name} - Dock measurements:`, {\n          x: dockBox.x,\n          width: dockBox.width,\n          viewportWidth: viewport.width,\n          isFlush: dockBox.x === 0 && dockBox.width === viewport.width\n        });\n      }\n    });\n    \n    test('Gradient should fill entire viewport', async ({ page }) => {\n      await page.goto('/');\n      \n      // Check gradient element exists\n      const gradientElement = await page.locator('.global-gradient-background');\n      await expect(gradientElement).toBeVisible();\n      \n      // Check gradient positioning\n      const gradientStyles = await gradientElement.evaluate(el => {\n        const styles = window.getComputedStyle(el);\n        return {\n          position: styles.position,\n          top: styles.top,\n          right: styles.right,\n          bottom: styles.bottom,\n          left: styles.left,\n          width: styles.width,\n          height: styles.height,\n          zIndex: styles.zIndex\n        };\n      });\n      \n      // Gradient should be fixed position with inset 0\n      expect(gradientStyles.position).toBe('fixed');\n      expect(gradientStyles.top).toBe('0px');\n      expect(gradientStyles.right).toBe('0px');\n      expect(gradientStyles.bottom).toBe('0px');\n      expect(gradientStyles.left).toBe('0px');\n      expect(gradientStyles.zIndex).toBe('-1');\n    });\n    \n    test('Visual snapshot comparison', async ({ page }) => {\n      await page.goto('/');\n      await page.waitForLoadState('networkidle');\n      \n      // Take screenshot for visual comparison\n      await expect(page).toHaveScreenshot(`${name}-full-page.png`, {\n        fullPage: true,\n        animations: 'disabled',\n        maxDiffPixels: 100,\n      });\n      \n      // Dock-specific screenshot\n      const dock = await page.locator('.bottom-navigation');\n      if (await dock.isVisible()) {\n        await expect(dock).toHaveScreenshot(`${name}-dock.png`, {\n          animations: 'disabled',\n          maxDiffPixels: 20, // Strict 2px tolerance for dock\n        });\n      }\n    });\n    \n    test('Safe area handling', async ({ page }) => {\n      await page.goto('/');\n      \n      // Check viewport meta tag\n      const viewportContent = await page.$eval('meta[name=\"viewport\"]', \n        el => el.getAttribute('content')\n      );\n      expect(viewportContent).toContain('viewport-fit=cover');\n      \n      // For iOS devices, check safe area classes\n      if (name.includes('iPhone') || name.includes('iPad')) {\n        const safeAreaElement = await page.locator('.safe-area-bottom');\n        await expect(safeAreaElement).toBeVisible();\n        \n        // Check computed padding includes safe area\n        const bottomNav = await page.locator('.bottom-navigation');\n        const paddingBottom = await bottomNav.evaluate(el => \n          window.getComputedStyle(el).paddingBottom\n        );\n        \n        console.log(`${name} - Safe area padding:`, paddingBottom);\n      }\n    });\n  });\n});\n\n// CI-specific test to prevent regressions\ntest.describe('CI Visual Regression', () => {\n  test('Dock positioning should not regress', async ({ page }) => {\n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Define critical measurements\n    const dock = await page.locator('.bottom-navigation');\n    const dockBox = await dock.boundingBox();\n    \n    if (dockBox) {\n      // These assertions will fail CI if dock positioning changes\n      expect(dockBox.x).toBe(0); // Must be flush left\n      expect(dockBox.x).toBeLessThanOrEqual(2); // Max 2px tolerance\n      \n      // Store measurements for future comparison\n      const measurements = {\n        timestamp: new Date().toISOString(),\n        dockX: dockBox.x,\n        dockWidth: dockBox.width,\n        viewportWidth: page.viewportSize()?.width\n      };\n      \n      console.log('CI Measurements:', measurements);\n    }\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/vueni-financial.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":223,"column":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Vueni Financial Operations', () => {\n  test.beforeEach(async ({ page }) => {\n    await page.goto('/');\n    \n    // Wait for the app to load\n    await page.waitForLoadState('networkidle');\n    \n    // Handle any auth or setup if needed\n    await page.waitForSelector('[data-testid=\"vueni-dashboard\"], [data-testid=\"dashboard-container\"], .dashboard, .container', { \n      timeout: 10000 \n    });\n  });\n\n  test('should display Vueni dashboard correctly', async ({ page }) => {\n    // Verify main dashboard elements are visible\n    const dashboardSelectors = [\n      '[data-testid=\"vueni-dashboard\"]',\n      '[data-testid=\"dashboard-container\"]', \n      '.dashboard',\n      'h1, h2', // Fallback for header elements\n    ];\n\n    let dashboardFound = false;\n    for (const selector of dashboardSelectors) {\n      try {\n        await expect(page.locator(selector).first()).toBeVisible({ timeout: 5000 });\n        dashboardFound = true;\n        break;\n      } catch (error) {\n        continue;\n      }\n    }\n    \n    expect(dashboardFound).toBe(true);\n\n    // Check for transaction-related elements\n    const transactionSelectors = [\n      '[data-testid=\"vueni-unified-transaction-list\"]',\n      '[data-testid=\"transaction-list\"]',\n      '.transaction-list',\n      '.transaction-item',\n      'text=Transactions',\n      'text=Transaction'\n    ];\n\n    let transactionElementFound = false;\n    for (const selector of transactionSelectors) {\n      if (await page.locator(selector).first().isVisible({ timeout: 3000 }).catch(() => false)) {\n        transactionElementFound = true;\n        break;\n      }\n    }\n\n    // If no transaction elements found, that's okay for an empty state\n    if (transactionElementFound) {\n      console.log('Transaction elements found on dashboard');\n    }\n  });\n\n  test('should handle Vueni unified transaction list variants', async ({ page }) => {\n    // Look for variant controls or transaction list\n    const variantSelectors = [\n      '[data-testid=\"transaction-variant-selector\"]',\n      'select[value*=\"variant\"]',\n      '.transaction-list',\n      '[class*=\"transaction\"]'\n    ];\n\n    let hasTransactionElements = false;\n    for (const selector of variantSelectors) {\n      if (await page.locator(selector).first().isVisible({ timeout: 3000 }).catch(() => false)) {\n        hasTransactionElements = true;\n        break;\n      }\n    }\n\n    if (hasTransactionElements) {\n      // Test variant switching if available\n      const variantSelect = page.locator('select[value*=\"variant\"], [data-testid=\"transaction-variant-selector\"]').first();\n      if (await variantSelect.isVisible({ timeout: 3000 }).catch(() => false)) {\n        // Test different variants\n        const variants = ['default', 'apple', 'clean', 'polished', 'enterprise', 'mobile'];\n        \n        for (const variant of variants.slice(0, 3)) { // Test first 3 variants\n          try {\n            await variantSelect.selectOption(variant);\n            await page.waitForTimeout(500); // Allow transition\n            \n            // Verify the variant is applied\n            expect(await variantSelect.inputValue()).toBe(variant);\n          } catch (error) {\n            console.log(`Variant ${variant} not available or not selectable`);\n          }\n        }\n      }\n    }\n  });\n\n  test('should handle Vueni transaction filtering and search', async ({ page }) => {\n    // Look for search and filter elements\n    const searchInput = page.locator('input[placeholder*=\"search\"], input[placeholder*=\"Search\"], [data-testid=\"transaction-search\"]').first();\n    const filterElements = page.locator('select, [data-testid*=\"filter\"], .filter');\n\n    if (await searchInput.isVisible({ timeout: 3000 }).catch(() => false)) {\n      // Test search functionality\n      await searchInput.fill('Test');\n      await page.waitForTimeout(500);\n      \n      // Clear search\n      await searchInput.clear();\n      await page.waitForTimeout(500);\n    }\n\n    // Test category filter if available\n    const categoryFilter = page.locator('select[value*=\"category\"], [data-testid=\"category-filter\"]').first();\n    if (await categoryFilter.isVisible({ timeout: 3000 }).catch(() => false)) {\n      // Try to select a category option\n      const options = await categoryFilter.locator('option').allTextContents();\n      if (options.length > 1) {\n        await categoryFilter.selectOption({ index: 1 });\n        await page.waitForTimeout(500);\n        \n        // Reset to all categories\n        await categoryFilter.selectOption({ index: 0 });\n      }\n    }\n  });\n\n  test('should verify Vueni design system components', async ({ page }) => {\n    // Check for design system elements\n    const designSystemElements = [\n      '.vueni-glass-card, [class*=\"glass\"]',\n      '.vueni-button, button',\n      '.vueni-metric, [data-testid*=\"metric\"]',\n      '.vueni-status-badge, [class*=\"badge\"]'\n    ];\n\n    for (const selector of designSystemElements) {\n      const elements = page.locator(selector);\n      const count = await elements.count();\n      \n      if (count > 0) {\n        // Verify at least one element is visible\n        await expect(elements.first()).toBeVisible({ timeout: 3000 });\n        console.log(`Found ${count} elements matching ${selector}`);\n      }\n    }\n  });\n\n  test('should check Vueni feature flags functionality', async ({ page }) => {\n    // Look for feature flag controls\n    const featureFlagSelectors = [\n      '[data-testid*=\"feature-flag\"]',\n      'input[type=\"checkbox\"]',\n      '.feature-flag',\n      '[class*=\"flag\"]'\n    ];\n\n    for (const selector of featureFlagSelectors) {\n      const elements = page.locator(selector);\n      const count = await elements.count();\n      \n      if (count > 0) {\n        // Test first checkbox if it's a feature flag\n        const firstCheckbox = elements.first();\n        if (await firstCheckbox.isVisible({ timeout: 3000 }).catch(() => false)) {\n          const isChecked = await firstCheckbox.isChecked();\n          \n          // Toggle the checkbox\n          await firstCheckbox.click();\n          await page.waitForTimeout(300);\n          \n          // Verify state changed\n          const newState = await firstCheckbox.isChecked();\n          expect(newState).toBe(!isChecked);\n          \n          // Toggle back\n          await firstCheckbox.click();\n          await page.waitForTimeout(300);\n        }\n        break;\n      }\n    }\n  });\n\n  test('should verify Vueni responsive design', async ({ page }) => {\n    // Test desktop view\n    await page.setViewportSize({ width: 1200, height: 800 });\n    await page.waitForTimeout(500);\n    \n    // Check that main content is visible\n    const mainContent = page.locator('main, .main, [role=\"main\"], .container, .dashboard').first();\n    await expect(mainContent).toBeVisible();\n\n    // Test tablet view\n    await page.setViewportSize({ width: 768, height: 1024 });\n    await page.waitForTimeout(500);\n    await expect(mainContent).toBeVisible();\n\n    // Test mobile view\n    await page.setViewportSize({ width: 375, height: 667 });\n    await page.waitForTimeout(500);\n    await expect(mainContent).toBeVisible();\n\n    // Reset to desktop\n    await page.setViewportSize({ width: 1200, height: 800 });\n  });\n\n  test('should check Vueni performance metrics', async ({ page }) => {\n    // Start performance monitoring\n    const startTime = Date.now();\n    \n    await page.goto('/', { waitUntil: 'networkidle' });\n    \n    const loadTime = Date.now() - startTime;\n    \n    // Verify page loads within reasonable time (5 seconds)\n    expect(loadTime).toBeLessThan(5000);\n\n    // Check for any JavaScript errors\n    const errors: string[] = [];\n    page.on('pageerror', (error) => {\n      errors.push(error.message);\n    });\n\n    // Wait a bit to catch any errors\n    await page.waitForTimeout(2000);\n\n    // Log errors but don't fail the test (some errors might be expected)\n    if (errors.length > 0) {\n      console.warn('JavaScript errors detected:', errors);\n    }\n\n    // Check that essential elements rendered\n    const hasContent = await page.locator('body *').first().isVisible({ timeout: 3000 }).catch(() => false);\n    expect(hasContent).toBe(true);\n  });\n\n  test('should verify Vueni accessibility standards', async ({ page }) => {\n    // Check for basic accessibility attributes\n    const elements = page.locator('button, input, select, [role], [aria-label], [aria-labelledby]');\n    const count = await elements.count();\n    \n    if (count > 0) {\n      // Check first few interactive elements have accessible attributes\n      for (let i = 0; i < Math.min(count, 5); i++) {\n        const element = elements.nth(i);\n        const tagName = await element.evaluate(el => el.tagName.toLowerCase());\n        \n        if (['button', 'input', 'select'].includes(tagName)) {\n          // These elements should be keyboard accessible\n          await element.focus().catch(() => {}); // Don't fail if focus not possible\n        }\n      }\n    }\n\n    // Check for heading structure\n    const headings = page.locator('h1, h2, h3, h4, h5, h6');\n    const headingCount = await headings.count();\n    \n    if (headingCount > 0) {\n      // Verify there's at least one main heading\n      const h1Count = await page.locator('h1').count();\n      expect(h1Count).toBeGreaterThanOrEqual(0); // Allow 0 h1s as some SPAs use different patterns\n    }\n  });\n});\n\ntest.describe('Vueni Security Validation', () => {\n  test('should verify secure storage implementation', async ({ page }) => {\n    await page.goto('/');\n    \n    // Check that no sensitive data is stored in plain text\n    const localStorageData = await page.evaluate(() => {\n      const data: Record<string, string> = {};\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key) {\n          data[key] = localStorage.getItem(key) || '';\n        }\n      }\n      return data;\n    });\n\n    // Check for encrypted Vueni data\n    const vueniKeys = Object.keys(localStorageData).filter(key => key.startsWith('vueni_'));\n    \n    for (const key of vueniKeys) {\n      const value = localStorageData[key];\n      \n      // Verify data appears encrypted (doesn't contain obvious plain text patterns)\n      expect(value).not.toMatch(/\\d{4}-\\d{2}-\\d{2}/); // No plain dates\n      expect(value).not.toMatch(/\\$\\d+\\.\\d{2}/); // No plain currency amounts\n      expect(value).not.toContain('password'); // No plain password strings\n      expect(value).not.toContain('@'); // No plain email addresses\n    }\n  });\n\n  test('should verify CSP headers are properly set', async ({ page }) => {\n    const response = await page.goto('/');\n    expect(response).toBeTruthy();\n\n    if (response) {\n      const headers = response.headers();\n      \n      // Check for security headers\n      const securityHeaders = [\n        'content-security-policy',\n        'x-frame-options',\n        'x-content-type-options',\n        'referrer-policy'\n      ];\n\n      for (const header of securityHeaders) {\n        if (headers[header]) {\n          console.log(`Security header found: ${header} = ${headers[header]}`);\n        }\n      }\n\n      // Verify CSP exists (might be set by Vercel)\n      const csp = headers['content-security-policy'];\n      if (csp) {\n        expect(csp).toContain(\"default-src 'self'\");\n      }\n    }\n  });\n\n  test('should verify no sensitive data in network requests', async ({ page }) => {\n    const requests: string[] = [];\n    \n    page.on('request', (request) => {\n      const url = request.url();\n      const postData = request.postData();\n      \n      if (postData) {\n        // Check that passwords/sensitive data aren't sent in plain text\n        expect(postData).not.toContain('password=');\n        expect(postData).not.toMatch(/ssn.*\\d{3}-\\d{2}-\\d{4}/);\n        expect(postData).not.toMatch(/credit.*card.*\\d{4}/);\n      }\n      \n      requests.push(url);\n    });\n\n    await page.goto('/');\n    await page.waitForTimeout(2000);\n\n    // Log API requests for debugging\n    const apiRequests = requests.filter(url => url.includes('/api/'));\n    if (apiRequests.length > 0) {\n      console.log('API requests made:', apiRequests);\n    }\n  });\n\n  test('should verify session management', async ({ page }) => {\n    await page.goto('/');\n    \n    // Check for session-related storage\n    const sessionData = await page.evaluate(() => {\n      const data: Record<string, string> = {};\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key) {\n          data[key] = sessionStorage.getItem(key) || '';\n        }\n      }\n      return data;\n    });\n\n    // Look for session management patterns\n    const sessionKeys = Object.keys(sessionData).filter(key => \n      key.includes('session') || key.includes('vueni_session') || key.includes('csrf')\n    );\n\n    if (sessionKeys.length > 0) {\n      console.log('Session management keys found:', sessionKeys);\n      \n      // Verify session data appears properly managed\n      for (const key of sessionKeys) {\n        const value = sessionData[key];\n        expect(value).toBeTruthy();\n        expect(value.length).toBeGreaterThan(10); // Should have meaningful content\n      }\n    }\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/vueni-performance.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token as","line":70,"column":59}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\ntest.describe('Vueni Performance Testing', () => {\n  test.beforeEach(async ({ page }) => {\n    // Clear cache and storage for clean performance testing\n    await page.context().clearCookies();\n    await page.evaluate(() => {\n      localStorage.clear();\n      sessionStorage.clear();\n    });\n  });\n\n  test('should meet Core Web Vitals standards', async ({ page }) => {\n    // Navigate to the page and measure performance\n    const startTime = Date.now();\n    \n    await page.goto('/', { waitUntil: 'networkidle' });\n    \n    const loadTime = Date.now() - startTime;\n    \n    // First Contentful Paint should be under 1.8s (good threshold)\n    expect(loadTime).toBeLessThan(1800);\n\n    // Measure LCP (Largest Contentful Paint)\n    const lcp = await page.evaluate(() => {\n      return new Promise((resolve) => {\n        new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1];\n          resolve(lastEntry.startTime);\n        }).observe({ entryTypes: ['largest-contentful-paint'] });\n        \n        // Fallback timeout\n        setTimeout(() => resolve(0), 5000);\n      });\n    });\n\n    if (lcp > 0) {\n      // LCP should be under 2.5s (good threshold)\n      expect(lcp).toBeLessThan(2500);\n      console.log(`LCP: ${lcp}ms`);\n    }\n\n    // Check First Input Delay by simulating a click\n    const button = page.locator('button, [role=\"button\"], .clickable').first();\n    if (await button.isVisible({ timeout: 3000 }).catch(() => false)) {\n      const clickStart = Date.now();\n      await button.click();\n      const clickEnd = Date.now();\n      const fid = clickEnd - clickStart;\n      \n      // FID should be under 100ms (good threshold)\n      expect(fid).toBeLessThan(100);\n      console.log(`Simulated FID: ${fid}ms`);\n    }\n  });\n\n  test('should efficiently handle large transaction lists', async ({ page }) => {\n    await page.goto('/');\n    \n    // Inject mock data for performance testing\n    await page.evaluate(() => {\n      // Create mock transaction data\n      const mockTransactions = Array.from({ length: 1000 }, (_, i) => ({\n        id: `tx-${i}`,\n        merchant: `Merchant ${i}`,\n        category: { name: `Category ${i % 10}`, color: '#3B82F6' },\n        amount: (Math.random() - 0.5) * 1000,\n        date: new Date(Date.now() - i * 24 * 60 * 60 * 1000).toISOString(),\n        status: ['completed', 'pending', 'failed'][i % 3] as 'completed' | 'pending' | 'failed',\n        scores: {\n          health: Math.floor(Math.random() * 100),\n          eco: Math.floor(Math.random() * 100),\n          financial: Math.floor(Math.random() * 100)\n        }\n      }));\n\n      // Store in window for component access\n      (window as unknown as { mockTransactions?: typeof mockTransactions }).mockTransactions = mockTransactions;\n    });\n\n    // Measure rendering performance with large dataset\n    const renderStart = Date.now();\n    \n    // Trigger re-render if there's a way to inject data\n    await page.evaluate(() => {\n      // Dispatch custom event that components might listen to\n      window.dispatchEvent(new CustomEvent('vueni-load-mock-data', {\n        detail: (window as unknown as { mockTransactions?: unknown }).mockTransactions\n      }));\n    });\n\n    await page.waitForTimeout(2000); // Allow rendering\n    \n    const renderEnd = Date.now();\n    const renderTime = renderEnd - renderStart;\n    \n    // Large list rendering should complete within 3 seconds\n    expect(renderTime).toBeLessThan(3000);\n    console.log(`Large list render time: ${renderTime}ms`);\n\n    // Check that the page is still responsive\n    const scrollStart = Date.now();\n    await page.mouse.wheel(0, 500);\n    await page.waitForTimeout(100);\n    const scrollEnd = Date.now();\n    \n    // Scrolling should be smooth (under 50ms response)\n    expect(scrollEnd - scrollStart).toBeLessThan(50);\n  });\n\n  test('should optimize bundle size and loading', async ({ page }) => {\n    // Track network requests\n    interface NetworkRequest {\n      url: string;\n      method: string;\n      resourceType: string;\n    }\n    interface NetworkResponse {\n      url: string;\n      status: number;\n      headers: Record<string, string>;\n    }\n    const requests: NetworkRequest[] = [];\n    const responses: NetworkResponse[] = [];\n\n    page.on('request', (request) => {\n      requests.push({\n        url: request.url(),\n        method: request.method(),\n        resourceType: request.resourceType()\n      });\n    });\n\n    page.on('response', (response) => {\n      responses.push({\n        url: response.url(),\n        status: response.status(),\n        headers: response.headers()\n      });\n    });\n\n    await page.goto('/', { waitUntil: 'networkidle' });\n\n    // Check JavaScript bundle sizes\n    const jsRequests = requests.filter(req => \n      req.resourceType === 'script' && req.url.includes('.js')\n    );\n\n    let totalJSSize = 0;\n    for (const jsReq of jsRequests) {\n      const response = responses.find(res => res.url === jsReq.url);\n      if (response && response.headers['content-length']) {\n        totalJSSize += parseInt(response.headers['content-length']);\n      }\n    }\n\n    // Main bundle should be under 1.5MB (compressed)\n    if (totalJSSize > 0) {\n      expect(totalJSSize).toBeLessThan(1.5 * 1024 * 1024);\n      console.log(`Total JS bundle size: ${(totalJSSize / 1024 / 1024).toFixed(2)}MB`);\n    }\n\n    // Check for code splitting evidence\n    const jsFiles = jsRequests.map(req => req.url);\n    const hasCodeSplitting = jsFiles.some(url => \n      url.includes('chunk') || url.includes('lazy') || jsFiles.length > 3\n    );\n\n    // Log code splitting status\n    console.log(`Code splitting detected: ${hasCodeSplitting}`);\n    console.log(`JavaScript files loaded: ${jsFiles.length}`);\n  });\n\n  test('should handle memory efficiently', async ({ page }) => {\n    await page.goto('/');\n\n    // Get initial memory usage\n    const initialMemory = await page.evaluate(() => {\n      return (performance as any).memory ? {\n        usedJSHeapSize: (performance as any).memory.usedJSHeapSize,\n        totalJSHeapSize: (performance as any).memory.totalJSHeapSize,\n        jsHeapSizeLimit: (performance as any).memory.jsHeapSizeLimit\n      } : null;\n    });\n\n    if (initialMemory) {\n      console.log('Initial memory usage:', initialMemory);\n\n      // Simulate heavy usage\n      await page.evaluate(() => {\n        // Simulate creating and destroying components\n        for (let i = 0; i < 100; i++) {\n          const div = document.createElement('div');\n          div.innerHTML = `<div>Component ${i}</div>`.repeat(100);\n          document.body.appendChild(div);\n          \n          setTimeout(() => {\n            if (div.parentNode) {\n              div.parentNode.removeChild(div);\n            }\n          }, 10);\n        }\n      });\n\n      await page.waitForTimeout(2000);\n\n      // Get memory usage after simulation\n      const finalMemory = await page.evaluate(() => {\n        return (performance as any).memory ? {\n          usedJSHeapSize: (performance as any).memory.usedJSHeapSize,\n          totalJSHeapSize: (performance as any).memory.totalJSHeapSize,\n          jsHeapSizeLimit: (performance as any).memory.jsHeapSizeLimit\n        } : null;\n      });\n\n      if (finalMemory) {\n        console.log('Final memory usage:', finalMemory);\n        \n        // Memory growth should be reasonable (under 50MB increase)\n        const memoryGrowth = finalMemory.usedJSHeapSize - initialMemory.usedJSHeapSize;\n        expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024);\n        console.log(`Memory growth: ${(memoryGrowth / 1024 / 1024).toFixed(2)}MB`);\n      }\n    }\n  });\n\n  test('should optimize image and asset loading', async ({ page }) => {\n    const imageRequests: any[] = [];\n    const cssRequests: any[] = [];\n\n    page.on('request', (request) => {\n      if (request.resourceType() === 'image') {\n        imageRequests.push(request.url());\n      }\n      if (request.resourceType() === 'stylesheet') {\n        cssRequests.push(request.url());\n      }\n    });\n\n    await page.goto('/', { waitUntil: 'networkidle' });\n\n    // Check that images are optimized\n    for (const imageUrl of imageRequests) {\n      // Modern format check (WebP, AVIF support)\n      const isOptimizedFormat = imageUrl.includes('.webp') || \n                               imageUrl.includes('.avif') || \n                               imageUrl.includes('f_auto') || // Cloudinary auto format\n                               imageUrl.includes('format=webp');\n                               \n      if (!isOptimizedFormat && !imageUrl.includes('data:')) {\n        console.warn(`Potentially unoptimized image: ${imageUrl}`);\n      }\n    }\n\n    // Check CSS optimization\n    console.log(`CSS files loaded: ${cssRequests.length}`);\n    console.log(`Images loaded: ${imageRequests.length}`);\n\n    // Should have reasonable number of asset requests\n    expect(imageRequests.length + cssRequests.length).toBeLessThan(20);\n  });\n\n  test('should validate caching strategies', async ({ page, context }) => {\n    // First visit\n    await page.goto('/', { waitUntil: 'networkidle' });\n    \n    const firstLoadRequests: string[] = [];\n    page.on('request', (request) => {\n      firstLoadRequests.push(request.url());\n    });\n\n    // Second visit (should utilize cache)\n    await page.reload({ waitUntil: 'networkidle' });\n    \n    const secondLoadRequests: string[] = [];\n    page.on('request', (request) => {\n      secondLoadRequests.push(request.url());\n    });\n\n    await page.waitForTimeout(1000);\n\n    // Check that static assets are cached\n    const staticAssets = firstLoadRequests.filter(url => \n      url.includes('.js') || url.includes('.css') || url.includes('.png') || \n      url.includes('.jpg') || url.includes('.svg')\n    );\n\n    const cachedAssets = staticAssets.filter(url => \n      !secondLoadRequests.includes(url)\n    );\n\n    // At least some assets should be cached\n    const cacheEfficiency = cachedAssets.length / staticAssets.length;\n    console.log(`Cache efficiency: ${(cacheEfficiency * 100).toFixed(1)}%`);\n    \n    // Should have at least 50% cache hit rate for static assets\n    expect(cacheEfficiency).toBeGreaterThan(0.5);\n  });\n\n  test('should measure component render performance', async ({ page }) => {\n    await page.goto('/');\n\n    // Measure component mount times\n    const componentMetrics = await page.evaluate(() => {\n      const startTime = performance.now();\n      \n      // Trigger component updates if possible\n      window.dispatchEvent(new Event('resize'));\n      \n      return new Promise((resolve) => {\n        requestAnimationFrame(() => {\n          const endTime = performance.now();\n          resolve({\n            componentUpdateTime: endTime - startTime,\n            timestamp: endTime\n          });\n        });\n      });\n    });\n\n    console.log('Component metrics:', componentMetrics);\n\n    // Test interaction responsiveness\n    const interactionStart = Date.now();\n    \n    // Find and interact with UI elements\n    const interactiveElements = page.locator('button, input, select, [role=\"button\"]');\n    const count = await interactiveElements.count();\n    \n    if (count > 0) {\n      // Test first interactive element\n      await interactiveElements.first().hover();\n      await page.waitForTimeout(50);\n      \n      const interactionEnd = Date.now();\n      const interactionTime = interactionEnd - interactionStart;\n      \n      // Interactions should be responsive (under 100ms)\n      expect(interactionTime).toBeLessThan(100);\n      console.log(`Interaction response time: ${interactionTime}ms`);\n    }\n  });\n\n  test('should validate accessibility performance', async ({ page }) => {\n    await page.goto('/');\n    \n    // Check for accessibility-related performance issues\n    const accessibilityMetrics = await page.evaluate(() => {\n      const startTime = performance.now();\n      \n      // Count focusable elements\n      const focusableElements = document.querySelectorAll(\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n      \n      // Count ARIA elements\n      const ariaElements = document.querySelectorAll('[aria-label], [aria-labelledby], [role]');\n      \n      const endTime = performance.now();\n      \n      return {\n        focusableCount: focusableElements.length,\n        ariaCount: ariaElements.length,\n        scanTime: endTime - startTime\n      };\n    });\n\n    console.log('Accessibility metrics:', accessibilityMetrics);\n    \n    // Accessibility scanning should be fast\n    expect(accessibilityMetrics.scanTime).toBeLessThan(100);\n    \n    // Should have reasonable number of interactive elements\n    expect(accessibilityMetrics.focusableCount).toBeGreaterThan(0);\n    expect(accessibilityMetrics.focusableCount).toBeLessThan(100);\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/e2e/white-screen-debug.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":9,"column":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page } from '@playwright/test';\n\n/**\n * Comprehensive White Screen Debugging Test\n * This test performs deep validation to ensure the application loads correctly\n */\n\ntest.describe('White Screen Debugging', () => {\n  let page: Page;\n\n  test.beforeEach(async ({ browser }) => {\n    page = await browser.newPage();\n    \n    // Enable console logging to catch errors\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        console.error('ðŸ”´ BROWSER ERROR:', msg.text());\n      } else if (msg.type() === 'warning') {\n        console.warn('ðŸŸ¡ BROWSER WARNING:', msg.text());\n      } else if (msg.text().includes('SECURITY') || msg.text().includes('ERROR')) {\n        console.log('ðŸ” SECURITY/ERROR LOG:', msg.text());\n      }\n    });\n\n    // Catch page errors\n    page.on('pageerror', error => {\n      console.error('ðŸ”´ PAGE ERROR:', error.message);\n    });\n\n    // Catch network failures\n    page.on('response', response => {\n      if (!response.ok()) {\n        console.error('ðŸ”´ NETWORK ERROR:', response.status(), response.url());\n      }\n    });\n  });\n\n  test('should load without white screen and display content', async () => {\n    console.log('ðŸ§ª Starting comprehensive white screen test...');\n    \n    // Step 1: Navigate to the application\n    console.log('ðŸ“¡ Navigating to application...');\n    await page.goto('/', { waitUntil: 'networkidle' });\n    \n    // Step 2: Wait for React to load and render\n    console.log('âš›ï¸ Waiting for React application to initialize...');\n    await page.waitForTimeout(2000); // Give React time to start up\n    \n    // Step 3: Check if we have the root element\n    const rootElement = await page.locator('#root');\n    await expect(rootElement).toBeVisible();\n    console.log('âœ… Root element is visible');\n    \n    // Step 4: Verify the root element has content (not empty)\n    const rootContent = await rootElement.innerHTML();\n    expect(rootContent.trim()).not.toBe('');\n    console.log('âœ… Root element has content');\n    \n    // Step 5: Check for any visible content on the page\n    const bodyContent = await page.locator('body').innerHTML();\n    expect(bodyContent).toContain('');\n    \n    // Step 6: Look for specific UI elements that should be present\n    console.log('ðŸ” Checking for specific UI elements...');\n    \n    // Wait for at least one of these elements to be visible\n    const criticalElements = [\n      'nav', // Navigation\n      'header', // Header\n      'main', // Main content\n      '[data-testid]', // Any test elements\n      '.card', // Cards\n      'button', // Buttons\n      'a[href]' // Links\n    ];\n    \n    const foundElements: string[] = [];\n    for (const selector of criticalElements) {\n      const elements = await page.locator(selector).count();\n      if (elements > 0) {\n        foundElements.push(`${selector}: ${elements}`);\n      }\n    }\n    \n    console.log('ðŸ“‹ Found UI elements:', foundElements);\n    expect(foundElements.length).toBeGreaterThan(0);\n    \n    // Step 7: Check for dark mode class (should be applied by default)\n    const htmlElement = page.locator('html');\n    await expect(htmlElement).toHaveClass(/dark/);\n    console.log('âœ… Dark mode is applied');\n    \n    // Step 8: Verify no critical errors in console\n    const errorMessages: string[] = [];\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        errorMessages.push(msg.text());\n      }\n    });\n    \n    // Step 9: Take a screenshot for visual verification\n    await page.screenshot({ \n      path: 'test-results/white-screen-debug.png',\n      fullPage: true \n    });\n    console.log('ðŸ“¸ Screenshot saved for visual verification');\n    \n    // Step 10: Check page title\n    const title = await page.title();\n    expect(title).not.toBe('');\n    console.log('âœ… Page title:', title);\n    \n    // Step 11: Verify page is not completely white\n    const pageBackground = await page.evaluate(() => {\n      const body = document.body;\n      const computedStyle = window.getComputedStyle(body);\n      return {\n        backgroundColor: computedStyle.backgroundColor,\n        color: computedStyle.color\n      };\n    });\n    \n    console.log('ðŸŽ¨ Page styling:', pageBackground);\n    \n    // The background should not be pure white (rgb(255, 255, 255))\n    expect(pageBackground.backgroundColor).not.toBe('rgb(255, 255, 255)');\n    \n    console.log('ðŸŽ‰ All white screen debugging tests passed!');\n  });\n\n  test('should handle environment variable validation correctly', async () => {\n    console.log('ðŸ” Testing environment variable validation...');\n    \n    await page.goto('/');\n    \n    // Wait for the security validation to complete\n    await page.waitForTimeout(1000);\n    \n    // Check for security validation messages in console\n    const securityLogs: string[] = [];\n    page.on('console', msg => {\n      if (msg.text().includes('SECURITY')) {\n        securityLogs.push(msg.text());\n      }\n    });\n    \n    // Reload to trigger validation again\n    await page.reload();\n    await page.waitForTimeout(1000);\n    \n    // Should not see critical security errors\n    const hasSecurityError = securityLogs.some(log => \n      log.includes('CRITICAL SECURITY ERROR')\n    );\n    \n    expect(hasSecurityError).toBeFalsy();\n    console.log('âœ… No critical security errors found');\n  });\n\n  test('should display loading states and transitions properly', async () => {\n    console.log('â³ Testing loading states and transitions...');\n    \n    // Use slow 3G to test loading states\n    await page.route('**/*', route => {\n      setTimeout(() => route.continue(), 100); // Add 100ms delay\n    });\n    \n    await page.goto('/');\n    \n    // Check if we see any loading indicators\n    const loadingIndicators = [\n      '[data-loading]',\n      '.loading',\n      '.spinner',\n      '[aria-busy=\"true\"]'\n    ];\n    \n    for (const selector of loadingIndicators) {\n      const exists = await page.locator(selector).count();\n      if (exists > 0) {\n        console.log(`ðŸ”„ Found loading indicator: ${selector}`);\n      }\n    }\n    \n    // Wait for content to fully load\n    await page.waitForLoadState('networkidle');\n    \n    // Verify we have actual content, not just loading states\n    const hasContent = await page.evaluate(() => {\n      const textContent = document.body.textContent || '';\n      return textContent.length > 100; // Should have substantial content\n    });\n    \n    expect(hasContent).toBeTruthy();\n    console.log('âœ… Page has substantial content beyond loading states');\n  });\n\n  test('should be responsive and work on different viewport sizes', async () => {\n    console.log('ðŸ“± Testing responsive design...');\n    \n    const viewports = [\n      { name: 'Mobile', width: 375, height: 667 },\n      { name: 'Tablet', width: 768, height: 1024 },\n      { name: 'Desktop', width: 1920, height: 1080 }\n    ];\n    \n    for (const viewport of viewports) {\n      console.log(`ðŸ–¥ï¸ Testing ${viewport.name} viewport (${viewport.width}x${viewport.height})`);\n      \n      await page.setViewportSize({ \n        width: viewport.width, \n        height: viewport.height \n      });\n      \n      await page.goto('/');\n      await page.waitForLoadState('networkidle');\n      \n      // Verify content is visible at this viewport\n      const visibleContent = await page.locator('body').isVisible();\n      expect(visibleContent).toBeTruthy();\n      \n      // Take screenshot for this viewport\n      await page.screenshot({ \n        path: `test-results/viewport-${viewport.name.toLowerCase()}.png`\n      });\n      \n      console.log(`âœ… ${viewport.name} viewport test passed`);\n    }\n  });\n\n  test('should navigate between pages without white screens', async () => {\n    console.log('ðŸ§­ Testing navigation between pages...');\n    \n    await page.goto('/');\n    await page.waitForLoadState('networkidle');\n    \n    // Find navigation links\n    const navLinks = await page.locator('nav a, [role=\"navigation\"] a, header a').all();\n    \n    for (let i = 0; i < Math.min(navLinks.length, 5); i++) {\n      const link = navLinks[i];\n      const href = await link.getAttribute('href');\n      \n      if (href && href.startsWith('/')) {\n        console.log(`ðŸ”— Testing navigation to: ${href}`);\n        \n        await link.click();\n        await page.waitForLoadState('networkidle');\n        \n        // Verify we're not on a white screen\n        const hasContent = await page.evaluate(() => {\n          const textContent = document.body.textContent || '';\n          return textContent.trim().length > 50;\n        });\n        \n        expect(hasContent).toBeTruthy();\n        console.log(`âœ… Navigation to ${href} successful`);\n        \n        // Go back to home for next test\n        await page.goto('/');\n        await page.waitForLoadState('networkidle');\n      }\n    }\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/postcss.config.js","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/tailwind.config.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token {","line":1,"column":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Config } from \"tailwindcss\";\nimport tailwindcssAnimate from \"tailwindcss-animate\";\n\nexport default {\n\tdarkMode: [\"class\"],\n\tcontent: [\n\t\t\"./pages/**/*.{ts,tsx}\",\n\t\t\"./features/**/*.{ts,tsx}\",\n\t\t\"./shared/**/*.{ts,tsx}\",\n\t\t\"./app/**/*.{ts,tsx}\",\n\t\t\"./src/**/*.{ts,tsx}\",\n\t],\n\tprefix: \"\",\n\ttheme: {\n\t\tcontainer: {\n\t\t\tcenter: false,\n\t\t\tpadding: '0',\n\t\t\tscreens: {\n\t\t\t\t'sm': '100%',\n\t\t\t\t'md': '100%', \n\t\t\t\t'lg': '100%',\n\t\t\t\t'xl': '100%',\n\t\t\t\t'2xl': '100%'\n\t\t\t}\n\t\t},\n\t\textend: {\n\t\t\tfontFamily: {\n\t\t\t\t'sans': ['SF Pro Rounded', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],\n\t\t\t\t'sf-pro-rounded': ['SF Pro Rounded', '-apple-system', 'BlinkMacSystemFont', 'sans-serif'],\n\t\t\t},\n\t\t\tcolors: {\n\t\t\t\tborder: 'hsl(var(--border))',\n\t\t\t\tinput: 'hsl(var(--input))',\n\t\t\t\tring: 'hsl(var(--ring))',\n\t\t\t\tbackground: 'hsl(var(--background))',\n\t\t\t\tforeground: 'hsl(var(--foreground))',\n\t\t\t\tprimary: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--primary))',\n\t\t\t\t\tforeground: 'hsl(var(--primary-foreground))'\n\t\t\t\t},\n\t\t\t\tsecondary: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--secondary))',\n\t\t\t\t\tforeground: 'hsl(var(--secondary-foreground))'\n\t\t\t\t},\n\t\t\t\tdestructive: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--destructive))',\n\t\t\t\t\tforeground: 'hsl(var(--destructive-foreground))'\n\t\t\t\t},\n\t\t\t\tmuted: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--muted))',\n\t\t\t\t\tforeground: 'hsl(var(--muted-foreground))'\n\t\t\t\t},\n\t\t\t\taccent: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--accent))',\n\t\t\t\t\tforeground: 'hsl(var(--accent-foreground))'\n\t\t\t\t},\n\t\t\t\tpopover: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--popover))',\n\t\t\t\t\tforeground: 'hsl(var(--popover-foreground))'\n\t\t\t\t},\n\t\t\t\tcard: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--card))',\n\t\t\t\t\tforeground: 'hsl(var(--card-foreground))'\n\t\t\t\t},\n\t\t\t\tsidebar: {\n\t\t\t\t\tDEFAULT: 'hsl(var(--sidebar-background))',\n\t\t\t\t\tforeground: 'hsl(var(--sidebar-foreground))',\n\t\t\t\t\tprimary: 'hsl(var(--sidebar-primary))',\n\t\t\t\t\t'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',\n\t\t\t\t\taccent: 'hsl(var(--sidebar-accent))',\n\t\t\t\t\t'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',\n\t\t\t\t\tborder: 'hsl(var(--sidebar-border))',\n\t\t\t\t\tring: 'hsl(var(--sidebar-ring))'\n\t\t\t\t}\n\t\t\t},\n\t\t\tborderRadius: {\n\t\t\t\tlg: 'var(--radius)',\n\t\t\t\tmd: 'calc(var(--radius) - 2px)',\n\t\t\t\tsm: 'calc(var(--radius) - 4px)'\n\t\t\t},\n\t\t\tkeyframes: {\n\t\t\t\t'accordion-down': {\n\t\t\t\t\tfrom: {\n\t\t\t\t\t\theight: '0'\n\t\t\t\t\t},\n\t\t\t\t\tto: {\n\t\t\t\t\t\theight: 'var(--radix-accordion-content-height)'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'accordion-up': {\n\t\t\t\t\tfrom: {\n\t\t\t\t\t\theight: 'var(--radix-accordion-content-height)'\n\t\t\t\t\t},\n\t\t\t\t\tto: {\n\t\t\t\t\t\theight: '0'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation: {\n\t\t\t\t'accordion-down': 'accordion-down 0.2s ease-out',\n\t\t\t\t'accordion-up': 'accordion-up 0.2s ease-out'\n\t\t\t}\n\t\t}\n\t},\n\tplugins: [tailwindcssAnimate],\n} satisfies Config;\n","usedDeprecatedRules":[]},{"filePath":"/Users/damon/liquid-spark-finance/vite.config.ts","messages":[{"ruleId":null,"fatal":false,"severity":1,"message":"File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.","nodeType":null}],"suppressedMessages":[],"errorCount":0,"warningCount":1,"fatalErrorCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
